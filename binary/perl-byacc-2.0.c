/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 134 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
struct bucket;
#line 134 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
typedef struct bucket bucket;
#line 135 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
struct bucket {
   struct bucket *link ;
   struct bucket *next ;
   char *name ;
   char *tag ;
   short value ;
   short index ;
   short prec ;
   char class ;
   char assoc ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 202 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
enum __anonenum_Language_26 {
    C = 0,
    PERL = 1
} ;
#line 202 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
typedef enum __anonenum_Language_26 Language;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 165 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
struct shifts;
#line 165 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
typedef struct shifts shifts;
#line 166 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
struct shifts {
   struct shifts *next ;
   short number ;
   short nshifts ;
   short shift[1] ;
};
#line 189
struct action;
#line 189 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
typedef struct action action;
#line 190 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
struct action {
   struct action *next ;
   short symbol ;
   short number ;
   short prec ;
   char action_code ;
   char assoc ;
   char suppressed ;
};
#line 151
struct core;
#line 151 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
typedef struct core core;
#line 152 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
struct core {
   struct core *next ;
   struct core *link ;
   short number ;
   short accessing_symbol ;
   short nitems ;
   short items[1] ;
};
#line 177
struct reductions;
#line 177 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
typedef struct reductions reductions;
#line 178 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
struct reductions {
   struct reductions *next ;
   short number ;
   short nreds ;
   short rules[1] ;
};
#line 3 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
struct shorts {
   struct shorts *next ;
   short value ;
};
#line 3 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
typedef struct shorts shorts;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 275 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
bucket *first_symbol  ;
#line 276 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
bucket *last_symbol  ;
#line 307
void create_symbol_table(void) ;
#line 317
void free_symbol_table(void) ;
#line 318
void free_symbols(void) ;
#line 322
bucket *lookup(char *name ) ;
#line 324
bucket *make_bucket(char *name ) ;
#line 327
char *my_malloc(unsigned int n ) ;
#line 10 "/home/wheatley/newnew/temp/perl-byacc-2.0/symtab.c"
bucket **symbol_table  ;
#line 16 "/home/wheatley/newnew/temp/perl-byacc-2.0/symtab.c"
static int hash(char *name ) 
{ 
  register char *s ;
  register int c ;
  register int k ;

  {
#line 25
  if ((unsigned long )name != (unsigned long )((char *)((void *)0))) {
#line 25
    if (! *name) {
      {
#line 25
      __assert_fail("name != (char *) ((void *)0) && *name", "/home/wheatley/newnew/temp/perl-byacc-2.0/symtab.c",
                    25U, "hash");
      }
    }
  } else {
    {
#line 25
    __assert_fail("name != (char *) ((void *)0) && *name", "/home/wheatley/newnew/temp/perl-byacc-2.0/symtab.c",
                  25U, "hash");
    }
  }
#line 26
  s = name;
#line 27
  k = (int )*s;
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    s ++;
#line 28
    c = (int )*s;
#line 28
    if (! c) {
#line 28
      goto while_break;
    }
#line 29
    k = (31 * k + c) & 1023;
  }
  while_break: /* CIL Label */ ;
  }
#line 31
  return (k);
}
}
#line 36 "/home/wheatley/newnew/temp/perl-byacc-2.0/symtab.c"
bucket *make_bucket(char *name ) 
{ 
  register bucket *bp ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 44
  if (! ((unsigned long )name != (unsigned long )((char *)((void *)0)))) {
    {
#line 44
    __assert_fail("name != (char *) ((void *)0)", "/home/wheatley/newnew/temp/perl-byacc-2.0/symtab.c",
                  44U, "make_bucket");
    }
  }
  {
#line 45
  tmp = my_malloc((unsigned int )sizeof(bucket ));
#line 45
  bp = (bucket *)tmp;
#line 46
  bp->link = (struct bucket *)0;
#line 47
  bp->next = (struct bucket *)0;
#line 48
  tmp___0 = strlen((char const   *)name);
#line 48
  bp->name = my_malloc((unsigned int )(tmp___0 + 1UL));
#line 49
  bp->tag = (char *)0;
#line 50
  bp->value = (short)-1;
#line 51
  bp->index = (short)0;
#line 52
  bp->prec = (short)0;
#line 53
  bp->class = (char)0;
#line 54
  bp->assoc = (char)0;
#line 56
  strcpy((char */* __restrict  */)bp->name, (char const   */* __restrict  */)name);
  }
#line 58
  return (bp);
}
}
#line 63 "/home/wheatley/newnew/temp/perl-byacc-2.0/symtab.c"
bucket *lookup(char *name ) 
{ 
  register bucket *bp ;
  register bucket **bpp ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 71
  tmp = hash(name);
#line 71
  bpp = symbol_table + tmp;
#line 72
  bp = *bpp;
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! bp) {
#line 74
      goto while_break;
    }
    {
#line 76
    tmp___0 = strcmp((char const   *)name, (char const   *)bp->name);
    }
#line 76
    if (tmp___0 == 0) {
#line 76
      return (bp);
    }
#line 77
    bpp = & bp->link;
#line 78
    bp = *bpp;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  bp = make_bucket(name);
#line 81
  *bpp = bp;
#line 82
  last_symbol->next = bp;
#line 83
  last_symbol = bp;
  }
#line 85
  return (bp);
}
}
#line 90 "/home/wheatley/newnew/temp/perl-byacc-2.0/symtab.c"
void create_symbol_table(void) 
{ 
  register int i ;
  register bucket *bp ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 98
  tmp = my_malloc((unsigned int )(1024UL * sizeof(bucket *)));
#line 98
  symbol_table = (bucket **)tmp;
#line 99
  i = 0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < 1024)) {
#line 99
      goto while_break;
    }
#line 100
    *(symbol_table + i) = (bucket *)0;
#line 99
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  bp = make_bucket((char *)"error");
#line 103
  bp->index = (short)1;
#line 104
  bp->class = (char)1;
#line 106
  first_symbol = bp;
#line 107
  last_symbol = bp;
#line 108
  tmp___0 = hash((char *)"error");
#line 108
  *(symbol_table + tmp___0) = bp;
  }
#line 109
  return;
}
}
#line 113 "/home/wheatley/newnew/temp/perl-byacc-2.0/symtab.c"
void free_symbol_table(void) 
{ 


  {
  {
#line 118
  free((void *)((char *)symbol_table));
#line 119
  symbol_table = (bucket **)0;
  }
#line 120
  return;
}
}
#line 124 "/home/wheatley/newnew/temp/perl-byacc-2.0/symtab.c"
void free_symbols(void) 
{ 
  register bucket *p ;
  register bucket *q ;

  {
#line 131
  p = first_symbol;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! p) {
#line 131
      goto while_break;
    }
    {
#line 133
    q = p->next;
#line 134
    free((void *)((char *)p));
#line 131
    p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  return;
}
}
#line 337 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
void reflexive_transitive_closure(unsigned int *R___0 , int n ) ;
#line 4 "/home/wheatley/newnew/temp/perl-byacc-2.0/warshall.c"
static void transitive_closure(unsigned int *R___0 , int n ) 
{ 
  register int rowsize ;
  register unsigned int mask ;
  register unsigned int *rowj ;
  register unsigned int *rp ;
  register unsigned int *rend ;
  register unsigned int *ccol ;
  register unsigned int *relend ;
  register unsigned int *cword ;
  register unsigned int *rowi ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;

  {
#line 21
  rowsize = (n + 31) / 32;
#line 22
  relend = R___0 + n * rowsize;
#line 24
  cword = R___0;
#line 25
  mask = 1U;
#line 26
  rowi = R___0;
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
#line 27
    if (! ((unsigned long )rowi < (unsigned long )relend)) {
#line 27
      goto while_break;
    }
#line 29
    ccol = cword;
#line 30
    rowj = R___0;
    {
#line 32
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 32
      if (! ((unsigned long )rowj < (unsigned long )relend)) {
#line 32
        goto while_break___0;
      }
#line 34
      if (*ccol & mask) {
#line 36
        rp = rowi;
#line 37
        rend = rowj + rowsize;
        {
#line 38
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 38
          if (! ((unsigned long )rowj < (unsigned long )rend)) {
#line 38
            goto while_break___1;
          }
#line 39
          tmp = rowj;
#line 39
          rowj ++;
#line 39
          tmp___0 = rp;
#line 39
          rp ++;
#line 39
          *tmp |= *tmp___0;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 43
        rowj += rowsize;
      }
#line 46
      ccol += rowsize;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 49
    mask <<= 1;
#line 50
    if (mask == 0U) {
#line 52
      mask = 1U;
#line 53
      cword ++;
    }
#line 56
    rowi += rowsize;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  return;
}
}
#line 61 "/home/wheatley/newnew/temp/perl-byacc-2.0/warshall.c"
void reflexive_transitive_closure(unsigned int *R___0 , int n ) 
{ 
  register int rowsize ;
  register unsigned int mask ;
  register unsigned int *rp ;
  register unsigned int *relend ;

  {
  {
#line 73
  transitive_closure(R___0, n);
#line 75
  rowsize = (n + 31) / 32;
#line 76
  relend = R___0 + n * rowsize;
#line 78
  mask = 1U;
#line 79
  rp = R___0;
  }
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! ((unsigned long )rp < (unsigned long )relend)) {
#line 80
      goto while_break;
    }
#line 82
    *rp |= mask;
#line 83
    mask <<= 1;
#line 84
    if (mask == 0U) {
#line 86
      mask = 1U;
#line 87
      rp ++;
    }
#line 90
    rp += rowsize;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 606
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) mktemp)(char *template ) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 206 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char dflag  ;
#line 207 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char lflag  ;
#line 208 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char rflag  ;
#line 209 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char tflag  ;
#line 210 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char vflag  ;
#line 211 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char perl5005flag  ;
#line 213
Language language ;
#line 215
char *myname ;
#line 218 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
int lineno  ;
#line 219 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
int outline  ;
#line 227
int prefix_changed ;
#line 228
char *define_prefix ;
#line 229
char *symbol_prefix ;
#line 230
char *perl_package ;
#line 232 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char *action_file_name  ;
#line 233 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char *code_file_name  ;
#line 234 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char *defines_file_name  ;
#line 235
char *input_file_name ;
#line 236 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char *output_file_name  ;
#line 237 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char *text_file_name  ;
#line 238 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char *union_file_name  ;
#line 239 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char *verbose_file_name  ;
#line 241 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
FILE *action_file  ;
#line 242 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
FILE *code_file  ;
#line 243 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
FILE *defines_file  ;
#line 244 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
FILE *input_file  ;
#line 245 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
FILE *output_file  ;
#line 246 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
FILE *text_file  ;
#line 247 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
FILE *union_file  ;
#line 248 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
FILE *verbose_file  ;
#line 250 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
int nitems  ;
#line 251 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
int nrules  ;
#line 252 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
int nsyms  ;
#line 253 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
int ntokens  ;
#line 254 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
int nvars  ;
#line 260 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
int start_symbol  ;
#line 261 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char **symbol_name  ;
#line 262 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
short *symbol_value  ;
#line 263 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
short *symbol_prec  ;
#line 264 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char *symbol_assoc  ;
#line 266 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
short *ritem  ;
#line 267 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
short *rlhs  ;
#line 268 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
short *rrhs  ;
#line 269 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
short *rprec  ;
#line 270 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char *rassoc  ;
#line 272 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
short **derives  ;
#line 273 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char *nullable  ;
#line 305
char *allocate(unsigned int n ) ;
#line 311
void done(int k ) ;
#line 321
void lalr(void) ;
#line 323
void lr0(void) ;
#line 325
void make_parser(void) ;
#line 326
char *my_calloc(unsigned int k , unsigned int n ) ;
#line 328
char *my_realloc(char *p , unsigned int n ) ;
#line 330
void no_space(void) ;
#line 331
void open_error(char *filename ) ;
#line 332
void output(void) ;
#line 336
void reader(void) ;
#line 359
void verbose(void) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 13 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
char *myname  =    (char *)"pbyacc";
#line 15 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
char *file_prefix  =    (char *)"y";
#line 16 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
char *temp_form  ;
#line 18 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
int prefix_changed  =    0;
#line 19 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
char *define_prefix  =    (char *)"YY";
#line 20 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
char *symbol_prefix  =    (char *)"yy";
#line 22 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
Language language  =    (Language )0;
#line 23 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
char *c_suffixes[4]  = {      (char *)".code.c",      (char *)".tab.h",      (char *)".tab.c",      (char *)".output"};
#line 24 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
char *perl_suffixes[4]  = {      (char *)".code.pl",      (char *)".tab.ph",      (char *)".tab.pl",      (char *)".output"};
#line 25 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
char **suffixes  =    c_suffixes;
#line 27 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
char *perl_package  =    (char *)0;
#line 35 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
char *input_file_name  =    (char *)"";
#line 95
extern int ( /* missing proto */  unlink)() ;
#line 89 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
void done(int k ) 
{ 


  {
#line 95
  if (action_file) {
    {
#line 95
    fclose(action_file);
#line 95
    unlink(action_file_name);
    }
  }
#line 96
  if (text_file) {
    {
#line 96
    fclose(text_file);
#line 96
    unlink(text_file_name);
    }
  }
#line 97
  if (union_file) {
    {
#line 97
    fclose(union_file);
#line 97
    unlink(union_file_name);
    }
  }
  {
#line 98
  exit(k);
  }
}
}
#line 103 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
static void onintr(int junk ) 
{ 


  {
  {
#line 108
  done(1);
  }
#line 109
  return;
}
}
#line 113 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
static void set_signals(void) 
{ 
  __sighandler_t tmp ;
  __sighandler_t tmp___0 ;
  __sighandler_t tmp___1 ;

  {
  {
#line 119
  tmp = signal(2, (void (*)(int  ))1);
  }
#line 119
  if ((unsigned long )tmp != (unsigned long )((void (*)(int  ))1)) {
    {
#line 120
    signal(2, & onintr);
    }
  }
  {
#line 123
  tmp___0 = signal(15, (void (*)(int  ))1);
  }
#line 123
  if ((unsigned long )tmp___0 != (unsigned long )((void (*)(int  ))1)) {
    {
#line 124
    signal(15, & onintr);
    }
  }
  {
#line 127
  tmp___1 = signal(1, (void (*)(int  ))1);
  }
#line 127
  if ((unsigned long )tmp___1 != (unsigned long )((void (*)(int  ))1)) {
    {
#line 128
    signal(1, & onintr);
    }
  }
#line 130
  return;
}
}
#line 134 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
static void usage(void) 
{ 


  {
  {
#line 139
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [-Ccdlrtv] [-b file_prefix] [-p sym_prefix] [-P package] filename\n",
          myname);
#line 142
  exit(1);
  }
}
}
#line 147 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
static void getargs(int argc , char **argv ) 
{ 
  register int i ;
  register char *s ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 157
  if (argc > 0) {
#line 157
    myname = *(argv + 0);
  }
  {
#line 159
  s = strrchr((char const   *)myname, '/');
  }
#line 160
  if ((unsigned long )s == (unsigned long )((char *)((void *)0))) {
#line 168
    s = myname;
  } else {
#line 172
    s ++;
  }
  {
#line 173
  tmp = strlen((char const   *)s);
#line 173
  temp_form = my_malloc((unsigned int )(tmp + sizeof(".XXXXXXX")));
#line 174
  sprintf((char */* __restrict  */)temp_form, (char const   */* __restrict  */)"%s.XXXXXXX",
          s);
#line 176
  i = 1;
  }
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (i < argc)) {
#line 176
      goto while_break;
    }
#line 178
    s = *(argv + i);
#line 179
    if ((int )*s != 45) {
#line 179
      goto while_break;
    }
#line 180
    s ++;
    {
#line 182
    if ((int )*s == 0) {
#line 182
      goto case_0;
    }
#line 187
    if ((int )*s == 45) {
#line 187
      goto case_45;
    }
#line 191
    if ((int )*s == 53) {
#line 191
      goto case_53;
    }
#line 195
    if ((int )*s == 98) {
#line 195
      goto case_98;
    }
#line 205
    if ((int )*s == 67) {
#line 205
      goto case_67;
    }
#line 205
    if ((int )*s == 99) {
#line 205
      goto case_67;
    }
#line 210
    if ((int )*s == 100) {
#line 210
      goto case_100;
    }
#line 214
    if ((int )*s == 108) {
#line 214
      goto case_108;
    }
#line 218
    if ((int )*s == 112) {
#line 218
      goto case_112;
    }
#line 227
    if ((int )*s == 80) {
#line 227
      goto case_80;
    }
#line 238
    if ((int )*s == 114) {
#line 238
      goto case_114;
    }
#line 242
    if ((int )*s == 116) {
#line 242
      goto case_116;
    }
#line 246
    if ((int )*s == 118) {
#line 246
      goto case_118;
    }
#line 250
    if ((int )*s == 86) {
#line 250
      goto case_86;
    }
#line 254
    goto switch_default;
    case_0: /* CIL Label */ 
#line 183
    input_file = stdin;
#line 184
    if (i + 1 < argc) {
      {
#line 184
      usage();
      }
    }
#line 185
    return;
    case_45: /* CIL Label */ 
#line 188
    i ++;
#line 189
    goto no_more_options;
    case_53: /* CIL Label */ 
#line 192
    perl5005flag = (char)1;
#line 193
    goto switch_break;
    case_98: /* CIL Label */ 
#line 196
    s ++;
#line 196
    if (*s) {
#line 197
      file_prefix = s;
    } else {
#line 198
      i ++;
#line 198
      if (i < argc) {
#line 199
        file_prefix = *(argv + i);
      } else {
        {
#line 201
        usage();
        }
      }
    }
#line 202
    goto __Cont;
    case_67: /* CIL Label */ 
    case_99: /* CIL Label */ 
#line 206
    language = (Language )0;
#line 207
    suffixes = c_suffixes;
#line 208
    goto switch_break;
    case_100: /* CIL Label */ 
#line 211
    dflag = (char)1;
#line 212
    goto switch_break;
    case_108: /* CIL Label */ 
#line 215
    lflag = (char)1;
#line 216
    goto switch_break;
    case_112: /* CIL Label */ 
#line 219
    s ++;
#line 219
    if (*s) {
#line 220
      symbol_prefix = s;
    } else {
#line 221
      i ++;
#line 221
      if (i < argc) {
#line 222
        symbol_prefix = *(argv + i);
      } else {
        {
#line 224
        usage();
        }
      }
    }
#line 225
    goto __Cont;
    case_80: /* CIL Label */ 
#line 228
    language = (Language )1;
#line 229
    suffixes = perl_suffixes;
#line 230
    s ++;
#line 230
    if (*s) {
#line 231
      perl_package = s;
    } else {
#line 232
      i ++;
#line 232
      if (i < argc) {
#line 233
        perl_package = *(argv + i);
      } else {
        {
#line 235
        usage();
        }
      }
    }
#line 236
    goto __Cont;
    case_114: /* CIL Label */ 
#line 239
    rflag = (char)1;
#line 240
    goto switch_break;
    case_116: /* CIL Label */ 
#line 243
    tflag = (char)1;
#line 244
    goto switch_break;
    case_118: /* CIL Label */ 
#line 247
    vflag = (char)1;
#line 248
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 251
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            myname, "Berkeley yacc version 1.8.2 (C or perl)");
#line 252
    exit(1);
    }
    switch_default: /* CIL Label */ 
    {
#line 255
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 258
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 260
      s ++;
      {
#line 262
      if ((int )*s == 0) {
#line 262
        goto case_0___0;
      }
#line 266
      if ((int )*s == 67) {
#line 266
        goto case_67___0;
      }
#line 266
      if ((int )*s == 99) {
#line 266
        goto case_67___0;
      }
#line 271
      if ((int )*s == 100) {
#line 271
        goto case_100___0;
      }
#line 275
      if ((int )*s == 108) {
#line 275
        goto case_108___0;
      }
#line 279
      if ((int )*s == 80) {
#line 279
        goto case_80___0;
      }
#line 284
      if ((int )*s == 114) {
#line 284
        goto case_114___0;
      }
#line 288
      if ((int )*s == 116) {
#line 288
        goto case_116___0;
      }
#line 292
      if ((int )*s == 118) {
#line 292
        goto case_118___0;
      }
#line 296
      if ((int )*s == 86) {
#line 296
        goto case_86___0;
      }
#line 300
      goto switch_default___0;
      case_0___0: /* CIL Label */ 
#line 263
      goto end_of_option;
      case_67___0: /* CIL Label */ 
      case_99___0: /* CIL Label */ 
#line 267
      language = (Language )0;
#line 268
      suffixes = c_suffixes;
#line 269
      goto switch_break___0;
      case_100___0: /* CIL Label */ 
#line 272
      dflag = (char)1;
#line 273
      goto switch_break___0;
      case_108___0: /* CIL Label */ 
#line 276
      lflag = (char)1;
#line 277
      goto switch_break___0;
      case_80___0: /* CIL Label */ 
#line 280
      language = (Language )1;
#line 281
      suffixes = perl_suffixes;
#line 282
      goto switch_break___0;
      case_114___0: /* CIL Label */ 
#line 285
      rflag = (char)1;
#line 286
      goto switch_break___0;
      case_116___0: /* CIL Label */ 
#line 289
      tflag = (char)1;
#line 290
      goto switch_break___0;
      case_118___0: /* CIL Label */ 
#line 293
      vflag = (char)1;
#line 294
      goto switch_break___0;
      case_86___0: /* CIL Label */ 
      {
#line 297
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
              myname, "Berkeley yacc version 1.8.2 (C or perl)");
#line 298
      exit(1);
      }
      switch_default___0: /* CIL Label */ 
      {
#line 301
      usage();
      }
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    end_of_option: ;
    __Cont: /* CIL Label */ 
#line 176
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  if ((unsigned int )language == 1U) {
#line 307
    if (rflag) {
      {
#line 308
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Warning: -r not recommended with Perl mode.\n",
              myname);
      }
    }
  }
#line 310
  if ((unsigned int )language == 1U) {
    {
#line 310
    tmp___0 = strcmp((char const   *)symbol_prefix, "yy");
    }
#line 310
    if (tmp___0 != 0) {
      {
#line 311
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Warning: -p not recommended with Perl mode.\n",
              myname);
      }
    }
  }
#line 313
  if ((unsigned int )language != 1U) {
#line 313
    if (perl5005flag) {
      {
#line 314
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Warning: -5 has no effect without Perl mode.\n",
              myname);
      }
    }
  }
  no_more_options: ;
#line 318
  if (i + 1 != argc) {
    {
#line 318
    usage();
    }
  }
#line 319
  input_file_name = *(argv + i);
#line 320
  return;
}
}
#line 324 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
char *allocate(unsigned int n ) 
{ 
  register char *p ;

  {
#line 332
  p = (char *)((void *)0);
#line 333
  if (n) {
    {
#line 335
    p = my_calloc(1U, n);
    }
  }
#line 337
  return (p);
}
}
#line 342 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
char *my_calloc(unsigned int k , unsigned int n ) 
{ 
  register char *p ;
  void *tmp ;

  {
  {
#line 354
  tmp = calloc((size_t )k, (size_t )n);
#line 354
  p = (char *)tmp;
  }
#line 355
  if (! p) {
    {
#line 355
    no_space();
    }
  }
#line 356
  return (p);
}
}
#line 361 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
char *my_malloc(unsigned int n ) 
{ 
  register char *p ;
  void *tmp ;

  {
  {
#line 372
  tmp = malloc((size_t )n);
#line 372
  p = (char *)tmp;
  }
#line 373
  if (! p) {
    {
#line 373
    no_space();
    }
  }
#line 374
  return (p);
}
}
#line 379 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
char *my_realloc(char *p , unsigned int n ) 
{ 
  void *tmp ;

  {
  {
#line 390
  tmp = realloc((void *)p, (size_t )n);
#line 390
  p = (char *)tmp;
  }
#line 391
  if (! p) {
    {
#line 391
    no_space();
    }
  }
#line 392
  return (p);
}
}
#line 397 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
static void create_file_names(void) 
{ 
  int i ;
  int len ;
  char *tmpdir ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int len___0 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 405
  tmpdir = getenv("TMPDIR");
  }
#line 409
  if ((unsigned long )tmpdir == (unsigned long )((char *)((void *)0))) {
#line 409
    tmpdir = (char *)"/tmp";
  }
  {
#line 412
  tmp = strlen((char const   *)tmpdir);
#line 412
  len = (int )tmp;
#line 413
  tmp___0 = strlen((char const   *)temp_form);
#line 413
  i = (int )(((size_t )len + tmp___0) + 1UL);
  }
#line 418
  if (len) {
#line 418
    if ((int )*(tmpdir + (len - 1)) != 47) {
#line 419
      i ++;
    }
  }
  {
#line 422
  action_file_name = my_malloc((unsigned int )i);
#line 423
  text_file_name = my_malloc((unsigned int )i);
#line 424
  union_file_name = my_malloc((unsigned int )i);
#line 426
  strcpy((char */* __restrict  */)action_file_name, (char const   */* __restrict  */)tmpdir);
#line 427
  strcpy((char */* __restrict  */)text_file_name, (char const   */* __restrict  */)tmpdir);
#line 428
  strcpy((char */* __restrict  */)union_file_name, (char const   */* __restrict  */)tmpdir);
  }
#line 438
  if (len) {
#line 438
    if ((int )*(tmpdir + (len - 1)) != 47) {
#line 439
      *(action_file_name + len) = (char )'/';
#line 440
      *(text_file_name + len) = (char )'/';
#line 441
      *(union_file_name + len) = (char )'/';
#line 442
      len ++;
    }
  }
  {
#line 446
  strcpy((char */* __restrict  */)(action_file_name + len), (char const   */* __restrict  */)temp_form);
#line 447
  strcpy((char */* __restrict  */)(text_file_name + len), (char const   */* __restrict  */)temp_form);
#line 448
  strcpy((char */* __restrict  */)(union_file_name + len), (char const   */* __restrict  */)temp_form);
#line 450
  free((void *)temp_form);
#line 451
  temp_form = (char *)((void *)0);
#line 453
  *(action_file_name + (len + 5)) = (char )'a';
#line 454
  *(text_file_name + (len + 5)) = (char )'t';
#line 455
  *(union_file_name + (len + 5)) = (char )'u';
#line 457
  mktemp(action_file_name);
#line 458
  mktemp(text_file_name);
#line 459
  mktemp(union_file_name);
#line 461
  tmp___1 = strlen((char const   *)file_prefix);
#line 461
  len = (int )tmp___1;
  }
#line 463
  if ((unsigned int )language == 1U) {
    {
#line 464
    tmp___2 = strlen((char const   *)perl_package);
#line 464
    len___0 = (int )tmp___2;
#line 465
    output_file_name = my_malloc((unsigned int )(len___0 + 4));
#line 466
    strcpy((char */* __restrict  */)output_file_name, (char const   */* __restrict  */)perl_package);
#line 467
    strcpy((char */* __restrict  */)(output_file_name + len___0), (char const   */* __restrict  */)".pm");
    }
  } else {
    {
#line 470
    tmp___3 = strlen((char const   *)*(suffixes + 2));
#line 470
    output_file_name = my_malloc((unsigned int )(((size_t )len + tmp___3) + 1UL));
#line 471
    strcpy((char */* __restrict  */)output_file_name, (char const   */* __restrict  */)file_prefix);
#line 472
    strcpy((char */* __restrict  */)(output_file_name + len), (char const   */* __restrict  */)*(suffixes + 2));
    }
  }
#line 475
  if (rflag) {
    {
#line 477
    tmp___4 = strlen((char const   *)*(suffixes + 0));
#line 477
    code_file_name = my_malloc((unsigned int )(((size_t )len + tmp___4) + 1UL));
#line 478
    strcpy((char */* __restrict  */)code_file_name, (char const   */* __restrict  */)file_prefix);
#line 479
    strcpy((char */* __restrict  */)(code_file_name + len), (char const   */* __restrict  */)*(suffixes + 0));
    }
  } else {
#line 482
    code_file_name = output_file_name;
  }
#line 484
  if (dflag) {
    {
#line 486
    tmp___5 = strlen((char const   *)*(suffixes + 1));
#line 486
    defines_file_name = my_malloc((unsigned int )(((size_t )len + tmp___5) + 1UL));
#line 487
    strcpy((char */* __restrict  */)defines_file_name, (char const   */* __restrict  */)file_prefix);
#line 488
    strcpy((char */* __restrict  */)(defines_file_name + len), (char const   */* __restrict  */)*(suffixes + 1));
    }
  }
#line 491
  if (vflag) {
    {
#line 493
    tmp___6 = strlen((char const   *)*(suffixes + 3));
#line 493
    verbose_file_name = my_malloc((unsigned int )(((size_t )len + tmp___6) + 1UL));
#line 494
    strcpy((char */* __restrict  */)verbose_file_name, (char const   */* __restrict  */)file_prefix);
#line 495
    strcpy((char */* __restrict  */)(verbose_file_name + len), (char const   */* __restrict  */)*(suffixes + 3));
    }
  }
#line 497
  return;
}
}
#line 501 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
static void open_files(void) 
{ 


  {
  {
#line 506
  create_file_names();
  }
#line 508
  if ((unsigned long )input_file == (unsigned long )((FILE *)0)) {
    {
#line 510
    input_file = fopen((char const   */* __restrict  */)input_file_name, (char const   */* __restrict  */)"r");
    }
#line 511
    if ((unsigned long )input_file == (unsigned long )((FILE *)0)) {
      {
#line 512
      open_error(input_file_name);
      }
    }
  }
  {
#line 515
  action_file = fopen((char const   */* __restrict  */)action_file_name, (char const   */* __restrict  */)"w");
  }
#line 516
  if ((unsigned long )action_file == (unsigned long )((FILE *)0)) {
    {
#line 517
    open_error(action_file_name);
    }
  }
  {
#line 519
  text_file = fopen((char const   */* __restrict  */)text_file_name, (char const   */* __restrict  */)"w");
  }
#line 520
  if ((unsigned long )text_file == (unsigned long )((FILE *)0)) {
    {
#line 521
    open_error(text_file_name);
    }
  }
#line 523
  if (vflag) {
    {
#line 525
    verbose_file = fopen((char const   */* __restrict  */)verbose_file_name, (char const   */* __restrict  */)"w");
    }
#line 526
    if ((unsigned long )verbose_file == (unsigned long )((FILE *)0)) {
      {
#line 527
      open_error(verbose_file_name);
      }
    }
  }
#line 530
  if (dflag) {
    {
#line 532
    defines_file = fopen((char const   */* __restrict  */)defines_file_name, (char const   */* __restrict  */)"w");
    }
#line 533
    if ((unsigned long )defines_file == (unsigned long )((FILE *)0)) {
      {
#line 534
      open_error(defines_file_name);
      }
    }
    {
#line 535
    union_file = fopen((char const   */* __restrict  */)union_file_name, (char const   */* __restrict  */)"w");
    }
#line 536
    if ((unsigned long )union_file == (unsigned long )((FILE *)0)) {
      {
#line 537
      open_error(union_file_name);
      }
    }
  }
  {
#line 540
  output_file = fopen((char const   */* __restrict  */)output_file_name, (char const   */* __restrict  */)"w");
  }
#line 541
  if ((unsigned long )output_file == (unsigned long )((FILE *)0)) {
    {
#line 542
    open_error(output_file_name);
    }
  }
#line 544
  if (rflag) {
    {
#line 546
    code_file = fopen((char const   */* __restrict  */)code_file_name, (char const   */* __restrict  */)"w");
    }
#line 547
    if ((unsigned long )code_file == (unsigned long )((FILE *)0)) {
      {
#line 548
      open_error(code_file_name);
      }
    }
  } else {
#line 551
    code_file = output_file;
  }
#line 552
  return;
}
}
#line 556 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
static void fix_defsym_prefix(void) 
{ 
  char *from ;
  int num_lower ;
  char *to ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  unsigned short const   **tmp___9 ;

  {
  {
#line 562
  num_lower = 0;
#line 565
  tmp = strcmp((char const   *)symbol_prefix, "yy");
  }
#line 565
  if (tmp == 0) {
#line 566
    return;
  }
  {
#line 568
  from = symbol_prefix;
#line 571
  tmp___0 = __ctype_b_loc();
  }
#line 571
  if (! ((int const   )*(*tmp___0 + (int )*from) & 1024)) {
#line 571
    if ((int )*from != 95) {
      {
#line 572
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: symbol prefix (%s) must start with an underline or letter\n",
              myname, symbol_prefix);
#line 575
      exit(1);
      }
    }
  }
  {
#line 578
  while (1) {
    while_continue: /* CIL Label */ ;
#line 578
    if (! *from) {
#line 578
      goto while_break;
    }
    {
#line 579
    tmp___5 = __ctype_b_loc();
    }
#line 579
    if ((int const   )*(*tmp___5 + (int )*from) & 8) {
#line 579
      goto _L;
    } else
#line 579
    if ((int )*from == 95) {
      _L: /* CIL Label */ 
      {
#line 580
      tmp___1 = __ctype_b_loc();
      }
#line 580
      if ((int const   )*(*tmp___1 + (int )*from) & 512) {
#line 581
        num_lower ++;
      }
    } else {
      {
#line 584
      tmp___4 = __ctype_b_loc();
      }
#line 584
      if ((int const   )*(*tmp___4 + (int )*from) & 32768) {
#line 584
        tmp___3 = (int )*from;
      } else {
#line 584
        tmp___3 = '?';
      }
      {
#line 584
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: invalid character (%c) in symbol prefix (%s)\n",
              myname, tmp___3, symbol_prefix);
#line 587
      exit(1);
      }
    }
#line 578
    from ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 590
  if (num_lower == 0) {
    {
#line 591
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: symbol prefix (%s) must contain at least 1 lower case character\n",
            myname, symbol_prefix);
#line 594
    exit(1);
    }
  }
  {
#line 596
  define_prefix = my_malloc((unsigned int )((from - symbol_prefix) + 1L));
#line 597
  to = define_prefix;
#line 597
  from = symbol_prefix;
  }
  {
#line 597
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 597
    if (! *from) {
#line 597
      goto while_break___0;
    }
    {
#line 598
    tmp___9 = __ctype_b_loc();
    }
#line 598
    if ((int const   )*(*tmp___9 + (int )*from) & 512) {
      {
#line 599
      tmp___6 = to;
#line 599
      to ++;
#line 599
      tmp___7 = toupper((int )*from);
#line 599
      *tmp___6 = (char )tmp___7;
      }
    } else {
#line 601
      tmp___8 = to;
#line 601
      to ++;
#line 601
      *tmp___8 = *from;
    }
#line 597
    from ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 603
  *to = *from;
#line 604
  prefix_changed = 1;
#line 605
  return;
}
}
#line 608 "/home/wheatley/newnew/temp/perl-byacc-2.0/main.c"
int main(int argc , char **argv ) 
{ 


  {
  {
#line 615
  set_signals();
#line 616
  getargs(argc, argv);
#line 617
  fix_defsym_prefix();
#line 618
  open_files();
#line 619
  reader();
#line 620
  lr0();
#line 621
  lalr();
#line 622
  make_parser();
#line 623
  verbose();
#line 624
  output();
#line 625
  done(0);
  }
#line 627
  return (0);
}
}
#line 221 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char **banner[2] ;
#line 222
char **tables[2] ;
#line 223
char **header[2] ;
#line 224
char **body[2] ;
#line 225
char **trailer[2] ;
#line 360
void write_section(char ***section ) ;
#line 9 "/home/wheatley/newnew/temp/perl-byacc-2.0/skeleton.c"
static char *c_banner[5]  = {      (char *)"#ifndef lint",      (char *)"static char yysccsid[] = \"@(#)yaccpar 1.8 (Berkeley) 01/20/91\";",      (char *)"#endif",      (char *)"#define YYBYACC 1", 
        (char *)((void *)0)};
#line 18 "/home/wheatley/newnew/temp/perl-byacc-2.0/skeleton.c"
static char *perl_banner[2]  = {      (char *)"# @(#)yaccpar 1.8 (Berkeley) 01/20/91 (JAKE-P5BP-0.6 04/26/98)",      (char *)((void *)0)};
#line 24 "/home/wheatley/newnew/temp/perl-byacc-2.0/skeleton.c"
char **banner[2]  = {      c_banner,      perl_banner};
#line 26 "/home/wheatley/newnew/temp/perl-byacc-2.0/skeleton.c"
static char *c_tables[14]  = 
#line 26
  {      (char *)"extern short yylhs[];",      (char *)"extern short yylen[];",      (char *)"extern short yydefred[];",      (char *)"extern short yydgoto[];", 
        (char *)"extern short yysindex[];",      (char *)"extern short yyrindex[];",      (char *)"extern short yygindex[];",      (char *)"extern short yytable[];", 
        (char *)"extern short yycheck[];",      (char *)"#if YYDEBUG",      (char *)"extern char *yyname[];",      (char *)"extern char *yyrule[];", 
        (char *)"#endif",      (char *)((void *)0)};
#line 44 "/home/wheatley/newnew/temp/perl-byacc-2.0/skeleton.c"
char **tables[2]  = {      c_tables,      (char **)((void *)0)};
#line 46 "/home/wheatley/newnew/temp/perl-byacc-2.0/skeleton.c"
static char *c_header[26]  = 
#line 46
  {      (char *)"#define yyclearin (yychar=(-1))",      (char *)"#define yyerrok (yyerrflag=0)",      (char *)"#ifdef YYSTACKSIZE",      (char *)"#ifndef YYMAXDEPTH", 
        (char *)"#define YYMAXDEPTH YYSTACKSIZE",      (char *)"#endif",      (char *)"#else",      (char *)"#ifdef YYMAXDEPTH", 
        (char *)"#define YYSTACKSIZE YYMAXDEPTH",      (char *)"#else",      (char *)"#define YYSTACKSIZE 500",      (char *)"#define YYMAXDEPTH 500", 
        (char *)"#endif",      (char *)"#endif",      (char *)"int yydebug;",      (char *)"int yynerrs;", 
        (char *)"int yyerrflag;",      (char *)"int yychar;",      (char *)"short *yyssp;",      (char *)"YYSTYPE *yyvsp;", 
        (char *)"YYSTYPE yyval;",      (char *)"YYSTYPE yylval;",      (char *)"short yyss[YYSTACKSIZE];",      (char *)"YYSTYPE yyvs[YYSTACKSIZE];", 
        (char *)"#define yystacksize YYSTACKSIZE",      (char *)((void *)0)};
#line 76 "/home/wheatley/newnew/temp/perl-byacc-2.0/skeleton.c"
static char *perl_header[11]  = 
#line 76
  {      (char *)"sub yyclearin {",      (char *)"  my PP $p;",      (char *)"  ($p) = @_;",      (char *)"  $p->{yychar} = -1;", 
        (char *)"}",      (char *)"sub yyerrok {",      (char *)"  my PP $p;",      (char *)"  ($p) = @_;", 
        (char *)"  $p->{yyerrflag} = 0;",      (char *)"}",      (char *)((void *)0)};
#line 91 "/home/wheatley/newnew/temp/perl-byacc-2.0/skeleton.c"
char **header[2]  = {      c_header,      perl_header};
#line 93 "/home/wheatley/newnew/temp/perl-byacc-2.0/skeleton.c"
static char *c_body[140]  = 
#line 93
  {      (char *)"#define YYABORT goto yyabort",      (char *)"#define YYACCEPT goto yyaccept",      (char *)"#define YYERROR goto yyerrlab",      (char *)"int", 
        (char *)"yyparse()",      (char *)"{",      (char *)"    register int yym, yyn, yystate;",      (char *)"#if YYDEBUG", 
        (char *)"    register char *yys;",      (char *)"    extern char *getenv();",      (char *)"",      (char *)"    if (yys = getenv(\"YYDEBUG\"))", 
        (char *)"    {",      (char *)"        yyn = *yys;",      (char *)"        if (yyn >= \'0\' && yyn <= \'9\')",      (char *)"            yydebug = yyn - \'0\';", 
        (char *)"    }",      (char *)"#endif",      (char *)"",      (char *)"    yynerrs = 0;", 
        (char *)"    yyerrflag = 0;",      (char *)"    yychar = (-1);",      (char *)"",      (char *)"    yyssp = yyss;", 
        (char *)"    yyvsp = yyvs;",      (char *)"    *yyssp = yystate = 0;",      (char *)"",      (char *)"yyloop:", 
        (char *)"    if (yyn = yydefred[yystate]) goto yyreduce;",      (char *)"    if (yychar < 0)",      (char *)"    {",      (char *)"        if ((yychar = yylex()) < 0) yychar = 0;", 
        (char *)"#if YYDEBUG",      (char *)"        if (yydebug)",      (char *)"        {",      (char *)"            yys = 0;", 
        (char *)"            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",      (char *)"            if (!yys) yys = \"illegal-symbol\";",      (char *)"            printf(\"yydebug: state %d, reading %d (%s)\\n\", yystate,",      (char *)"                    yychar, yys);", 
        (char *)"        }",      (char *)"#endif",      (char *)"    }",      (char *)"    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&", 
        (char *)"            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",      (char *)"    {",      (char *)"#if YYDEBUG",      (char *)"        if (yydebug)", 
        (char *)"            printf(\"yydebug: state %d, shifting to state %d\\n\",",      (char *)"                    yystate, yytable[yyn]);",      (char *)"#endif",      (char *)"        if (yyssp >= yyss + yystacksize - 1)", 
        (char *)"        {",      (char *)"            goto yyoverflow;",      (char *)"        }",      (char *)"        *++yyssp = yystate = yytable[yyn];", 
        (char *)"        *++yyvsp = yylval;",      (char *)"        yychar = (-1);",      (char *)"        if (yyerrflag > 0)  --yyerrflag;",      (char *)"        goto yyloop;", 
        (char *)"    }",      (char *)"    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&",      (char *)"            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",      (char *)"    {", 
        (char *)"        yyn = yytable[yyn];",      (char *)"        goto yyreduce;",      (char *)"    }",      (char *)"    if (yyerrflag) goto yyinrecovery;", 
        (char *)"#ifdef lint",      (char *)"    goto yynewerror;",      (char *)"#endif",      (char *)"yynewerror:", 
        (char *)"    yyerror(\"syntax error\");",      (char *)"#ifdef lint",      (char *)"    goto yyerrlab;",      (char *)"#endif", 
        (char *)"yyerrlab:",      (char *)"    ++yynerrs;",      (char *)"yyinrecovery:",      (char *)"    if (yyerrflag < 3)", 
        (char *)"    {",      (char *)"        yyerrflag = 3;",      (char *)"        for (;;)",      (char *)"        {", 
        (char *)"            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&",      (char *)"                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)",      (char *)"            {",      (char *)"#if YYDEBUG", 
        (char *)"                if (yydebug)",      (char *)"                    printf(\"yydebug: state %d, error recovery shifting\\",      (char *)" to state %d\\n\", *yyssp, yytable[yyn]);",      (char *)"#endif", 
        (char *)"                if (yyssp >= yyss + yystacksize - 1)",      (char *)"                {",      (char *)"                    goto yyoverflow;",      (char *)"                }", 
        (char *)"                *++yyssp = yystate = yytable[yyn];",      (char *)"                *++yyvsp = yylval;",      (char *)"                goto yyloop;",      (char *)"            }", 
        (char *)"            else",      (char *)"            {",      (char *)"#if YYDEBUG",      (char *)"                if (yydebug)", 
        (char *)"                    printf(\"yydebug: error recovery discarding state %d\\n\",",      (char *)"                            *yyssp);",      (char *)"#endif",      (char *)"                if (yyssp <= yyss) goto yyabort;", 
        (char *)"                --yyssp;",      (char *)"                --yyvsp;",      (char *)"            }",      (char *)"        }", 
        (char *)"    }",      (char *)"    else",      (char *)"    {",      (char *)"        if (yychar == 0) goto yyabort;", 
        (char *)"#if YYDEBUG",      (char *)"        if (yydebug)",      (char *)"        {",      (char *)"            yys = 0;", 
        (char *)"            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",      (char *)"            if (!yys) yys = \"illegal-symbol\";",      (char *)"            printf(\"yydebug: state %d, error recovery discards token %d (%s)\\n\",",      (char *)"                    yystate, yychar, yys);", 
        (char *)"        }",      (char *)"#endif",      (char *)"        yychar = (-1);",      (char *)"        goto yyloop;", 
        (char *)"    }",      (char *)"yyreduce:",      (char *)"#if YYDEBUG",      (char *)"    if (yydebug)", 
        (char *)"        printf(\"yydebug: state %d, reducing by rule %d (%s)\\n\",",      (char *)"                yystate, yyn, yyrule[yyn]);",      (char *)"#endif",      (char *)"    yym = yylen[yyn];", 
        (char *)"    yyval = yyvsp[1-yym];",      (char *)"    switch (yyn)",      (char *)"    {",      (char *)((void *)0)};
#line 239 "/home/wheatley/newnew/temp/perl-byacc-2.0/skeleton.c"
static char *perl_body[137]  = 
#line 239
  {      (char *)"  $p->{yylex} = $_[1];",      (char *)"  $p->{yyerror} = $_[2];",      (char *)"  $p->{yydebug} = $_[3];",      (char *)"  return $p;", 
        (char *)"}",      (char *)"sub YYERROR {",      (char *)"  my PP $p;",      (char *)"  ($p) = @_;", 
        (char *)"  ++$p->{yynerrs};",      (char *)"  $p->yy_err_recover;",      (char *)"}",      (char *)"sub yy_err_recover {", 
        (char *)"  my PP $p;",      (char *)"  ($p) = @_;",      (char *)"  if ($p->{yyerrflag} < 3)",      (char *)"  {", 
        (char *)"    $p->{yyerrflag} = 3;",      (char *)"    while (1)",      (char *)"    {",      (char *)"      if (($p->{yyn} = $yysindex[$p->{yyss}->[$p->{yyssp}]]) && ", 
        (char *)"          ($p->{yyn} += $YYERRCODE) >= 0 && ",      (char *)"          $p->{yyn} <= $#yycheck &&",      (char *)"          $yycheck[$p->{yyn}] == $YYERRCODE)",      (char *)"      {", 
        (char *)"        warn(\"yydebug: state \" . ",      (char *)"                     $p->{yyss}->[$p->{yyssp}] . ",      (char *)"                     \", error recovery shifting to state\" . ",      (char *)"                     $yytable[$p->{yyn}] . \"\\n\") ", 
        (char *)"                       if $p->{yydebug};",      (char *)"        $p->{yyss}->[++$p->{yyssp}] = ",      (char *)"          $p->{yystate} = $yytable[$p->{yyn}];",      (char *)"        $p->{yyvs}->[++$p->{yyvsp}] = $p->{yylval};", 
        (char *)"        next yyloop;",      (char *)"      }",      (char *)"      else",      (char *)"      {", 
        (char *)"        warn(\"yydebug: error recovery discarding state \".",      (char *)"              $p->{yyss}->[$p->{yyssp}]. \"\\n\") ",      (char *)"                if $p->{yydebug};",      (char *)"        return(undef) if $p->{yyssp} <= 0;", 
        (char *)"        --$p->{yyssp};",      (char *)"        --$p->{yyvsp};",      (char *)"      }",      (char *)"    }", 
        (char *)"  }",      (char *)"  else",      (char *)"  {",      (char *)"    return (undef) if $p->{yychar} == 0;", 
        (char *)"    if ($p->{yydebug})",      (char *)"    {",      (char *)"      $p->{yys} = \'\';",      (char *)"      if ($p->{yychar} <= $YYMAXTOKEN) { $p->{yys} = ", 
        (char *)"        $yyname[$p->{yychar}]; }",      (char *)"      if (!$p->{yys}) { $p->{yys} = \'illegal-symbol\'; }",      (char *)"      warn(\"yydebug: state \" . $p->{yystate} . ",      (char *)"                   \", error recovery discards \" . ", 
        (char *)"                   \"token \" . $p->{yychar} . \"(\" . ",      (char *)"                   $p->{yys} . \")\\n\");",      (char *)"    }",      (char *)"    $p->{yychar} = -1;", 
        (char *)"    next yyloop;",      (char *)"  }",      (char *)"0;",      (char *)"} # yy_err_recover", 
        (char *)"",      (char *)"sub yyparse {",      (char *)"  my PP $p;",      (char *)"  my $s;", 
        (char *)"  ($p, $s) = @_;",      (char *)"  if ($p->{yys} = $ENV{\'YYDEBUG\'})",      (char *)"  {",      (char *)"    $p->{yydebug} = int($1) if $p->{yys} =~ /^(\\d)/;", 
        (char *)"  }",      (char *)"",      (char *)"  $p->{yynerrs} = 0;",      (char *)"  $p->{yyerrflag} = 0;", 
        (char *)"  $p->{yychar} = (-1);",      (char *)"",      (char *)"  $p->{yyssp} = 0;",      (char *)"  $p->{yyvsp} = 0;", 
        (char *)"  $p->{yyss}->[$p->{yyssp}] = $p->{yystate} = 0;",      (char *)"",      (char *)"yyloop: while(1)",      (char *)"  {", 
        (char *)"    yyreduce: {",      (char *)"      last yyreduce if ($p->{yyn} = $yydefred[$p->{yystate}]);",      (char *)"      if ($p->{yychar} < 0)",      (char *)"      {", 
        (char *)"        if ((($p->{yychar}, $p->{yylval}) = ",      (char *)"            &{$p->{yylex}}($s)) < 0) { $p->{yychar} = 0; }",      (char *)"        if ($p->{yydebug})",      (char *)"        {", 
        (char *)"          $p->{yys} = \'\';",      (char *)"          if ($p->{yychar} <= $#yyname) ",      (char *)"             { $p->{yys} = $yyname[$p->{yychar}]; }",      (char *)"          if (!$p->{yys}) { $p->{yys} = \'illegal-symbol\'; };", 
        (char *)"          warn(\"yydebug: state \" . $p->{yystate} . ",      (char *)"                       \", reading \" . $p->{yychar} . \" (\" . ",      (char *)"                       $p->{yys} . \")\\n\");",      (char *)"        }", 
        (char *)"      }",      (char *)"      if (($p->{yyn} = $yysindex[$p->{yystate}]) && ",      (char *)"          ($p->{yyn} += $p->{yychar}) >= 0 && ",      (char *)"          $p->{yyn} <= $#yycheck &&", 
        (char *)"          $yycheck[$p->{yyn}] == $p->{yychar})",      (char *)"      {",      (char *)"        warn(\"yydebug: state \" . $p->{yystate} . ",      (char *)"                     \", shifting to state \" .", 
        (char *)"              $yytable[$p->{yyn}] . \"\\n\") if $p->{yydebug};",      (char *)"        $p->{yyss}->[++$p->{yyssp}] = $p->{yystate} = ",      (char *)"          $yytable[$p->{yyn}];",      (char *)"        $p->{yyvs}->[++$p->{yyvsp}] = $p->{yylval};", 
        (char *)"        $p->{yychar} = (-1);",      (char *)"        --$p->{yyerrflag} if $p->{yyerrflag} > 0;",      (char *)"        next yyloop;",      (char *)"      }", 
        (char *)"      if (($p->{yyn} = $yyrindex[$p->{yystate}]) && ",      (char *)"          ($p->{yyn} += $p->{\'yychar\'}) >= 0 &&",      (char *)"          $p->{yyn} <= $#yycheck &&",      (char *)"          $yycheck[$p->{yyn}] == $p->{yychar})", 
        (char *)"      {",      (char *)"        $p->{yyn} = $yytable[$p->{yyn}];",      (char *)"        last yyreduce;",      (char *)"      }", 
        (char *)"      if (! $p->{yyerrflag}) {",      (char *)"        &{$p->{yyerror}}(\'syntax error\', $s);",      (char *)"        ++$p->{yynerrs};",      (char *)"      }", 
        (char *)"      return(undef) if $p->yy_err_recover;",      (char *)"    } # yyreduce",      (char *)"    warn(\"yydebug: state \" . $p->{yystate} . ",      (char *)"                 \", reducing by rule \" . ", 
        (char *)"                 $p->{yyn} . \" (\" . $yyrule[$p->{yyn}] . ",      (char *)"                 \")\\n\") if $p->{yydebug};",      (char *)"    $p->{yym} = $yylen[$p->{yyn}];",      (char *)"    $p->{yyval} = $p->{yyvs}->[$p->{yyvsp}+1-$p->{yym}];", 
        (char *)((void *)0)};
#line 383 "/home/wheatley/newnew/temp/perl-byacc-2.0/skeleton.c"
char **body[2]  = {      c_body,      perl_body};
#line 385 "/home/wheatley/newnew/temp/perl-byacc-2.0/skeleton.c"
static char *c_trailer[57]  = 
#line 385
  {      (char *)"    }",      (char *)"    yyssp -= yym;",      (char *)"    yystate = *yyssp;",      (char *)"    yyvsp -= yym;", 
        (char *)"    yym = yylhs[yyn];",      (char *)"    if (yystate == 0 && yym == 0)",      (char *)"    {",      (char *)"#if YYDEBUG", 
        (char *)"        if (yydebug)",      (char *)"            printf(\"yydebug: after reduction, shifting from state 0 to\\",      (char *)" state %d\\n\", YYFINAL);",      (char *)"#endif", 
        (char *)"        yystate = YYFINAL;",      (char *)"        *++yyssp = YYFINAL;",      (char *)"        *++yyvsp = yyval;",      (char *)"        if (yychar < 0)", 
        (char *)"        {",      (char *)"            if ((yychar = yylex()) < 0) yychar = 0;",      (char *)"#if YYDEBUG",      (char *)"            if (yydebug)", 
        (char *)"            {",      (char *)"                yys = 0;",      (char *)"                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",      (char *)"                if (!yys) yys = \"illegal-symbol\";", 
        (char *)"                printf(\"yydebug: state %d, reading %d (%s)\\n\",",      (char *)"                        YYFINAL, yychar, yys);",      (char *)"            }",      (char *)"#endif", 
        (char *)"        }",      (char *)"        if (yychar == 0) goto yyaccept;",      (char *)"        goto yyloop;",      (char *)"    }", 
        (char *)"    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&",      (char *)"            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)",      (char *)"        yystate = yytable[yyn];",      (char *)"    else", 
        (char *)"        yystate = yydgoto[yym];",      (char *)"#if YYDEBUG",      (char *)"    if (yydebug)",      (char *)"        printf(\"yydebug: after reduction, shifting from state %d \\", 
        (char *)"to state %d\\n\", *yyssp, yystate);",      (char *)"#endif",      (char *)"    if (yyssp >= yyss + yystacksize - 1)",      (char *)"    {", 
        (char *)"        goto yyoverflow;",      (char *)"    }",      (char *)"    *++yyssp = yystate;",      (char *)"    *++yyvsp = yyval;", 
        (char *)"    goto yyloop;",      (char *)"yyoverflow:",      (char *)"    yyerror(\"yacc stack overflow\");",      (char *)"yyabort:", 
        (char *)"    return (1);",      (char *)"yyaccept:",      (char *)"    return (0);",      (char *)"}", 
        (char *)((void *)0)};
#line 446 "/home/wheatley/newnew/temp/perl-byacc-2.0/skeleton.c"
static char *perl_trailer[45]  = 
#line 446
  {      (char *)"    $p->{yyssp} -= $p->{yym};",      (char *)"    $p->{yystate} = $p->{yyss}->[$p->{yyssp}];",      (char *)"    $p->{yyvsp} -= $p->{yym};",      (char *)"    $p->{yym} = $yylhs[$p->{yyn}];", 
        (char *)"    if ($p->{yystate} == 0 && $p->{yym} == 0)",      (char *)"    {",      (char *)"      warn(\"yydebug: after reduction, shifting from state 0 \",",      (char *)"            \"to state $YYFINAL\\n\") if $p->{yydebug};", 
        (char *)"      $p->{yystate} = $YYFINAL;",      (char *)"      $p->{yyss}->[++$p->{yyssp}] = $YYFINAL;",      (char *)"      $p->{yyvs}->[++$p->{yyvsp}] = $p->{yyval};",      (char *)"      if ($p->{yychar} < 0)", 
        (char *)"      {",      (char *)"        if ((($p->{yychar}, $p->{yylval}) = ",      (char *)"            &{$p->{yylex}}($s)) < 0) { $p->{yychar} = 0; }",      (char *)"        if ($p->{yydebug})", 
        (char *)"        {",      (char *)"          $p->{yys} = \'\';",      (char *)"          if ($p->{yychar} <= $#yyname) ",      (char *)"            { $p->{yys} = $yyname[$p->{yychar}]; }", 
        (char *)"          if (!$p->{yys}) { $p->{yys} = \'illegal-symbol\'; }",      (char *)"          warn(\"yydebug: state $YYFINAL, reading \" . ",      (char *)"               $p->{yychar} . \" (\" . $p->{yys} . \")\\n\");",      (char *)"        }", 
        (char *)"      }",      (char *)"      return ($p->{yyvs}->[1]) if $p->{yychar} == 0;",      (char *)"      next yyloop;",      (char *)"    }", 
        (char *)"    if (($p->{yyn} = $yygindex[$p->{yym}]) && ",      (char *)"        ($p->{yyn} += $p->{yystate}) >= 0 && ",      (char *)"        $p->{yyn} <= $#yycheck && ",      (char *)"        $yycheck[$p->{yyn}] == $p->{yystate})", 
        (char *)"    {",      (char *)"        $p->{yystate} = $yytable[$p->{yyn}];",      (char *)"    } else {",      (char *)"        $p->{yystate} = $yydgoto[$p->{yym}];", 
        (char *)"    }",      (char *)"    warn(\"yydebug: after reduction, shifting from state \" . ",      (char *)"        $p->{yyss}->[$p->{yyssp}] . \" to state \" . ",      (char *)"        $p->{yystate} . \"\\n\") if $p->{yydebug};", 
        (char *)"    $p->{yyss}[++$p->{yyssp}] = $p->{yystate};",      (char *)"    $p->{yyvs}[++$p->{yyvsp}] = $p->{yyval};",      (char *)"  } # yyloop",      (char *)"} # yyparse", 
        (char *)((void *)0)};
#line 495 "/home/wheatley/newnew/temp/perl-byacc-2.0/skeleton.c"
char **trailer[2]  = {      c_trailer,      perl_trailer};
#line 498 "/home/wheatley/newnew/temp/perl-byacc-2.0/skeleton.c"
static char *add_perl_package(char *old_str , char *new_str ) 
{ 
  register char *from ;
  register char *to ;
  register char *p ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 505
  from = old_str;
#line 506
  to = new_str;
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    if (! *from) {
#line 509
      goto while_break;
    }
#line 510
    if ((int )*from == 80) {
#line 510
      if ((int )*(from + 1) == 80) {
#line 511
        from += 2;
#line 512
        if (perl5005flag) {
#line 512
          p = perl_package;
        } else {
#line 512
          p = (char *)"";
        }
        {
#line 513
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 513
          tmp = to;
#line 513
          to ++;
#line 513
          tmp___1 = p;
#line 513
          p ++;
#line 513
          tmp___0 = *tmp___1;
#line 513
          *tmp = tmp___0;
#line 513
          if (! tmp___0) {
#line 513
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 515
        to --;
      } else {
#line 518
        tmp___2 = to;
#line 518
        to ++;
#line 518
        tmp___3 = from;
#line 518
        from ++;
#line 518
        *tmp___2 = *tmp___3;
      }
    } else {
#line 518
      tmp___2 = to;
#line 518
      to ++;
#line 518
      tmp___3 = from;
#line 518
      from ++;
#line 518
      *tmp___2 = *tmp___3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  *to = *from;
#line 524
  return (new_str);
}
}
#line 528 "/home/wheatley/newnew/temp/perl-byacc-2.0/skeleton.c"
static char *add_prefixes(char *old_str , char *new_str ) 
{ 
  register char *from ;
  register char *to ;
  register char *p ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 535
  from = old_str;
#line 536
  to = new_str;
  {
#line 539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 539
    if (! *from) {
#line 539
      goto while_break;
    }
#line 540
    if ((int )*from == 89) {
#line 540
      if ((int )*(from + 1) == 89) {
#line 541
        from += 2;
#line 542
        p = define_prefix;
        {
#line 543
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 543
          tmp = to;
#line 543
          to ++;
#line 543
          tmp___1 = p;
#line 543
          p ++;
#line 543
          tmp___0 = *tmp___1;
#line 543
          *tmp = tmp___0;
#line 543
          if (! tmp___0) {
#line 543
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 545
        to --;
      } else {
#line 540
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 547
    if ((int )*from == 121) {
#line 547
      if ((int )*(from + 1) == 121) {
#line 548
        from += 2;
#line 549
        p = symbol_prefix;
        {
#line 550
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 550
          tmp___2 = to;
#line 550
          to ++;
#line 550
          tmp___4 = p;
#line 550
          p ++;
#line 550
          tmp___3 = *tmp___4;
#line 550
          *tmp___2 = tmp___3;
#line 550
          if (! tmp___3) {
#line 550
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 552
        to --;
      } else {
#line 555
        tmp___5 = to;
#line 555
        to ++;
#line 555
        tmp___6 = from;
#line 555
        from ++;
#line 555
        *tmp___5 = *tmp___6;
      }
    } else {
#line 555
      tmp___5 = to;
#line 555
      to ++;
#line 555
      tmp___6 = from;
#line 555
      from ++;
#line 555
      *tmp___5 = *tmp___6;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 559
  *to = *from;
#line 561
  return (new_str);
}
}
#line 565 "/home/wheatley/newnew/temp/perl-byacc-2.0/skeleton.c"
void write_section(char ***section ) 
{ 
  register int i ;
  register FILE *fp ;
  register char **sec ;
  char buf[8192] ;
  char *tmp ;
  char buf___0[8192] ;
  char *tmp___0 ;

  {
#line 573
  sec = *(section + (int )language);
#line 575
  if ((unsigned long )sec != (unsigned long )((char **)((void *)0))) {
#line 577
    fp = code_file;
#line 578
    if ((unsigned int )language == 1U) {
#line 582
      i = 0;
      {
#line 582
      while (1) {
        while_continue: /* CIL Label */ ;
#line 582
        if (! *(sec + i)) {
#line 582
          goto while_break;
        }
        {
#line 584
        outline ++;
#line 585
        tmp = add_perl_package(*(sec + i), buf);
#line 585
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n",
                tmp);
#line 582
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else
#line 588
    if (prefix_changed) {
#line 592
      i = 0;
      {
#line 592
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 592
        if (! *(sec + i)) {
#line 592
          goto while_break___0;
        }
        {
#line 594
        outline ++;
#line 595
        tmp___0 = add_prefixes(*(sec + i), buf___0);
#line 595
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n",
                tmp___0);
#line 592
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 600
      i = 0;
      {
#line 600
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 600
        if (! *(sec + i)) {
#line 600
          goto while_break___1;
        }
        {
#line 602
        outline ++;
#line 603
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n",
                *(sec + i));
#line 600
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 607
  return;
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 217 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char *line ;
#line 308
void default_action_warning(void) ;
#line 309
void dollar_error(int a_lineno , char *a_line , char *a_cptr ) ;
#line 310
void dollar_warning(int a_lineno , int i ) ;
#line 312
void fatal(char *msg ) ;
#line 319
void illegal_character(char *c_cptr ) ;
#line 320
void illegal_tag(int t_lineno , char *t_line , char *t_cptr ) ;
#line 329
void no_grammar(void) ;
#line 333
void over_unionized(char *u_cptr ) ;
#line 334
void prec_redeclared(void) ;
#line 335
void print_pos(char *st_line , char *st_cptr ) ;
#line 338
void reprec_warning(char *s ) ;
#line 339
void restarted_warning(void) ;
#line 340
void retyped_warning(char *s ) ;
#line 341
void revalued_warning(char *s ) ;
#line 343
void syntax_error(int st_lineno , char *st_line , char *st_cptr ) ;
#line 344
void terminal_lhs(int s_lineno ) ;
#line 345
void terminal_start(char *s ) ;
#line 346
void tokenized_start(char *s ) ;
#line 347
void undefined_goal(char *s ) ;
#line 348
void undefined_symbol_warning(char *s ) ;
#line 349
void unexpected_EOF(void) ;
#line 350
void unknown_rhs(int i ) ;
#line 351
void unterminated_action(int a_lineno , char *a_line , char *a_cptr ) ;
#line 352
void unterminated_comment(int c_lineno , char *c_line , char *c_cptr ) ;
#line 353
void unterminated_string(int s_lineno , char *s_line , char *s_cptr ) ;
#line 354
void unterminated_text(int t_lineno , char *t_line , char *t_cptr ) ;
#line 355
void unterminated_union(int u_lineno , char *u_line , char *u_cptr ) ;
#line 356
void untyped_lhs(void) ;
#line 357
void untyped_rhs(int i , char *s ) ;
#line 358
void used_reserved(char *s ) ;
#line 7 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void fatal(char *msg ) 
{ 


  {
  {
#line 13
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: f - %s\n",
          myname, msg);
#line 14
  done(2);
  }
#line 15
  return;
}
}
#line 19 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void no_space(void) 
{ 


  {
  {
#line 24
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: f - out of space\n",
          myname);
#line 25
  done(2);
  }
#line 26
  return;
}
}
#line 30 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void open_error(char *filename ) 
{ 


  {
  {
#line 36
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: f - cannot open \"%s\"\n",
          myname, filename);
#line 37
  done(2);
  }
#line 38
  return;
}
}
#line 42 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void unexpected_EOF(void) 
{ 


  {
  {
#line 47
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", unexpected end-of-file\n",
          myname, lineno, input_file_name);
#line 49
  done(1);
  }
#line 50
  return;
}
}
#line 54 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void print_pos(char *st_line , char *st_cptr ) 
{ 
  register char *s ;
  unsigned short const   **tmp ;

  {
#line 63
  if ((unsigned long )st_line == (unsigned long )((char *)0)) {
#line 63
    return;
  }
#line 64
  s = st_line;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! ((int )*s != 10)) {
#line 64
      goto while_break;
    }
    {
#line 66
    tmp = __ctype_b_loc();
    }
#line 66
    if ((int const   )*(*tmp + (int )*s) & 16384) {
      {
#line 67
      _IO_putc((int )*s, stderr);
      }
    } else
#line 66
    if ((int )*s == 9) {
      {
#line 67
      _IO_putc((int )*s, stderr);
      }
    } else {
      {
#line 69
      _IO_putc('?', stderr);
      }
    }
#line 64
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 71
  _IO_putc('\n', stderr);
#line 72
  s = st_line;
  }
  {
#line 72
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 72
    if (! ((unsigned long )s < (unsigned long )st_cptr)) {
#line 72
      goto while_break___0;
    }
#line 74
    if ((int )*s == 9) {
      {
#line 75
      _IO_putc('\t', stderr);
      }
    } else {
      {
#line 77
      _IO_putc(' ', stderr);
      }
    }
#line 72
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 79
  _IO_putc('^', stderr);
#line 80
  _IO_putc('\n', stderr);
  }
#line 81
  return;
}
}
#line 85 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void syntax_error(int st_lineno , char *st_line , char *st_cptr ) 
{ 


  {
  {
#line 93
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", syntax error\n",
          myname, st_lineno, input_file_name);
#line 95
  print_pos(st_line, st_cptr);
#line 96
  done(1);
  }
#line 97
  return;
}
}
#line 101 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void unterminated_comment(int c_lineno , char *c_line , char *c_cptr ) 
{ 


  {
  {
#line 109
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", unmatched /*\n",
          myname, c_lineno, input_file_name);
#line 111
  print_pos(c_line, c_cptr);
#line 112
  done(1);
  }
#line 113
  return;
}
}
#line 117 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void unterminated_string(int s_lineno , char *s_line , char *s_cptr ) 
{ 


  {
  {
#line 125
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", unterminated string\n",
          myname, s_lineno, input_file_name);
#line 127
  print_pos(s_line, s_cptr);
#line 128
  done(1);
  }
#line 129
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void unterminated_text(int t_lineno , char *t_line , char *t_cptr ) 
{ 


  {
  {
#line 141
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", unmatched %%{\n",
          myname, t_lineno, input_file_name);
#line 143
  print_pos(t_line, t_cptr);
#line 144
  done(1);
  }
#line 145
  return;
}
}
#line 149 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void unterminated_union(int u_lineno , char *u_line , char *u_cptr ) 
{ 


  {
  {
#line 157
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", unterminated %%union declaration\n",
          myname, u_lineno, input_file_name);
#line 159
  print_pos(u_line, u_cptr);
#line 160
  done(1);
  }
#line 161
  return;
}
}
#line 165 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void over_unionized(char *u_cptr ) 
{ 


  {
  {
#line 171
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", too many %%union declarations\n",
          myname, lineno, input_file_name);
#line 173
  print_pos(line, u_cptr);
#line 174
  done(1);
  }
#line 175
  return;
}
}
#line 179 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void illegal_tag(int t_lineno , char *t_line , char *t_cptr ) 
{ 


  {
  {
#line 187
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", illegal tag\n",
          myname, t_lineno, input_file_name);
#line 189
  print_pos(t_line, t_cptr);
#line 190
  done(1);
  }
#line 191
  return;
}
}
#line 195 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void illegal_character(char *c_cptr ) 
{ 


  {
  {
#line 201
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", illegal character\n",
          myname, lineno, input_file_name);
#line 203
  print_pos(line, c_cptr);
#line 204
  done(1);
  }
#line 205
  return;
}
}
#line 209 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void used_reserved(char *s ) 
{ 


  {
  {
#line 215
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", illegal use of reserved symbol %s\n",
          myname, lineno, input_file_name, s);
#line 217
  done(1);
  }
#line 218
  return;
}
}
#line 222 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void tokenized_start(char *s ) 
{ 


  {
  {
#line 228
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", the start symbol %s cannot be declared to be a token\n",
          myname, lineno, input_file_name, s);
#line 230
  done(1);
  }
#line 231
  return;
}
}
#line 235 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void retyped_warning(char *s ) 
{ 


  {
  {
#line 241
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: w - line %d of \"%s\", the type of %s has been redeclared\n",
          myname, lineno, input_file_name, s);
  }
#line 243
  return;
}
}
#line 247 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void reprec_warning(char *s ) 
{ 


  {
  {
#line 253
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: w - line %d of \"%s\", the precedence of %s has been redeclared\n",
          myname, lineno, input_file_name, s);
  }
#line 255
  return;
}
}
#line 259 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void revalued_warning(char *s ) 
{ 


  {
  {
#line 265
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: w - line %d of \"%s\", the value of %s has been redeclared\n",
          myname, lineno, input_file_name, s);
  }
#line 267
  return;
}
}
#line 271 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void terminal_start(char *s ) 
{ 


  {
  {
#line 277
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", the start symbol %s is a token\n",
          myname, lineno, input_file_name, s);
#line 279
  done(1);
  }
#line 280
  return;
}
}
#line 284 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void restarted_warning(void) 
{ 


  {
  {
#line 289
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: w - line %d of \"%s\", the start symbol has been redeclared\n",
          myname, lineno, input_file_name);
  }
#line 291
  return;
}
}
#line 295 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void no_grammar(void) 
{ 


  {
  {
#line 300
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", no grammar has been specified\n",
          myname, lineno, input_file_name);
#line 302
  done(1);
  }
#line 303
  return;
}
}
#line 307 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void terminal_lhs(int s_lineno ) 
{ 


  {
  {
#line 313
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", a token appears on the lhs of a production\n",
          myname, s_lineno, input_file_name);
#line 315
  done(1);
  }
#line 316
  return;
}
}
#line 320 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void prec_redeclared(void) 
{ 


  {
  {
#line 325
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: w - line %d of  \"%s\", conflicting %%prec specifiers\n",
          myname, lineno, input_file_name);
  }
#line 327
  return;
}
}
#line 331 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void unterminated_action(int a_lineno , char *a_line , char *a_cptr ) 
{ 


  {
  {
#line 339
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", unterminated action\n",
          myname, a_lineno, input_file_name);
#line 341
  print_pos(a_line, a_cptr);
#line 342
  done(1);
  }
#line 343
  return;
}
}
#line 347 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void dollar_warning(int a_lineno , int i ) 
{ 


  {
  {
#line 354
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: w - line %d of \"%s\", $%d references beyond the end of the current rule\n",
          myname, a_lineno, input_file_name, i);
  }
#line 356
  return;
}
}
#line 360 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void dollar_error(int a_lineno , char *a_line , char *a_cptr ) 
{ 


  {
  {
#line 368
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", illegal $-name\n",
          myname, a_lineno, input_file_name);
#line 370
  print_pos(a_line, a_cptr);
#line 371
  done(1);
  }
#line 372
  return;
}
}
#line 376 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void untyped_lhs(void) 
{ 


  {
  {
#line 381
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", $$ is untyped\n",
          myname, lineno, input_file_name);
#line 383
  done(1);
  }
#line 384
  return;
}
}
#line 388 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void untyped_rhs(int i , char *s ) 
{ 


  {
  {
#line 395
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", $%d (%s) is untyped\n",
          myname, lineno, input_file_name, i, s);
#line 397
  done(1);
  }
#line 398
  return;
}
}
#line 402 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void unknown_rhs(int i ) 
{ 


  {
  {
#line 408
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - line %d of \"%s\", $%d is untyped\n",
          myname, lineno, input_file_name, i);
#line 410
  done(1);
  }
#line 411
  return;
}
}
#line 415 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void default_action_warning(void) 
{ 


  {
  {
#line 420
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: w - line %d of \"%s\", the default action assigns an undefined value to $$\n",
          myname, lineno, input_file_name);
  }
#line 422
  return;
}
}
#line 426 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void undefined_goal(char *s ) 
{ 


  {
  {
#line 432
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: e - the start symbol %s is undefined\n",
          myname, s);
#line 433
  done(1);
  }
#line 434
  return;
}
}
#line 438 "/home/wheatley/newnew/temp/perl-byacc-2.0/error.c"
void undefined_symbol_warning(char *s ) 
{ 


  {
  {
#line 444
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: w - the symbol %s is undefined\n",
          myname, s);
  }
#line 445
  return;
}
}
#line 278 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
int nstates ;
#line 282
short *accessing_symbol ;
#line 284
shifts **shift_table ;
#line 286
unsigned int *LA ;
#line 287
short *LAruleno ;
#line 288
short *lookaheads ;
#line 293 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
action **parser  ;
#line 294 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
int SRtotal  ;
#line 295 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
int RRtotal  ;
#line 296 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
short *SRconflicts  ;
#line 297 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
short *RRconflicts  ;
#line 298 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
short *defred  ;
#line 299 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
short *rules_used  ;
#line 300 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
short nunused  ;
#line 301 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
short final_state  ;
#line 316
void free_parser(void) ;
#line 13 "/home/wheatley/newnew/temp/perl-byacc-2.0/mkpar.c"
static int SRcount  ;
#line 14 "/home/wheatley/newnew/temp/perl-byacc-2.0/mkpar.c"
static int RRcount  ;
#line 16
static action *parse_actions(int stateno ) ;
#line 17
static void find_final_state(void) ;
#line 18
static void remove_conflicts(void) ;
#line 19
static void unused_rules(void) ;
#line 20
static void total_conflicts(void) ;
#line 21
static void defreds(void) ;
#line 22
static action *get_shifts(int stateno ) ;
#line 23
static action *add_reductions(int stateno , action *actions ) ;
#line 24
static action *add_reduce(action *actions , int ruleno , int symbol ) ;
#line 29 "/home/wheatley/newnew/temp/perl-byacc-2.0/mkpar.c"
void make_parser(void) 
{ 
  register int i ;
  char *tmp ;

  {
  {
#line 36
  tmp = allocate((unsigned int )((unsigned long )nstates * sizeof(action *)));
#line 36
  parser = (action **)tmp;
#line 37
  i = 0;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i < nstates)) {
#line 37
      goto while_break;
    }
    {
#line 38
    *(parser + i) = parse_actions(i);
#line 37
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 40
  find_final_state();
#line 41
  remove_conflicts();
#line 42
  unused_rules();
  }
#line 43
  if (SRtotal + RRtotal > 0) {
    {
#line 43
    total_conflicts();
    }
  }
  {
#line 44
  defreds();
  }
#line 45
  return;
}
}
#line 49 "/home/wheatley/newnew/temp/perl-byacc-2.0/mkpar.c"
static action *parse_actions(int stateno ) 
{ 
  register action *actions ;

  {
  {
#line 57
  actions = get_shifts(stateno);
#line 58
  actions = add_reductions(stateno, actions);
  }
#line 59
  return (actions);
}
}
#line 64 "/home/wheatley/newnew/temp/perl-byacc-2.0/mkpar.c"
static action *get_shifts(int stateno ) 
{ 
  register action *actions ;
  register action *temp ;
  register shifts *sp ;
  register short *to_state___0 ;
  register int i ;
  register int k ;
  register int symbol ;
  char *tmp ;

  {
#line 76
  actions = (action *)0;
#line 77
  sp = *(shift_table + stateno);
#line 78
  if (sp) {
#line 80
    to_state___0 = sp->shift;
#line 81
    i = (int )sp->nshifts - 1;
    {
#line 81
    while (1) {
      while_continue: /* CIL Label */ ;
#line 81
      if (! (i >= 0)) {
#line 81
        goto while_break;
      }
#line 83
      k = (int )*(to_state___0 + i);
#line 84
      symbol = (int )*(accessing_symbol + k);
#line 85
      if (symbol < start_symbol) {
        {
#line 87
        tmp = allocate((unsigned int )sizeof(action ));
#line 87
        temp = (action *)tmp;
#line 88
        temp->next = actions;
#line 89
        temp->symbol = (short )symbol;
#line 90
        temp->number = (short )k;
#line 91
        temp->prec = *(symbol_prec + symbol);
#line 92
        temp->action_code = (char)1;
#line 93
        temp->assoc = *(symbol_assoc + symbol);
#line 94
        actions = temp;
        }
      }
#line 81
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 98
  return (actions);
}
}
#line 102 "/home/wheatley/newnew/temp/perl-byacc-2.0/mkpar.c"
static action *add_reductions(int stateno , action *actions ) 
{ 
  register int i ;
  register int j ;
  register int m ;
  register int n ;
  register int ruleno ;
  register int tokensetsize___0 ;
  register unsigned int *rowp ;

  {
#line 113
  tokensetsize___0 = (ntokens + 31) / 32;
#line 114
  m = (int )*(lookaheads + stateno);
#line 115
  n = (int )*(lookaheads + (stateno + 1));
#line 116
  i = m;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (i < n)) {
#line 116
      goto while_break;
    }
#line 118
    ruleno = (int )*(LAruleno + i);
#line 119
    rowp = LA + i * tokensetsize___0;
#line 120
    j = ntokens - 1;
    {
#line 120
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 120
      if (! (j >= 0)) {
#line 120
        goto while_break___0;
      }
#line 122
      if ((*(rowp + (j >> 5)) >> (j & 31)) & 1U) {
        {
#line 123
        actions = add_reduce(actions, ruleno, j);
        }
      }
#line 120
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 116
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return (actions);
}
}
#line 131 "/home/wheatley/newnew/temp/perl-byacc-2.0/mkpar.c"
static action *add_reduce(action *actions , int ruleno , int symbol ) 
{ 
  register action *temp ;
  register action *prev ;
  register action *next ;
  char *tmp ;

  {
#line 142
  prev = (action *)0;
#line 143
  next = actions;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (next) {
#line 143
      if (! ((int )next->symbol < symbol)) {
#line 143
        goto while_break;
      }
    } else {
#line 143
      goto while_break;
    }
#line 144
    prev = next;
#line 143
    next = next->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 146
    if (next) {
#line 146
      if ((int )next->symbol == symbol) {
#line 146
        if (! ((int )next->action_code == 1)) {
#line 146
          goto while_break___0;
        }
      } else {
#line 146
        goto while_break___0;
      }
    } else {
#line 146
      goto while_break___0;
    }
#line 148
    prev = next;
#line 149
    next = next->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 152
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 152
    if (next) {
#line 152
      if ((int )next->symbol == symbol) {
#line 152
        if ((int )next->action_code == 2) {
#line 152
          if (! ((int )next->number < ruleno)) {
#line 152
            goto while_break___1;
          }
        } else {
#line 152
          goto while_break___1;
        }
      } else {
#line 152
        goto while_break___1;
      }
    } else {
#line 152
      goto while_break___1;
    }
#line 155
    prev = next;
#line 156
    next = next->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 159
  tmp = allocate((unsigned int )sizeof(action ));
#line 159
  temp = (action *)tmp;
#line 160
  temp->next = next;
#line 161
  temp->symbol = (short )symbol;
#line 162
  temp->number = (short )ruleno;
#line 163
  temp->prec = *(rprec + ruleno);
#line 164
  temp->action_code = (char)2;
#line 165
  temp->assoc = *(rassoc + ruleno);
  }
#line 167
  if (prev) {
#line 168
    prev->next = temp;
  } else {
#line 170
    actions = temp;
  }
#line 172
  return (actions);
}
}
#line 177 "/home/wheatley/newnew/temp/perl-byacc-2.0/mkpar.c"
static void find_final_state(void) 
{ 
  register int goal___0 ;
  register int i ;
  register short *to_state___0 ;
  register shifts *p ;

  {
#line 186
  p = *(shift_table + 0);
#line 187
  to_state___0 = p->shift;
#line 188
  goal___0 = (int )*(ritem + 1);
#line 189
  i = (int )p->nshifts - 1;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! (i >= 0)) {
#line 189
      goto while_break;
    }
#line 191
    final_state = *(to_state___0 + i);
#line 192
    if ((int )*(accessing_symbol + final_state) == goal___0) {
#line 192
      goto while_break;
    }
#line 189
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return;
}
}
#line 198 "/home/wheatley/newnew/temp/perl-byacc-2.0/mkpar.c"
static void unused_rules(void) 
{ 
  register int i ;
  register action *p ;
  char *tmp ;

  {
  {
#line 206
  tmp = my_malloc((unsigned int )((unsigned long )nrules * sizeof(short )));
#line 206
  rules_used = (short *)tmp;
#line 208
  i = 0;
  }
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! (i < nrules)) {
#line 208
      goto while_break;
    }
#line 209
    *(rules_used + i) = (short)0;
#line 208
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  i = 0;
  {
#line 211
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 211
    if (! (i < nstates)) {
#line 211
      goto while_break___0;
    }
#line 213
    p = *(parser + i);
    {
#line 213
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 213
      if (! p) {
#line 213
        goto while_break___1;
      }
#line 215
      if ((int )p->action_code == 2) {
#line 215
        if ((int )p->suppressed == 0) {
#line 216
          *(rules_used + p->number) = (short)1;
        }
      }
#line 213
      p = p->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 211
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 220
  nunused = (short)0;
#line 221
  i = 3;
  {
#line 221
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 221
    if (! (i < nrules)) {
#line 221
      goto while_break___2;
    }
#line 222
    if (! *(rules_used + i)) {
#line 222
      nunused = (short )((int )nunused + 1);
    }
#line 221
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 224
  if (nunused) {
#line 225
    if ((int )nunused == 1) {
      {
#line 226
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: 1 rule never reduced\n",
              myname);
      }
    } else {
      {
#line 228
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %d rules never reduced\n",
              myname, (int )nunused);
      }
    }
  }
#line 229
  return;
}
}
#line 233 "/home/wheatley/newnew/temp/perl-byacc-2.0/mkpar.c"
static void remove_conflicts(void) 
{ 
  register int i ;
  register int symbol ;
  register action *p ;
  register action *pref ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 242
  SRtotal = 0;
#line 243
  RRtotal = 0;
#line 244
  tmp = allocate((unsigned int )((unsigned long )nstates * sizeof(short )));
#line 244
  SRconflicts = (short *)tmp;
#line 245
  tmp___0 = allocate((unsigned int )((unsigned long )nstates * sizeof(short )));
#line 245
  RRconflicts = (short *)tmp___0;
#line 246
  i = 0;
  }
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! (i < nstates)) {
#line 246
      goto while_break;
    }
#line 248
    SRcount = 0;
#line 249
    RRcount = 0;
#line 250
    symbol = -1;
#line 251
    p = *(parser + i);
    {
#line 251
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 251
      if (! p) {
#line 251
        goto while_break___0;
      }
#line 253
      if ((int )p->symbol != symbol) {
#line 255
        pref = p;
#line 256
        symbol = (int )p->symbol;
      } else
#line 258
      if (i == (int )final_state) {
#line 258
        if (symbol == 0) {
#line 260
          SRcount ++;
#line 261
          p->suppressed = (char)1;
        } else {
#line 258
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 263
      if ((int )pref->action_code == 1) {
#line 265
        if ((int )pref->prec > 0) {
#line 265
          if ((int )p->prec > 0) {
#line 267
            if ((int )pref->prec < (int )p->prec) {
#line 269
              pref->suppressed = (char)2;
#line 270
              pref = p;
            } else
#line 272
            if ((int )pref->prec > (int )p->prec) {
#line 274
              p->suppressed = (char)2;
            } else
#line 276
            if ((int )pref->assoc == 1) {
#line 278
              pref->suppressed = (char)2;
#line 279
              pref = p;
            } else
#line 281
            if ((int )pref->assoc == 2) {
#line 283
              p->suppressed = (char)2;
            } else {
#line 287
              pref->suppressed = (char)2;
#line 288
              p->suppressed = (char)2;
            }
          } else {
#line 293
            SRcount ++;
#line 294
            p->suppressed = (char)1;
          }
        } else {
#line 293
          SRcount ++;
#line 294
          p->suppressed = (char)1;
        }
      } else {
#line 299
        RRcount ++;
#line 300
        p->suppressed = (char)1;
      }
#line 251
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 303
    SRtotal += SRcount;
#line 304
    RRtotal += RRcount;
#line 305
    *(SRconflicts + i) = (short )SRcount;
#line 306
    *(RRconflicts + i) = (short )RRcount;
#line 246
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  return;
}
}
#line 312 "/home/wheatley/newnew/temp/perl-byacc-2.0/mkpar.c"
static void total_conflicts(void) 
{ 


  {
  {
#line 317
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          myname);
  }
#line 318
  if (SRtotal == 1) {
    {
#line 319
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"1 shift/reduce conflict");
    }
  } else
#line 320
  if (SRtotal > 1) {
    {
#line 321
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d shift/reduce conflicts",
            SRtotal);
    }
  }
#line 323
  if (SRtotal) {
#line 323
    if (RRtotal) {
      {
#line 324
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", ");
      }
    }
  }
#line 326
  if (RRtotal == 1) {
    {
#line 327
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"1 reduce/reduce conflict");
    }
  } else
#line 328
  if (RRtotal > 1) {
    {
#line 329
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d reduce/reduce conflicts",
            RRtotal);
    }
  }
  {
#line 331
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".\n");
  }
#line 332
  return;
}
}
#line 336 "/home/wheatley/newnew/temp/perl-byacc-2.0/mkpar.c"
static int sole_reduction(int stateno ) 
{ 
  register int count ;
  register int ruleno ;
  register action *p ;

  {
#line 345
  count = 0;
#line 346
  ruleno = 0;
#line 347
  p = *(parser + stateno);
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! p) {
#line 347
      goto while_break;
    }
#line 349
    if ((int )p->action_code == 1) {
#line 349
      if ((int )p->suppressed == 0) {
#line 350
        return (0);
      } else {
#line 349
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 351
    if ((int )p->action_code == 2) {
#line 351
      if ((int )p->suppressed == 0) {
#line 353
        if (ruleno > 0) {
#line 353
          if ((int )p->number != ruleno) {
#line 354
            return (0);
          }
        }
#line 355
        if ((int )p->symbol != 1) {
#line 356
          count ++;
        }
#line 357
        ruleno = (int )p->number;
      }
    }
#line 347
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  if (count == 0) {
#line 362
    return (0);
  }
#line 363
  return (ruleno);
}
}
#line 368 "/home/wheatley/newnew/temp/perl-byacc-2.0/mkpar.c"
static void defreds(void) 
{ 
  register int i ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 375
  tmp = allocate((unsigned int )((unsigned long )nstates * sizeof(short )));
#line 375
  defred = (short *)tmp;
#line 376
  i = 0;
  }
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 376
    if (! (i < nstates)) {
#line 376
      goto while_break;
    }
    {
#line 377
    tmp___0 = sole_reduction(i);
#line 377
    *(defred + i) = (short )tmp___0;
#line 376
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  return;
}
}
#line 381 "/home/wheatley/newnew/temp/perl-byacc-2.0/mkpar.c"
static void free_action_row(action *p ) 
{ 
  register action *q ;

  {
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! p) {
#line 389
      goto while_break;
    }
    {
#line 391
    q = p->next;
#line 392
    free((void *)((char *)p));
#line 393
    p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  return;
}
}
#line 398 "/home/wheatley/newnew/temp/perl-byacc-2.0/mkpar.c"
void free_parser(void) 
{ 
  register int i ;

  {
#line 405
  i = 0;
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    if (! (i < nstates)) {
#line 405
      goto while_break;
    }
    {
#line 406
    free_action_row(*(parser + i));
#line 405
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 408
  free((void *)((char *)parser));
  }
#line 409
  return;
}
}
#line 279 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
core *first_state ;
#line 280
shifts *first_shift ;
#line 281
reductions *first_reduction ;
#line 282 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
short *accessing_symbol  ;
#line 283 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
core **state_table  ;
#line 284 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
shifts **shift_table  ;
#line 285 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
reductions **reduction_table  ;
#line 286 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
unsigned int *LA  ;
#line 287 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
short *LAruleno  ;
#line 288 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
short *lookaheads  ;
#line 289 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
short *goto_map  ;
#line 290 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
short *from_state  ;
#line 291 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
short *to_state  ;
#line 9 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
int tokensetsize  ;
#line 21 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static int infinity  ;
#line 22 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static int maxrhs  ;
#line 23 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static int ngotos  ;
#line 24 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static unsigned int *F  ;
#line 25 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static short **includes  ;
#line 26 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static shorts **lookback  ;
#line 27 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static short **R  ;
#line 28 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static short *INDEX  ;
#line 29 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static short *VERTICES  ;
#line 30 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static int top  ;
#line 32
static void set_state_table(void) ;
#line 33
static void set_accessing_symbol(void) ;
#line 34
static void set_shift_table(void) ;
#line 35
static void set_reduction_table(void) ;
#line 36
static void set_maxrhs(void) ;
#line 37
static void initialize_LA(void) ;
#line 38
static void set_goto_map(void) ;
#line 39
static int map_goto(int state , int symbol ) ;
#line 40
static void initialize_F(void) ;
#line 41
static void build_relations(void) ;
#line 42
static void add_lookback_edge(int stateno , int ruleno , int gotono ) ;
#line 43
static short **transpose(short **R___0 , int n ) ;
#line 44
static void compute_FOLLOWS(void) ;
#line 45
static void compute_lookaheads(void) ;
#line 46
static void digraph(short **relation ) ;
#line 47
static void traverse(int i ) ;
#line 51 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
void lalr(void) 
{ 


  {
  {
#line 56
  tokensetsize = (ntokens + 31) / 32;
#line 58
  set_state_table();
#line 59
  set_accessing_symbol();
#line 60
  set_shift_table();
#line 61
  set_reduction_table();
#line 62
  set_maxrhs();
#line 63
  initialize_LA();
#line 64
  set_goto_map();
#line 65
  initialize_F();
#line 66
  build_relations();
#line 67
  compute_FOLLOWS();
#line 68
  compute_lookaheads();
  }
#line 69
  return;
}
}
#line 74 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static void set_state_table(void) 
{ 
  register core *sp ;
  char *tmp ;

  {
  {
#line 81
  tmp = allocate((unsigned int )((unsigned long )nstates * sizeof(core *)));
#line 81
  state_table = (core **)tmp;
#line 82
  sp = first_state;
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! sp) {
#line 82
      goto while_break;
    }
#line 83
    *(state_table + sp->number) = sp;
#line 82
    sp = sp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return;
}
}
#line 89 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static void set_accessing_symbol(void) 
{ 
  register core *sp ;
  char *tmp ;

  {
  {
#line 96
  tmp = allocate((unsigned int )((unsigned long )nstates * sizeof(short )));
#line 96
  accessing_symbol = (short *)tmp;
#line 97
  sp = first_state;
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! sp) {
#line 97
      goto while_break;
    }
#line 98
    *(accessing_symbol + sp->number) = sp->accessing_symbol;
#line 97
    sp = sp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 104 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static void set_shift_table(void) 
{ 
  register shifts *sp ;
  char *tmp ;

  {
  {
#line 111
  tmp = allocate((unsigned int )((unsigned long )nstates * sizeof(shifts *)));
#line 111
  shift_table = (shifts **)tmp;
#line 112
  sp = first_shift;
  }
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! sp) {
#line 112
      goto while_break;
    }
#line 113
    *(shift_table + sp->number) = sp;
#line 112
    sp = sp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static void set_reduction_table(void) 
{ 
  register reductions *rp ;
  char *tmp ;

  {
  {
#line 126
  tmp = allocate((unsigned int )((unsigned long )nstates * sizeof(reductions *)));
#line 126
  reduction_table = (reductions **)tmp;
#line 127
  rp = first_reduction;
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! rp) {
#line 127
      goto while_break;
    }
#line 128
    *(reduction_table + rp->number) = rp;
#line 127
    rp = rp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  return;
}
}
#line 134 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static void set_maxrhs(void) 
{ 
  register short *itemp ;
  register short *item_end ;
  register int length ;
  register int max ;

  {
#line 144
  length = 0;
#line 145
  max = 0;
#line 146
  item_end = ritem + nitems;
#line 147
  itemp = ritem;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! ((unsigned long )itemp < (unsigned long )item_end)) {
#line 147
      goto while_break;
    }
#line 149
    if ((int )*itemp >= 0) {
#line 151
      length ++;
    } else {
#line 155
      if (length > max) {
#line 155
        max = length;
      }
#line 156
      length = 0;
    }
#line 147
    itemp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  maxrhs = max;
#line 161
  return;
}
}
#line 166 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static void initialize_LA(void) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register reductions *rp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 174
  tmp = allocate((unsigned int )((unsigned long )(nstates + 1) * sizeof(short )));
#line 174
  lookaheads = (short *)tmp;
#line 176
  k = 0;
#line 177
  i = 0;
  }
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < nstates)) {
#line 177
      goto while_break;
    }
#line 179
    *(lookaheads + i) = (short )k;
#line 180
    rp = *(reduction_table + i);
#line 181
    if (rp) {
#line 182
      k += (int )rp->nreds;
    }
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 184
  *(lookaheads + nstates) = (short )k;
#line 186
  tmp___0 = allocate((unsigned int )((unsigned long )(k * tokensetsize) * sizeof(unsigned int )));
#line 186
  LA = (unsigned int *)tmp___0;
#line 187
  tmp___1 = allocate((unsigned int )((unsigned long )k * sizeof(short )));
#line 187
  LAruleno = (short *)tmp___1;
#line 188
  tmp___2 = allocate((unsigned int )((unsigned long )k * sizeof(shorts *)));
#line 188
  lookback = (shorts **)tmp___2;
#line 190
  k = 0;
#line 191
  i = 0;
  }
  {
#line 191
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 191
    if (! (i < nstates)) {
#line 191
      goto while_break___0;
    }
#line 193
    rp = *(reduction_table + i);
#line 194
    if (rp) {
#line 196
      j = 0;
      {
#line 196
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 196
        if (! (j < (int )rp->nreds)) {
#line 196
          goto while_break___1;
        }
#line 198
        *(LAruleno + k) = rp->rules[j];
#line 199
        k ++;
#line 196
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 191
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 203
  return;
}
}
#line 207 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static void set_goto_map(void) 
{ 
  register shifts *sp ;
  register int i ;
  register int symbol ;
  register int k ;
  register short *temp_map ;
  register int state2 ;
  register int state1 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  short tmp___3 ;

  {
  {
#line 220
  tmp = allocate((unsigned int )((unsigned long )(nvars + 1) * sizeof(short )));
#line 220
  goto_map = (short *)tmp - ntokens;
#line 221
  tmp___0 = allocate((unsigned int )((unsigned long )(nvars + 1) * sizeof(short )));
#line 221
  temp_map = (short *)tmp___0 - ntokens;
#line 223
  ngotos = 0;
#line 224
  sp = first_shift;
  }
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! sp) {
#line 224
      goto while_break;
    }
#line 226
    i = (int )sp->nshifts - 1;
    {
#line 226
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 226
      if (! (i >= 0)) {
#line 226
        goto while_break___0;
      }
#line 228
      symbol = (int )*(accessing_symbol + sp->shift[i]);
#line 230
      if (symbol < start_symbol) {
#line 230
        goto while_break___0;
      }
#line 232
      if (ngotos == 32767) {
        {
#line 233
        fatal((char *)"too many gotos");
        }
      }
#line 235
      ngotos ++;
#line 236
      *(goto_map + symbol) = (short )((int )*(goto_map + symbol) + 1);
#line 226
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 224
    sp = sp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  k = 0;
#line 241
  i = ntokens;
  {
#line 241
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 241
    if (! (i < nsyms)) {
#line 241
      goto while_break___1;
    }
#line 243
    *(temp_map + i) = (short )k;
#line 244
    k += (int )*(goto_map + i);
#line 241
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 247
  i = ntokens;
  {
#line 247
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 247
    if (! (i < nsyms)) {
#line 247
      goto while_break___2;
    }
#line 248
    *(goto_map + i) = *(temp_map + i);
#line 247
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 250
  *(goto_map + nsyms) = (short )ngotos;
#line 251
  *(temp_map + nsyms) = (short )ngotos;
#line 253
  tmp___1 = allocate((unsigned int )((unsigned long )ngotos * sizeof(short )));
#line 253
  from_state = (short *)tmp___1;
#line 254
  tmp___2 = allocate((unsigned int )((unsigned long )ngotos * sizeof(short )));
#line 254
  to_state = (short *)tmp___2;
#line 256
  sp = first_shift;
  }
  {
#line 256
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 256
    if (! sp) {
#line 256
      goto while_break___3;
    }
#line 258
    state1 = (int )sp->number;
#line 259
    i = (int )sp->nshifts - 1;
    {
#line 259
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 259
      if (! (i >= 0)) {
#line 259
        goto while_break___4;
      }
#line 261
      state2 = (int )sp->shift[i];
#line 262
      symbol = (int )*(accessing_symbol + state2);
#line 264
      if (symbol < start_symbol) {
#line 264
        goto while_break___4;
      }
#line 266
      tmp___3 = *(temp_map + symbol);
#line 266
      *(temp_map + symbol) = (short )((int )*(temp_map + symbol) + 1);
#line 266
      k = (int )tmp___3;
#line 267
      *(from_state + k) = (short )state1;
#line 268
      *(to_state + k) = (short )state2;
#line 259
      i --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 256
    sp = sp->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 272
  free((void *)((char *)(temp_map + ntokens)));
  }
#line 273
  return;
}
}
#line 280 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static int map_goto(int state , int symbol ) 
{ 
  register int high___0 ;
  register int low ;
  register int middle ;
  register int s ;

  {
#line 292
  low = (int )*(goto_map + symbol);
#line 293
  high___0 = (int )*(goto_map + (symbol + 1));
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! (low <= high___0)) {
      {
#line 297
      __assert_fail("low <= high", "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c",
                    297U, "map_goto");
      }
    }
#line 298
    middle = (low + high___0) >> 1;
#line 299
    s = (int )*(from_state + middle);
#line 300
    if (s == state) {
#line 301
      return (middle);
    } else
#line 302
    if (s < state) {
#line 303
      low = middle + 1;
    } else {
#line 305
      high___0 = middle - 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 312 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static void initialize_F(void) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register shifts *sp ;
  register short *edge ;
  register unsigned int *rowp ;
  register short *rp ;
  register short **reads ;
  register int nedges ;
  register int stateno ;
  register int symbol ;
  register int nwords ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 330
  nwords = ngotos * tokensetsize;
#line 331
  tmp = allocate((unsigned int )((unsigned long )nwords * sizeof(unsigned int )));
#line 331
  F = (unsigned int *)tmp;
#line 333
  tmp___0 = allocate((unsigned int )((unsigned long )ngotos * sizeof(short *)));
#line 333
  reads = (short **)tmp___0;
#line 334
  tmp___1 = allocate((unsigned int )((unsigned long )(ngotos + 1) * sizeof(short )));
#line 334
  edge = (short *)tmp___1;
#line 335
  nedges = 0;
#line 337
  rowp = F;
#line 338
  i = 0;
  }
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! (i < ngotos)) {
#line 338
      goto while_break;
    }
#line 340
    stateno = (int )*(to_state + i);
#line 341
    sp = *(shift_table + stateno);
#line 343
    if (sp) {
#line 345
      k = (int )sp->nshifts;
#line 347
      j = 0;
      {
#line 347
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 347
        if (! (j < k)) {
#line 347
          goto while_break___0;
        }
#line 349
        symbol = (int )*(accessing_symbol + sp->shift[j]);
#line 350
        if (symbol >= start_symbol) {
#line 351
          goto while_break___0;
        }
#line 352
        *(rowp + (symbol >> 5)) |= 1U << (symbol & 31);
#line 347
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 355
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 355
        if (! (j < k)) {
#line 355
          goto while_break___1;
        }
#line 357
        symbol = (int )*(accessing_symbol + sp->shift[j]);
#line 358
        if (*(nullable + symbol)) {
          {
#line 359
          tmp___2 = nedges;
#line 359
          nedges ++;
#line 359
          tmp___3 = map_goto(stateno, symbol);
#line 359
          *(edge + tmp___2) = (short )tmp___3;
          }
        }
#line 355
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 362
      if (nedges) {
        {
#line 364
        tmp___4 = allocate((unsigned int )((unsigned long )(nedges + 1) * sizeof(short )));
#line 364
        rp = (short *)tmp___4;
#line 364
        *(reads + i) = rp;
#line 366
        j = 0;
        }
        {
#line 366
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 366
          if (! (j < nedges)) {
#line 366
            goto while_break___2;
          }
#line 367
          *(rp + j) = *(edge + j);
#line 366
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 369
        *(rp + nedges) = (short)-1;
#line 370
        nedges = 0;
      }
    }
#line 374
    rowp += tokensetsize;
#line 338
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 377
  *(F + 0) |= 1U;
#line 378
  digraph(reads);
#line 380
  i = 0;
  }
  {
#line 380
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 380
    if (! (i < ngotos)) {
#line 380
      goto while_break___3;
    }
#line 382
    if (*(reads + i)) {
      {
#line 383
      free((void *)((char *)*(reads + i)));
      }
    }
#line 380
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 386
  free((void *)((char *)reads));
#line 387
  free((void *)((char *)edge));
  }
#line 388
  return;
}
}
#line 393 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static void build_relations(void) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register short *rulep ;
  register short *rp ;
  register shifts *sp ;
  register int length ;
  register int nedges ;
  register int done___0 ;
  register int state1 ;
  register int stateno ;
  register int symbol1 ;
  register int symbol2 ;
  register short *shortp ;
  register short *edge ;
  register short *states ;
  register short **new_includes ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 416
  tmp = allocate((unsigned int )((unsigned long )ngotos * sizeof(short *)));
#line 416
  includes = (short **)tmp;
#line 417
  tmp___0 = allocate((unsigned int )((unsigned long )(ngotos + 1) * sizeof(short )));
#line 417
  edge = (short *)tmp___0;
#line 418
  tmp___1 = allocate((unsigned int )((unsigned long )(maxrhs + 1) * sizeof(short )));
#line 418
  states = (short *)tmp___1;
#line 420
  i = 0;
  }
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 420
    if (! (i < ngotos)) {
#line 420
      goto while_break;
    }
#line 422
    nedges = 0;
#line 423
    state1 = (int )*(from_state + i);
#line 424
    symbol1 = (int )*(accessing_symbol + *(to_state + i));
#line 426
    rulep = *(derives + symbol1);
    {
#line 426
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 426
      if (! ((int )*rulep >= 0)) {
#line 426
        goto while_break___0;
      }
#line 428
      length = 1;
#line 429
      *(states + 0) = (short )state1;
#line 430
      stateno = state1;
#line 432
      rp = ritem + (int )*(rrhs + *rulep);
      {
#line 432
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 432
        if (! ((int )*rp >= 0)) {
#line 432
          goto while_break___1;
        }
#line 434
        symbol2 = (int )*rp;
#line 435
        sp = *(shift_table + stateno);
#line 436
        k = (int )sp->nshifts;
#line 438
        j = 0;
        {
#line 438
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 438
          if (! (j < k)) {
#line 438
            goto while_break___2;
          }
#line 440
          stateno = (int )sp->shift[j];
#line 441
          if ((int )*(accessing_symbol + stateno) == symbol2) {
#line 441
            goto while_break___2;
          }
#line 438
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 444
        tmp___2 = length;
#line 444
        length ++;
#line 444
        *(states + tmp___2) = (short )stateno;
#line 432
        rp ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 447
      add_lookback_edge(stateno, (int )*rulep, i);
#line 449
      length --;
#line 450
      done___0 = 0;
      }
      {
#line 451
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 451
        if (! (! done___0)) {
#line 451
          goto while_break___3;
        }
#line 453
        done___0 = 1;
#line 454
        rp --;
#line 455
        if ((int )*rp >= start_symbol) {
          {
#line 457
          length --;
#line 457
          stateno = (int )*(states + length);
#line 458
          tmp___3 = nedges;
#line 458
          nedges ++;
#line 458
          tmp___4 = map_goto(stateno, (int )*rp);
#line 458
          *(edge + tmp___3) = (short )tmp___4;
          }
#line 459
          if (*(nullable + *rp)) {
#line 459
            if (length > 0) {
#line 459
              done___0 = 0;
            }
          }
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 426
      rulep ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 464
    if (nedges) {
      {
#line 466
      tmp___5 = allocate((unsigned int )((unsigned long )(nedges + 1) * sizeof(short )));
#line 466
      shortp = (short *)tmp___5;
#line 466
      *(includes + i) = shortp;
#line 467
      j = 0;
      }
      {
#line 467
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 467
        if (! (j < nedges)) {
#line 467
          goto while_break___4;
        }
#line 468
        *(shortp + j) = *(edge + j);
#line 467
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 469
      *(shortp + nedges) = (short)-1;
    }
#line 420
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 473
  new_includes = transpose(includes, ngotos);
#line 475
  i = 0;
  }
  {
#line 475
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 475
    if (! (i < ngotos)) {
#line 475
      goto while_break___5;
    }
#line 476
    if (*(includes + i)) {
      {
#line 477
      free((void *)((char *)*(includes + i)));
      }
    }
#line 475
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 479
  free((void *)((char *)includes));
#line 481
  includes = new_includes;
#line 483
  free((void *)((char *)edge));
#line 484
  free((void *)((char *)states));
  }
#line 485
  return;
}
}
#line 489 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static void add_lookback_edge(int stateno , int ruleno , int gotono ) 
{ 
  register int i ;
  register int k ;
  register int found ;
  register shorts *sp ;
  char *tmp ;

  {
#line 499
  i = (int )*(lookaheads + stateno);
#line 500
  k = (int )*(lookaheads + (stateno + 1));
#line 501
  found = 0;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! found) {
#line 502
      if (! (i < k)) {
#line 502
        goto while_break;
      }
    } else {
#line 502
      goto while_break;
    }
#line 504
    if ((int )*(LAruleno + i) == ruleno) {
#line 505
      found = 1;
    } else {
#line 507
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 509
  if (! found) {
    {
#line 509
    __assert_fail("found", "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c", 509U,
                  "add_lookback_edge");
    }
  }
  {
#line 511
  tmp = allocate((unsigned int )sizeof(shorts ));
#line 511
  sp = (shorts *)tmp;
#line 512
  sp->next = *(lookback + i);
#line 513
  sp->value = (short )gotono;
#line 514
  *(lookback + i) = sp;
  }
#line 515
  return;
}
}
#line 520 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static short **transpose(short **R___0 , int n ) 
{ 
  register short **new_R ;
  register short **temp_R ;
  register short *nedges ;
  register short *sp ;
  register int i ;
  register int k ;
  char *tmp ;
  short *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  short *tmp___4 ;
  short *tmp___5 ;

  {
  {
#line 534
  tmp = allocate((unsigned int )((unsigned long )n * sizeof(short )));
#line 534
  nedges = (short *)tmp;
#line 536
  i = 0;
  }
  {
#line 536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 536
    if (! (i < n)) {
#line 536
      goto while_break;
    }
#line 538
    sp = *(R___0 + i);
#line 539
    if (sp) {
      {
#line 541
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 541
        if (! ((int )*sp >= 0)) {
#line 541
          goto while_break___0;
        }
#line 542
        tmp___0 = sp;
#line 542
        sp ++;
#line 542
        *(nedges + *tmp___0) = (short )((int )*(nedges + *tmp___0) + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 536
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 546
  tmp___1 = allocate((unsigned int )((unsigned long )n * sizeof(short *)));
#line 546
  new_R = (short **)tmp___1;
#line 547
  tmp___2 = allocate((unsigned int )((unsigned long )n * sizeof(short *)));
#line 547
  temp_R = (short **)tmp___2;
#line 549
  i = 0;
  }
  {
#line 549
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 549
    if (! (i < n)) {
#line 549
      goto while_break___1;
    }
#line 551
    k = (int )*(nedges + i);
#line 552
    if (k > 0) {
      {
#line 554
      tmp___3 = allocate((unsigned int )((unsigned long )(k + 1) * sizeof(short )));
#line 554
      sp = (short *)tmp___3;
#line 555
      *(new_R + i) = sp;
#line 556
      *(temp_R + i) = sp;
#line 557
      *(sp + k) = (short)-1;
      }
    }
#line 549
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 561
  free((void *)((char *)nedges));
#line 563
  i = 0;
  }
  {
#line 563
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 563
    if (! (i < n)) {
#line 563
      goto while_break___2;
    }
#line 565
    sp = *(R___0 + i);
#line 566
    if (sp) {
      {
#line 568
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 568
        if (! ((int )*sp >= 0)) {
#line 568
          goto while_break___3;
        }
#line 569
        tmp___4 = sp;
#line 569
        sp ++;
#line 569
        tmp___5 = *(temp_R + *tmp___4);
#line 569
        (*(temp_R + *tmp___4)) ++;
#line 569
        *tmp___5 = (short )i;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 563
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 573
  free((void *)((char *)temp_R));
  }
#line 575
  return (new_R);
}
}
#line 581 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static void compute_FOLLOWS(void) 
{ 


  {
  {
#line 586
  digraph(includes);
  }
#line 587
  return;
}
}
#line 591 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static void compute_lookaheads(void) 
{ 
  register int i ;
  register int n ;
  register unsigned int *fp1 ;
  register unsigned int *fp2 ;
  register unsigned int *fp3 ;
  register shorts *sp ;
  register shorts *next ;
  register unsigned int *rowp ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;

  {
#line 601
  rowp = LA;
#line 602
  n = (int )*(lookaheads + nstates);
#line 603
  i = 0;
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 603
    if (! (i < n)) {
#line 603
      goto while_break;
    }
#line 605
    fp3 = rowp + tokensetsize;
#line 606
    sp = *(lookback + i);
    {
#line 606
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 606
      if (! sp) {
#line 606
        goto while_break___0;
      }
#line 608
      fp1 = rowp;
#line 609
      fp2 = F + tokensetsize * (int )sp->value;
      {
#line 610
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 610
        if (! ((unsigned long )fp1 < (unsigned long )fp3)) {
#line 610
          goto while_break___1;
        }
#line 611
        tmp = fp1;
#line 611
        fp1 ++;
#line 611
        tmp___0 = fp2;
#line 611
        fp2 ++;
#line 611
        *tmp |= *tmp___0;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 606
      sp = sp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 613
    rowp = fp3;
#line 603
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 616
  i = 0;
  {
#line 616
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 616
    if (! (i < n)) {
#line 616
      goto while_break___2;
    }
#line 617
    sp = *(lookback + i);
    {
#line 617
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 617
      if (! sp) {
#line 617
        goto while_break___3;
      }
      {
#line 619
      next = sp->next;
#line 620
      free((void *)((char *)sp));
#line 617
      sp = next;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 616
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 623
  free((void *)((char *)lookback));
#line 624
  free((void *)((char *)F));
  }
#line 625
  return;
}
}
#line 629 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static void digraph(short **relation ) 
{ 
  register int i ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 637
  infinity = ngotos + 2;
#line 638
  tmp = allocate((unsigned int )((unsigned long )(ngotos + 1) * sizeof(short )));
#line 638
  INDEX = (short *)tmp;
#line 639
  tmp___0 = allocate((unsigned int )((unsigned long )(ngotos + 1) * sizeof(short )));
#line 639
  VERTICES = (short *)tmp___0;
#line 640
  top = 0;
#line 642
  R = relation;
#line 644
  i = 0;
  }
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 644
    if (! (i < ngotos)) {
#line 644
      goto while_break;
    }
#line 645
    *(INDEX + i) = (short)0;
#line 644
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 647
  i = 0;
  {
#line 647
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 647
    if (! (i < ngotos)) {
#line 647
      goto while_break___0;
    }
#line 649
    if ((int )*(INDEX + i) == 0) {
#line 649
      if (*(R + i)) {
        {
#line 650
        traverse(i);
        }
      }
    }
#line 647
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 653
  free((void *)((char *)INDEX));
#line 654
  free((void *)((char *)VERTICES));
  }
#line 655
  return;
}
}
#line 660 "/home/wheatley/newnew/temp/perl-byacc-2.0/lalr.c"
static void traverse(int i ) 
{ 
  register unsigned int *fp1 ;
  register unsigned int *fp2 ;
  register unsigned int *fp3 ;
  register int j ;
  register short *rp ;
  int height ;
  unsigned int *base___0 ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;
  short *tmp___1 ;
  int tmp___2 ;
  unsigned int *tmp___3 ;
  unsigned int *tmp___4 ;

  {
#line 675
  top ++;
#line 675
  *(VERTICES + top) = (short )i;
#line 676
  height = top;
#line 676
  *(INDEX + i) = (short )height;
#line 678
  base___0 = F + i * tokensetsize;
#line 679
  fp3 = base___0 + tokensetsize;
#line 681
  rp = *(R + i);
#line 682
  if (rp) {
    {
#line 684
    while (1) {
      while_continue: /* CIL Label */ ;
#line 684
      tmp___1 = rp;
#line 684
      rp ++;
#line 684
      j = (int )*tmp___1;
#line 684
      if (! (j >= 0)) {
#line 684
        goto while_break;
      }
#line 686
      if ((int )*(INDEX + j) == 0) {
        {
#line 687
        traverse(j);
        }
      }
#line 689
      if ((int )*(INDEX + i) > (int )*(INDEX + j)) {
#line 690
        *(INDEX + i) = *(INDEX + j);
      }
#line 692
      fp1 = base___0;
#line 693
      fp2 = F + j * tokensetsize;
      {
#line 695
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 695
        if (! ((unsigned long )fp1 < (unsigned long )fp3)) {
#line 695
          goto while_break___0;
        }
#line 696
        tmp = fp1;
#line 696
        fp1 ++;
#line 696
        tmp___0 = fp2;
#line 696
        fp2 ++;
#line 696
        *tmp |= *tmp___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 700
  if ((int )*(INDEX + i) == height) {
    {
#line 702
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 704
      tmp___2 = top;
#line 704
      top --;
#line 704
      j = (int )*(VERTICES + tmp___2);
#line 705
      *(INDEX + j) = (short )infinity;
#line 707
      if (i == j) {
#line 708
        goto while_break___1;
      }
#line 710
      fp1 = base___0;
#line 711
      fp2 = F + j * tokensetsize;
      {
#line 713
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 713
        if (! ((unsigned long )fp1 < (unsigned long )fp3)) {
#line 713
          goto while_break___2;
        }
#line 714
        tmp___3 = fp2;
#line 714
        fp2 ++;
#line 714
        tmp___4 = fp1;
#line 714
        fp1 ++;
#line 714
        *tmp___3 = *tmp___4;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 717
  return;
}
}
#line 4 "/home/wheatley/newnew/temp/perl-byacc-2.0/verbose.c"
static short *null_rules  ;
#line 6
static void log_unused(void) ;
#line 7
static void log_conflicts(void) ;
#line 8
static void print_state(int state ) ;
#line 9
static void print_conflicts(int state ) ;
#line 10
static void print_core(int state ) ;
#line 11
static void print_nulls(int state ) ;
#line 12
static void print_actions(int stateno ) ;
#line 13
static void print_shifts(action *p ) ;
#line 14
static void print_reductions(action *p , int defred___0 ) ;
#line 15
static void print_gotos(int stateno ) ;
#line 19 "/home/wheatley/newnew/temp/perl-byacc-2.0/verbose.c"
void verbose(void) 
{ 
  register int i ;
  char *tmp ;

  {
#line 26
  if (! vflag) {
#line 26
    return;
  }
  {
#line 28
  tmp = my_malloc((unsigned int )((unsigned long )nrules * sizeof(short )));
#line 28
  null_rules = (short *)tmp;
#line 29
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\f\n");
#line 30
  i = 0;
  }
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! (i < nstates)) {
#line 30
      goto while_break;
    }
    {
#line 31
    print_state(i);
#line 30
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 32
  free((void *)((char *)null_rules));
  }
#line 34
  if (nunused) {
    {
#line 35
    log_unused();
    }
  }
#line 36
  if (SRtotal) {
    {
#line 37
    log_conflicts();
    }
  } else
#line 36
  if (RRtotal) {
    {
#line 37
    log_conflicts();
    }
  }
  {
#line 39
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\n\n%d terminals, %d nonterminals\n",
          ntokens, nvars);
#line 41
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%d grammar rules, %d states\n",
          nrules - 2, nstates);
  }
#line 42
  return;
}
}
#line 46 "/home/wheatley/newnew/temp/perl-byacc-2.0/verbose.c"
static void log_unused(void) 
{ 
  register int i ;
  register short *p ;

  {
  {
#line 54
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\n\nRules never reduced:\n");
#line 55
  i = 3;
  }
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! (i < nrules)) {
#line 55
      goto while_break;
    }
#line 57
    if (! *(rules_used + i)) {
      {
#line 59
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t%s :",
              *(symbol_name + *(rlhs + i)));
#line 60
      p = ritem + (int )*(rrhs + i);
      }
      {
#line 60
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 60
        if (! ((int )*p >= 0)) {
#line 60
          goto while_break___0;
        }
        {
#line 61
        fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)" %s",
                *(symbol_name + *p));
#line 60
        p ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 62
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"  (%d)\n",
              i - 2);
      }
    }
#line 55
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return;
}
}
#line 69 "/home/wheatley/newnew/temp/perl-byacc-2.0/verbose.c"
static void log_conflicts(void) 
{ 
  register int i ;

  {
  {
#line 76
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\n\n");
#line 77
  i = 0;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < nstates)) {
#line 77
      goto while_break;
    }
#line 79
    if (*(SRconflicts + i)) {
#line 79
      goto _L;
    } else
#line 79
    if (*(RRconflicts + i)) {
      _L: /* CIL Label */ 
      {
#line 81
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"State %d contains ",
              i);
      }
#line 82
      if ((int )*(SRconflicts + i) == 1) {
        {
#line 83
        fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"1 shift/reduce conflict");
        }
      } else
#line 84
      if ((int )*(SRconflicts + i) > 1) {
        {
#line 85
        fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%d shift/reduce conflicts",
                (int )*(SRconflicts + i));
        }
      }
#line 87
      if (*(SRconflicts + i)) {
#line 87
        if (*(RRconflicts + i)) {
          {
#line 88
          fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)", ");
          }
        }
      }
#line 89
      if ((int )*(RRconflicts + i) == 1) {
        {
#line 90
        fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"1 reduce/reduce conflict");
        }
      } else
#line 91
      if ((int )*(RRconflicts + i) > 1) {
        {
#line 92
        fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%d reduce/reduce conflicts",
                (int )*(RRconflicts + i));
        }
      }
      {
#line 94
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)".\n");
      }
    }
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  return;
}
}
#line 101 "/home/wheatley/newnew/temp/perl-byacc-2.0/verbose.c"
static void print_state(int state ) 
{ 


  {
#line 107
  if (state) {
    {
#line 108
    fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\n\n");
    }
  }
#line 109
  if (*(SRconflicts + state)) {
    {
#line 110
    print_conflicts(state);
    }
  } else
#line 109
  if (*(RRconflicts + state)) {
    {
#line 110
    print_conflicts(state);
    }
  }
  {
#line 111
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"state %d\n",
          state);
#line 112
  print_core(state);
#line 113
  print_nulls(state);
#line 114
  print_actions(state);
  }
#line 115
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/perl-byacc-2.0/verbose.c"
static void print_conflicts(int state ) 
{ 
  register int symbol ;
  register int act ;
  register int number ;
  register action *p ;

  {
#line 128
  symbol = -1;
#line 129
  p = *(parser + state);
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! p) {
#line 129
      goto while_break;
    }
#line 131
    if ((int )p->suppressed == 2) {
#line 132
      goto __Cont;
    }
#line 134
    if ((int )p->symbol != symbol) {
#line 136
      symbol = (int )p->symbol;
#line 137
      number = (int )p->number;
#line 138
      if ((int )p->action_code == 1) {
#line 139
        act = 1;
      } else {
#line 141
        act = 2;
      }
    } else
#line 143
    if ((int )p->suppressed == 1) {
#line 145
      if (state == (int )final_state) {
#line 145
        if (symbol == 0) {
          {
#line 147
          fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%d: shift/reduce conflict (accept, reduce %d) on $end\n",
                  state, (int )p->number - 2);
          }
        } else {
#line 145
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 152
      if (act == 1) {
        {
#line 154
        fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%d: shift/reduce conflict (shift %d, reduce %d) on %s\n",
                state, number, (int )p->number - 2, *(symbol_name + symbol));
        }
      } else {
        {
#line 160
        fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%d: reduce/reduce conflict (reduce %d, reduce %d) on %s\n",
                state, number - 2, (int )p->number - 2, *(symbol_name + symbol));
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 129
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  return;
}
}
#line 171 "/home/wheatley/newnew/temp/perl-byacc-2.0/verbose.c"
static void print_core(int state ) 
{ 
  register int i ;
  register int k ;
  register int rule ;
  register core *statep ;
  register short *sp ;
  register short *sp1 ;

  {
#line 184
  statep = *(state_table + state);
#line 185
  k = (int )statep->nitems;
#line 187
  i = 0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (i < k)) {
#line 187
      goto while_break;
    }
#line 189
    sp = ritem + (int )statep->items[i];
#line 189
    sp1 = sp;
    {
#line 191
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 191
      if (! ((int )*sp >= 0)) {
#line 191
        goto while_break___0;
      }
#line 191
      sp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 192
    rule = - ((int )*sp);
#line 193
    fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t%s : ",
            *(symbol_name + *(rlhs + rule)));
#line 195
    sp = ritem + (int )*(rrhs + rule);
    }
    {
#line 195
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 195
      if (! ((unsigned long )sp < (unsigned long )sp1)) {
#line 195
        goto while_break___1;
      }
      {
#line 196
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%s ",
              *(symbol_name + *sp));
#line 195
      sp ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 198
    _IO_putc('.', verbose_file);
    }
    {
#line 200
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 200
      if (! ((int )*sp >= 0)) {
#line 200
        goto while_break___2;
      }
      {
#line 202
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)" %s",
              *(symbol_name + *sp));
#line 203
      sp ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 205
    fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"  (%d)\n",
            -2 - (int )*sp);
#line 187
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  return;
}
}
#line 211 "/home/wheatley/newnew/temp/perl-byacc-2.0/verbose.c"
static void print_nulls(int state ) 
{ 
  register action *p ;
  register int i ;
  register int j ;
  register int k ;
  register int nnulls ;

  {
#line 220
  nnulls = 0;
#line 221
  p = *(parser + state);
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! p) {
#line 221
      goto while_break;
    }
#line 223
    if ((int )p->action_code == 2) {
#line 223
      if ((int )p->suppressed == 0) {
#line 223
        goto _L;
      } else
#line 223
      if ((int )p->suppressed == 1) {
        _L: /* CIL Label */ 
#line 226
        i = (int )p->number;
#line 227
        if ((int )*(rrhs + i) + 1 == (int )*(rrhs + (i + 1))) {
#line 229
          j = 0;
          {
#line 229
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 229
            if (j < nnulls) {
#line 229
              if (! (i > (int )*(null_rules + j))) {
#line 229
                goto while_break___0;
              }
            } else {
#line 229
              goto while_break___0;
            }
#line 230
            goto __Cont;
            __Cont: /* CIL Label */ 
#line 229
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 232
          if (j == nnulls) {
#line 234
            nnulls ++;
#line 235
            *(null_rules + j) = (short )i;
          } else
#line 237
          if (i != (int )*(null_rules + j)) {
#line 239
            nnulls ++;
#line 240
            k = nnulls - 1;
            {
#line 240
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 240
              if (! (k > j)) {
#line 240
                goto while_break___1;
              }
#line 241
              *(null_rules + k) = *(null_rules + (k - 1));
#line 240
              k --;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 242
            *(null_rules + j) = (short )i;
          }
        }
      }
    }
#line 221
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  i = 0;
  {
#line 248
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 248
    if (! (i < nnulls)) {
#line 248
      goto while_break___2;
    }
    {
#line 250
    j = (int )*(null_rules + i);
#line 251
    fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t%s : .  (%d)\n",
            *(symbol_name + *(rlhs + j)), j - 2);
#line 248
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 254
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\n");
  }
#line 255
  return;
}
}
#line 259 "/home/wheatley/newnew/temp/perl-byacc-2.0/verbose.c"
static void print_actions(int stateno ) 
{ 
  register action *p ;
  register shifts *sp ;
  register int as ;

  {
#line 269
  if (stateno == (int )final_state) {
    {
#line 270
    fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t$end  accept\n");
    }
  }
#line 272
  p = *(parser + stateno);
#line 273
  if (p) {
    {
#line 275
    print_shifts(p);
#line 276
    print_reductions(p, (int )*(defred + stateno));
    }
  }
#line 279
  sp = *(shift_table + stateno);
#line 280
  if (sp) {
#line 280
    if ((int )sp->nshifts > 0) {
#line 282
      as = (int )*(accessing_symbol + sp->shift[(int )sp->nshifts - 1]);
#line 283
      if (as >= start_symbol) {
        {
#line 284
        print_gotos(stateno);
        }
      }
    }
  }
#line 286
  return;
}
}
#line 290 "/home/wheatley/newnew/temp/perl-byacc-2.0/verbose.c"
static void print_shifts(action *p ) 
{ 
  register int count ;
  register action *q ;

  {
#line 299
  count = 0;
#line 300
  q = p;
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! q) {
#line 300
      goto while_break;
    }
#line 302
    if ((int )q->suppressed < 2) {
#line 302
      if ((int )q->action_code == 1) {
#line 303
        count ++;
      }
    }
#line 300
    q = q->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (count > 0) {
    {
#line 308
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 308
      if (! p) {
#line 308
        goto while_break___0;
      }
#line 310
      if ((int )p->action_code == 1) {
#line 310
        if ((int )p->suppressed == 0) {
          {
#line 311
          fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t%s  shift %d\n",
                  *(symbol_name + p->symbol), (int )p->number);
          }
        }
      }
#line 308
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 315
  return;
}
}
#line 319 "/home/wheatley/newnew/temp/perl-byacc-2.0/verbose.c"
static void print_reductions(action *p , int defred___0 ) 
{ 
  register int k ;
  register int anyreds ;
  register action *q ;

  {
#line 329
  anyreds = 0;
#line 330
  q = p;
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (! q) {
#line 330
      goto while_break;
    }
#line 332
    if ((int )q->action_code == 2) {
#line 332
      if ((int )q->suppressed < 2) {
#line 334
        anyreds = 1;
#line 335
        goto while_break;
      }
    }
#line 330
    q = q->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  if (anyreds == 0) {
    {
#line 340
    fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t.  error\n");
    }
  } else {
    {
#line 343
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 343
      if (! p) {
#line 343
        goto while_break___0;
      }
#line 345
      if ((int )p->action_code == 2) {
#line 345
        if ((int )p->number != defred___0) {
#line 347
          k = (int )p->number - 2;
#line 348
          if ((int )p->suppressed == 0) {
            {
#line 349
            fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t%s  reduce %d\n",
                    *(symbol_name + p->symbol), k);
            }
          }
        }
      }
#line 343
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 354
    if (defred___0 > 0) {
      {
#line 355
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t.  reduce %d\n",
              defred___0 - 2);
      }
    }
  }
#line 357
  return;
}
}
#line 361 "/home/wheatley/newnew/temp/perl-byacc-2.0/verbose.c"
static void print_gotos(int stateno ) 
{ 
  register int i ;
  register int k ;
  register int as ;
  register short *to_state___0 ;
  register shifts *sp ;

  {
  {
#line 372
  _IO_putc('\n', verbose_file);
#line 373
  sp = *(shift_table + stateno);
#line 374
  to_state___0 = sp->shift;
#line 375
  i = 0;
  }
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! (i < (int )sp->nshifts)) {
#line 375
      goto while_break;
    }
#line 377
    k = (int )*(to_state___0 + i);
#line 378
    as = (int )*(accessing_symbol + k);
#line 379
    if (as >= start_symbol) {
      {
#line 380
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t%s  goto %d\n",
              *(symbol_name + as), k);
      }
    }
#line 375
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  return;
}
}
#line 278 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
int nstates  ;
#line 279 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
core *first_state  ;
#line 280 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
shifts *first_shift  ;
#line 281 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
reductions *first_reduction  ;
#line 306
void closure(short *nucleus , int n ) ;
#line 313
void finalize_closure(void) ;
#line 314
void free_derives(void) ;
#line 315
void free_nullable(void) ;
#line 342
void set_first_derives(void) ;
#line 3 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
short *itemset ;
#line 4
short *itemsetend ;
#line 5
unsigned int *ruleset ;
#line 12 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static core **state_set  ;
#line 13 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static core *this_state  ;
#line 14 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static core *last_state  ;
#line 15 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static shifts *last_shift  ;
#line 16 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static reductions *last_reduction  ;
#line 18 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static int nshifts  ;
#line 19 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static short *shift_symbol  ;
#line 21 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static short *redset  ;
#line 22 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static short *shiftset  ;
#line 24 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static short **kernel_base  ;
#line 25 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static short **kernel_end  ;
#line 26 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static short *kernel_items  ;
#line 28
static void allocate_itemsets(void) ;
#line 29
static void allocate_storage(void) ;
#line 30
static void append_states(void) ;
#line 31
static void free_storage(void) ;
#line 32
static void generate_states(void) ;
#line 33
static int get_state(int symbol ) ;
#line 34
static void initialize_states(void) ;
#line 35
static void new_itemsets(void) ;
#line 36
static core *new_state(int symbol ) ;
#line 37
static void save_shifts(void) ;
#line 38
static void save_reductions(void) ;
#line 39
static void set_derives(void) ;
#line 40
static void set_nullable(void) ;
#line 50 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void allocate_itemsets(void) 
{ 
  register short *itemp ;
  register short *item_end ;
  register int symbol ;
  register int i ;
  register int count ;
  register int max ;
  register short *symbol_count ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 60
  count = 0;
#line 61
  tmp = allocate((unsigned int )((unsigned long )nsyms * sizeof(short )));
#line 61
  symbol_count = (short *)tmp;
#line 63
  item_end = ritem + nitems;
#line 64
  itemp = ritem;
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! ((unsigned long )itemp < (unsigned long )item_end)) {
#line 64
      goto while_break;
    }
#line 66
    symbol = (int )*itemp;
#line 67
    if (symbol >= 0) {
#line 69
      count ++;
#line 70
      *(symbol_count + symbol) = (short )((int )*(symbol_count + symbol) + 1);
    }
#line 64
    itemp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 74
  tmp___0 = allocate((unsigned int )((unsigned long )nsyms * sizeof(short *)));
#line 74
  kernel_base = (short **)tmp___0;
#line 75
  tmp___1 = allocate((unsigned int )((unsigned long )count * sizeof(short )));
#line 75
  kernel_items = (short *)tmp___1;
#line 77
  count = 0;
#line 78
  max = 0;
#line 79
  i = 0;
  }
  {
#line 79
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 79
    if (! (i < nsyms)) {
#line 79
      goto while_break___0;
    }
#line 81
    *(kernel_base + i) = kernel_items + count;
#line 82
    count += (int )*(symbol_count + i);
#line 83
    if (max < (int )*(symbol_count + i)) {
#line 84
      max = (int )*(symbol_count + i);
    }
#line 79
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 87
  shift_symbol = symbol_count;
#line 88
  tmp___2 = allocate((unsigned int )((unsigned long )nsyms * sizeof(short *)));
#line 88
  kernel_end = (short **)tmp___2;
  }
#line 89
  return;
}
}
#line 92 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void allocate_storage(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 94
  allocate_itemsets();
#line 95
  tmp = allocate((unsigned int )((unsigned long )nsyms * sizeof(short )));
#line 95
  shiftset = (short *)tmp;
#line 96
  tmp___0 = allocate((unsigned int )((unsigned long )(nrules + 1) * sizeof(short )));
#line 96
  redset = (short *)tmp___0;
#line 97
  tmp___1 = allocate((unsigned int )((unsigned long )nitems * sizeof(core *)));
#line 97
  state_set = (core **)tmp___1;
  }
#line 98
  return;
}
}
#line 101 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void append_states(void) 
{ 
  register int i ;
  register int j ;
  register int symbol ;
  int tmp ;

  {
#line 110
  i = 1;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! (i < nshifts)) {
#line 110
      goto while_break;
    }
#line 112
    symbol = (int )*(shift_symbol + i);
#line 113
    j = i;
    {
#line 114
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 114
      if (j > 0) {
#line 114
        if (! ((int )*(shift_symbol + (j - 1)) > symbol)) {
#line 114
          goto while_break___0;
        }
      } else {
#line 114
        goto while_break___0;
      }
#line 116
      *(shift_symbol + j) = *(shift_symbol + (j - 1));
#line 117
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 119
    *(shift_symbol + j) = (short )symbol;
#line 110
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  i = 0;
  {
#line 122
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 122
    if (! (i < nshifts)) {
#line 122
      goto while_break___1;
    }
    {
#line 124
    symbol = (int )*(shift_symbol + i);
#line 125
    tmp = get_state(symbol);
#line 125
    *(shiftset + i) = (short )tmp;
#line 122
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 127
  return;
}
}
#line 130 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void free_storage(void) 
{ 


  {
  {
#line 132
  free((void *)((char *)shift_symbol));
#line 133
  free((void *)((char *)redset));
#line 134
  free((void *)((char *)shiftset));
#line 135
  free((void *)((char *)kernel_base));
#line 136
  free((void *)((char *)kernel_end));
#line 137
  free((void *)((char *)kernel_items));
#line 138
  free((void *)((char *)state_set));
  }
#line 139
  return;
}
}
#line 143 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void generate_states(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 145
  allocate_storage();
#line 146
  tmp = allocate((unsigned int )((unsigned long )nitems * sizeof(short )));
#line 146
  itemset = (short *)tmp;
#line 147
  tmp___0 = allocate((unsigned int )((unsigned long )((nrules + 31) / 32) * sizeof(unsigned int )));
#line 147
  ruleset = (unsigned int *)tmp___0;
#line 148
  set_first_derives();
#line 149
  initialize_states();
  }
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! this_state) {
#line 151
      goto while_break;
    }
    {
#line 153
    closure(this_state->items, (int )this_state->nitems);
#line 154
    save_reductions();
#line 155
    new_itemsets();
#line 156
    append_states();
    }
#line 158
    if (nshifts > 0) {
      {
#line 159
      save_shifts();
      }
    }
#line 161
    this_state = this_state->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  finalize_closure();
#line 165
  free_storage();
  }
#line 166
  return;
}
}
#line 170 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static int get_state(int symbol ) 
{ 
  register int key ;
  register short *isp1 ;
  register short *isp2 ;
  register short *iend ;
  register core *sp ;
  register int found ;
  register int n ;
  short *tmp ;
  short *tmp___0 ;
  struct core *tmp___1 ;

  {
#line 185
  isp1 = *(kernel_base + symbol);
#line 186
  iend = *(kernel_end + symbol);
#line 187
  n = (int )(iend - isp1);
#line 189
  key = (int )*isp1;
#line 190
  if (0 <= key) {
#line 190
    if (! (key < nitems)) {
      {
#line 190
      __assert_fail("0 <= key && key < nitems", "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c",
                    190U, "get_state");
      }
    }
  } else {
    {
#line 190
    __assert_fail("0 <= key && key < nitems", "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c",
                  190U, "get_state");
    }
  }
#line 191
  sp = *(state_set + key);
#line 192
  if (sp) {
#line 194
    found = 0;
    {
#line 195
    while (1) {
      while_continue: /* CIL Label */ ;
#line 195
      if (! (! found)) {
#line 195
        goto while_break;
      }
#line 197
      if ((int )sp->nitems == n) {
#line 199
        found = 1;
#line 200
        isp1 = *(kernel_base + symbol);
#line 201
        isp2 = sp->items;
        {
#line 203
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 203
          if (found) {
#line 203
            if (! ((unsigned long )isp1 < (unsigned long )iend)) {
#line 203
              goto while_break___0;
            }
          } else {
#line 203
            goto while_break___0;
          }
#line 205
          tmp = isp1;
#line 205
          isp1 ++;
#line 205
          tmp___0 = isp2;
#line 205
          isp2 ++;
#line 205
          if ((int )*tmp != (int )*tmp___0) {
#line 206
            found = 0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 210
      if (! found) {
#line 212
        if (sp->link) {
#line 214
          sp = sp->link;
        } else {
          {
#line 218
          tmp___1 = new_state(symbol);
#line 218
          sp->link = tmp___1;
#line 218
          sp = tmp___1;
#line 219
          found = 1;
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 226
    sp = new_state(symbol);
#line 226
    *(state_set + key) = sp;
    }
  }
#line 229
  return ((int )sp->number);
}
}
#line 234 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void initialize_states(void) 
{ 
  register int i ;
  register short *start_derives ;
  register core *p ;
  char *tmp ;

  {
#line 240
  start_derives = *(derives + start_symbol);
#line 241
  i = 0;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! ((int )*(start_derives + i) >= 0)) {
#line 241
      goto while_break;
    }
#line 242
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 241
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 244
  tmp = my_malloc((unsigned int )(sizeof(core ) + (unsigned long )i * sizeof(short )));
#line 244
  p = (core *)tmp;
#line 246
  p->next = (struct core *)0;
#line 247
  p->link = (struct core *)0;
#line 248
  p->number = (short)0;
#line 249
  p->accessing_symbol = (short)0;
#line 250
  p->nitems = (short )i;
#line 252
  i = 0;
  }
  {
#line 252
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 252
    if (! ((int )*(start_derives + i) >= 0)) {
#line 252
      goto while_break___0;
    }
#line 253
    p->items[i] = *(rrhs + *(start_derives + i));
#line 252
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 255
  this_state = p;
#line 255
  last_state = this_state;
#line 255
  first_state = last_state;
#line 256
  nstates = 1;
#line 257
  return;
}
}
#line 260 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void new_itemsets(void) 
{ 
  register int i ;
  register int shiftcount ;
  register short *isp ;
  register short *ksp ;
  register int symbol ;
  short *tmp ;
  int tmp___0 ;
  short *tmp___1 ;

  {
#line 268
  i = 0;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! (i < nsyms)) {
#line 268
      goto while_break;
    }
#line 269
    *(kernel_end + i) = (short *)0;
#line 268
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  shiftcount = 0;
#line 272
  isp = itemset;
  {
#line 273
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 273
    if (! ((unsigned long )isp < (unsigned long )itemsetend)) {
#line 273
      goto while_break___0;
    }
#line 275
    tmp = isp;
#line 275
    isp ++;
#line 275
    i = (int )*tmp;
#line 276
    symbol = (int )*(ritem + i);
#line 277
    if (symbol > 0) {
#line 279
      ksp = *(kernel_end + symbol);
#line 280
      if (! ksp) {
#line 282
        tmp___0 = shiftcount;
#line 282
        shiftcount ++;
#line 282
        *(shift_symbol + tmp___0) = (short )symbol;
#line 283
        ksp = *(kernel_base + symbol);
      }
#line 286
      tmp___1 = ksp;
#line 286
      ksp ++;
#line 286
      *tmp___1 = (short )(i + 1);
#line 287
      *(kernel_end + symbol) = ksp;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 291
  nshifts = shiftcount;
#line 292
  return;
}
}
#line 296 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static core *new_state(int symbol ) 
{ 
  register int n ;
  register core *p ;
  register short *isp1 ;
  register short *isp2 ;
  register short *iend ;
  char *tmp ;
  short *tmp___0 ;
  short *tmp___1 ;

  {
#line 309
  if (nstates >= 32767) {
    {
#line 310
    fatal((char *)"too many states");
    }
  }
  {
#line 312
  isp1 = *(kernel_base + symbol);
#line 313
  iend = *(kernel_end + symbol);
#line 314
  n = (int )(iend - isp1);
#line 316
  tmp = allocate((unsigned int )(sizeof(core ) + (unsigned long )(n - 1) * sizeof(short )));
#line 316
  p = (core *)tmp;
#line 317
  p->accessing_symbol = (short )symbol;
#line 318
  p->number = (short )nstates;
#line 319
  p->nitems = (short )n;
#line 321
  isp2 = p->items;
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! ((unsigned long )isp1 < (unsigned long )iend)) {
#line 322
      goto while_break;
    }
#line 323
    tmp___0 = isp2;
#line 323
    isp2 ++;
#line 323
    tmp___1 = isp1;
#line 323
    isp1 ++;
#line 323
    *tmp___0 = *tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  last_state->next = p;
#line 326
  last_state = p;
#line 328
  nstates ++;
#line 330
  return (p);
}
}
#line 406 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void save_shifts(void) 
{ 
  register shifts *p ;
  register short *sp1 ;
  register short *sp2 ;
  register short *send ;
  char *tmp ;
  short *tmp___0 ;
  short *tmp___1 ;

  {
  {
#line 413
  tmp = allocate((unsigned int )(sizeof(shifts ) + (unsigned long )(nshifts - 1) * sizeof(short )));
#line 413
  p = (shifts *)tmp;
#line 416
  p->number = this_state->number;
#line 417
  p->nshifts = (short )nshifts;
#line 419
  sp1 = shiftset;
#line 420
  sp2 = p->shift;
#line 421
  send = shiftset + nshifts;
  }
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (! ((unsigned long )sp1 < (unsigned long )send)) {
#line 423
      goto while_break;
    }
#line 424
    tmp___0 = sp2;
#line 424
    sp2 ++;
#line 424
    tmp___1 = sp1;
#line 424
    sp1 ++;
#line 424
    *tmp___0 = *tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  if (last_shift) {
#line 428
    last_shift->next = p;
#line 429
    last_shift = p;
  } else {
#line 433
    first_shift = p;
#line 434
    last_shift = p;
  }
#line 436
  return;
}
}
#line 440 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void save_reductions(void) 
{ 
  register short *isp ;
  register short *rp1 ;
  register short *rp2 ;
  register int item ;
  register int count ;
  register reductions *p ;
  register short *rend ;
  int tmp ;
  char *tmp___0 ;
  short *tmp___1 ;
  short *tmp___2 ;

  {
#line 450
  count = 0;
#line 451
  isp = itemset;
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 451
    if (! ((unsigned long )isp < (unsigned long )itemsetend)) {
#line 451
      goto while_break;
    }
#line 453
    item = (int )*(ritem + *isp);
#line 454
    if (item < 0) {
#line 456
      tmp = count;
#line 456
      count ++;
#line 456
      *(redset + tmp) = (short )(- item);
    }
#line 451
    isp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 460
  if (count) {
    {
#line 462
    tmp___0 = allocate((unsigned int )(sizeof(reductions ) + (unsigned long )(count - 1) * sizeof(short )));
#line 462
    p = (reductions *)tmp___0;
#line 465
    p->number = this_state->number;
#line 466
    p->nreds = (short )count;
#line 468
    rp1 = redset;
#line 469
    rp2 = p->rules;
#line 470
    rend = rp1 + count;
    }
    {
#line 472
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 472
      if (! ((unsigned long )rp1 < (unsigned long )rend)) {
#line 472
        goto while_break___0;
      }
#line 473
      tmp___1 = rp2;
#line 473
      rp2 ++;
#line 473
      tmp___2 = rp1;
#line 473
      rp1 ++;
#line 473
      *tmp___1 = *tmp___2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 475
    if (last_reduction) {
#line 477
      last_reduction->next = p;
#line 478
      last_reduction = p;
    } else {
#line 482
      first_reduction = p;
#line 483
      last_reduction = p;
    }
  }
#line 486
  return;
}
}
#line 489 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void set_derives(void) 
{ 
  register int i ;
  register int k ;
  register int lhs ;
  register short *rules ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 495
  tmp = allocate((unsigned int )((unsigned long )nsyms * sizeof(short *)));
#line 495
  derives = (short **)tmp;
#line 496
  tmp___0 = allocate((unsigned int )((unsigned long )(nvars + nrules) * sizeof(short )));
#line 496
  rules = (short *)tmp___0;
#line 498
  k = 0;
#line 499
  lhs = start_symbol;
  }
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! (lhs < nsyms)) {
#line 499
      goto while_break;
    }
#line 501
    *(derives + lhs) = rules + k;
#line 502
    i = 0;
    {
#line 502
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 502
      if (! (i < nrules)) {
#line 502
        goto while_break___0;
      }
#line 504
      if ((int )*(rlhs + i) == lhs) {
#line 506
        *(rules + k) = (short )i;
#line 507
        k ++;
      }
#line 502
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 510
    *(rules + k) = (short)-1;
#line 511
    k ++;
#line 499
    lhs ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  return;
}
}
#line 520 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
void free_derives(void) 
{ 


  {
  {
#line 525
  free((void *)((char *)*(derives + start_symbol)));
#line 526
  free((void *)((char *)derives));
  }
#line 527
  return;
}
}
#line 552 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void set_nullable(void) 
{ 
  register int i ;
  register int j ;
  register int empty ;
  int done___0 ;

  {
  {
#line 558
  nullable = my_malloc((unsigned int )nsyms);
#line 560
  i = 0;
  }
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 560
    if (! (i < nsyms)) {
#line 560
      goto while_break;
    }
#line 561
    *(nullable + i) = (char)0;
#line 560
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 563
  done___0 = 0;
  {
#line 564
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 564
    if (! (! done___0)) {
#line 564
      goto while_break___0;
    }
#line 566
    done___0 = 1;
#line 567
    i = 1;
    {
#line 567
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 567
      if (! (i < nitems)) {
#line 567
        goto while_break___1;
      }
#line 569
      empty = 1;
      {
#line 570
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 570
        j = (int )*(ritem + i);
#line 570
        if (! (j >= 0)) {
#line 570
          goto while_break___2;
        }
#line 572
        if (! *(nullable + j)) {
#line 573
          empty = 0;
        }
#line 574
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 576
      if (empty) {
#line 578
        j = (int )*(rlhs + - j);
#line 579
        if (! *(nullable + j)) {
#line 581
          *(nullable + j) = (char)1;
#line 582
          done___0 = 0;
        }
      }
#line 567
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 597
  return;
}
}
#line 601 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
void free_nullable(void) 
{ 


  {
  {
#line 606
  free((void *)nullable);
  }
#line 607
  return;
}
}
#line 610 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
void lr0(void) 
{ 


  {
  {
#line 612
  set_derives();
#line 613
  set_nullable();
#line 614
  generate_states();
  }
#line 615
  return;
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 216 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char *cptr ;
#line 255
int ntags ;
#line 257
char unionized ;
#line 258
char line_format[15] ;
#line 3 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static int nvectors  ;
#line 4 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static int nentries  ;
#line 5 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static short **froms  ;
#line 6 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static short **tos  ;
#line 7 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static short *tally  ;
#line 8 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static short *width  ;
#line 9 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static short *state_count  ;
#line 10 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static short *order  ;
#line 11 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static short *base  ;
#line 12 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static short *pos  ;
#line 13 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static int maxtable  ;
#line 14 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static short *table  ;
#line 15 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static short *check  ;
#line 16 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static int lowzero  ;
#line 17 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static int high  ;
#line 20
static void free_itemsets(void) ;
#line 21
static void free_shifts(void) ;
#line 22
static void free_reductions(void) ;
#line 23
static void output_stored_text(void) ;
#line 24
static void output_defines(void) ;
#line 25
static void write_num(int value ) ;
#line 26
static void start_num_array(char *name , int indent , int first ) ;
#line 27
static void start_string_array(char *name , int nl ) ;
#line 28
static void end_num_array(void) ;
#line 29
static void end_string_array(int nl ) ;
#line 30
static void start_define(FILE *file ) ;
#line 31
static void end_define(FILE *file , int value ) ;
#line 32
static void write_define(char *name , int value ) ;
#line 33
static void write_null(void) ;
#line 34
static void output_rule_data(void) ;
#line 35
static void output_yydefred(void) ;
#line 36
static void output_actions(void) ;
#line 37
static void token_actions(void) ;
#line 38
static void goto_actions(void) ;
#line 39
static int default_goto(int symbol ) ;
#line 40
static void save_column(int symbol , int default_state ) ;
#line 41
static void sort_actions(void) ;
#line 42
static void pack_table(void) ;
#line 43
static int matching_vector(int vector ) ;
#line 44
static int pack_vector(int vector ) ;
#line 45
static void output_base(void) ;
#line 46
static void output_table(void) ;
#line 47
static void output_check(void) ;
#line 48
static int is_C_identifier(char *name ) ;
#line 49
static void output_debug(void) ;
#line 50
static void output_stype(void) ;
#line 51
static void output_trailing_text(void) ;
#line 52
static void output_semantic_actions(void) ;
#line 56 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
void output(void) 
{ 


  {
  {
#line 61
  free_itemsets();
#line 62
  free_shifts();
#line 63
  free_reductions();
#line 64
  output_stored_text();
#line 65
  output_defines();
#line 66
  output_rule_data();
#line 67
  output_yydefred();
#line 68
  output_actions();
#line 69
  free_parser();
#line 70
  output_debug();
#line 71
  output_stype();
  }
#line 72
  if (rflag) {
    {
#line 72
    write_section(tables);
    }
  }
#line 73
  if ((unsigned int )language == 1U) {
#line 73
    if (perl5005flag) {
      {
#line 74
      fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"use fields qw(yylex yyerror yydebug yynerrs yyerrflag yym \n");
#line 76
      fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"              yyn yyss yyssp yyvs yyvsp yystate yyval \n");
#line 78
      fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"              yylval yychar yys);\n");
      }
    }
  }
  {
#line 81
  write_section(header);
  }
#line 82
  if ((unsigned int )language == 0U) {
    {
#line 83
    output_trailing_text();
    }
  }
#line 84
  if ((unsigned int )language == 1U) {
    {
#line 85
    fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"sub new {\n");
    }
#line 86
    if (perl5005flag) {
      {
#line 87
      fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"  my %s $p = bless [\\%FIELDS], $_[0];\n",
              perl_package);
      }
    } else {
      {
#line 91
      fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"  my $p = bless {}, $_[0];\n");
      }
    }
  }
  {
#line 94
  write_section(body);
#line 95
  output_semantic_actions();
#line 96
  write_section(trailer);
  }
#line 97
  if ((unsigned int )language == 1U) {
    {
#line 98
    output_trailing_text();
#line 99
    fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"1;\n");
    }
  }
  {
#line 101
  free_derives();
#line 102
  free_nullable();
  }
#line 103
  return;
}
}
#line 107 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void write_num(int value ) 
{ 


  {
  {
#line 115
  if ((unsigned int )language == 1U) {
#line 115
    goto case_1;
  }
#line 118
  if ((unsigned int )language == 0U) {
#line 118
    goto case_0;
  }
#line 113
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 116
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"%5d,",
          value);
  }
#line 117
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 119
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"%5d,",
          value);
  }
#line 120
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 125 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void start_num_array(char *name , int indent , int first ) 
{ 


  {
  {
#line 134
  if ((unsigned int )language == 1U) {
#line 134
    goto case_1;
  }
#line 138
  if ((unsigned int )language == 0U) {
#line 138
    goto case_0;
  }
#line 132
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 135
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"@%s%s = (%*d,",
          symbol_prefix, name, indent + 7, first);
  }
#line 137
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 139
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"short %s%s[] = {%*d,",
          symbol_prefix, name, indent, first);
  }
#line 141
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 146 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void start_string_array(char *name , int nl ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 155
  if ((unsigned int )language == 1U) {
#line 155
    goto case_1;
  }
#line 159
  if ((unsigned int )language == 0U) {
#line 159
    goto case_0;
  }
#line 153
  goto switch_break;
  case_1: /* CIL Label */ 
#line 156
  if (nl) {
#line 156
    tmp = "\n";
  } else {
#line 156
    tmp = "";
  }
  {
#line 156
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"@%s%s = (%s",
          symbol_prefix, name, tmp);
  }
#line 158
  goto switch_break;
  case_0: /* CIL Label */ 
#line 160
  if (nl) {
#line 160
    tmp___0 = "\n";
  } else {
#line 160
    tmp___0 = "";
  }
  {
#line 160
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"char *%s%s[] = {%s",
          symbol_prefix, name, tmp___0);
  }
#line 162
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 169 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void end_num_array(void) 
{ 


  {
  {
#line 174
  if ((unsigned int )language == 1U) {
#line 174
    goto case_1;
  }
#line 177
  if ((unsigned int )language == 0U) {
#line 177
    goto case_0;
  }
#line 172
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 175
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\n);\n");
  }
#line 176
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 178
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\n};\n");
  }
#line 179
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 181
  return;
}
}
#line 184 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void end_string_array(int nl ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 192
  if ((unsigned int )language == 1U) {
#line 192
    goto case_1;
  }
#line 195
  if ((unsigned int )language == 0U) {
#line 195
    goto case_0;
  }
#line 190
  goto switch_break;
  case_1: /* CIL Label */ 
#line 193
  if (nl) {
#line 193
    tmp = "\n";
  } else {
#line 193
    tmp = "";
  }
  {
#line 193
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"%s);\n",
          tmp);
  }
#line 194
  goto switch_break;
  case_0: /* CIL Label */ 
#line 196
  if (nl) {
#line 196
    tmp___0 = "\n";
  } else {
#line 196
    tmp___0 = "";
  }
  {
#line 196
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"%s};\n",
          tmp___0);
  }
#line 197
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 199
  return;
}
}
#line 202 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void start_define(FILE *file ) 
{ 


  {
  {
#line 210
  if ((unsigned int )language == 1U) {
#line 210
    goto case_1;
  }
#line 213
  if ((unsigned int )language == 0U) {
#line 213
    goto case_0;
  }
#line 208
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 211
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"$");
  }
#line 212
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 214
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"#define ");
  }
#line 215
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 217
  return;
}
}
#line 220 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void end_define(FILE *file , int value ) 
{ 


  {
#line 227
  if ((unsigned int )language == 1U) {
    {
#line 228
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"=%d;\n",
            value);
    }
  } else {
    {
#line 230
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %d\n",
            value);
    }
  }
#line 231
  return;
}
}
#line 236 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void write_define(char *name , int value ) 
{ 


  {
  {
#line 241
  start_define(code_file);
#line 242
  fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"%s%s",
          define_prefix, name);
#line 243
  end_define(code_file, value);
  }
#line 244
  return;
}
}
#line 249 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void write_null(void) 
{ 


  {
  {
#line 254
  if ((unsigned int )language == 1U) {
#line 254
    goto case_1;
  }
#line 257
  if ((unsigned int )language == 0U) {
#line 257
    goto case_0;
  }
#line 252
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 255
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\'\',");
  }
#line 256
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 258
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"0,");
  }
#line 259
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 261
  return;
}
}
#line 264 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void output_rule_data(void) 
{ 
  register int i ;
  register int j ;

  {
  {
#line 273
  start_num_array((char *)"lhs", 42, (int )*(symbol_value + start_symbol));
#line 275
  j = 10;
#line 276
  i = 3;
  }
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if (! (i < nrules)) {
#line 276
      goto while_break;
    }
#line 278
    if (j >= 10) {
#line 280
      if (! rflag) {
#line 280
        outline ++;
      }
      {
#line 281
      _IO_putc('\n', output_file);
#line 282
      j = 1;
      }
    } else {
#line 285
      j ++;
    }
    {
#line 287
    write_num((int )*(symbol_value + *(rlhs + i)));
#line 276
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 289
  if (! rflag) {
#line 289
    outline += 2;
  }
  {
#line 290
  end_num_array();
#line 292
  start_num_array((char *)"len", 42, 2);
#line 294
  j = 10;
#line 295
  i = 3;
  }
  {
#line 295
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 295
    if (! (i < nrules)) {
#line 295
      goto while_break___0;
    }
#line 297
    if (j >= 10) {
#line 299
      if (! rflag) {
#line 299
        outline ++;
      }
      {
#line 300
      _IO_putc('\n', output_file);
#line 301
      j = 1;
      }
    } else {
#line 304
      j ++;
    }
    {
#line 306
    write_num(((int )*(rrhs + (i + 1)) - (int )*(rrhs + i)) - 1);
#line 295
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 308
  if (! rflag) {
#line 308
    outline += 2;
  }
  {
#line 309
  end_num_array();
  }
#line 310
  return;
}
}
#line 314 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void output_yydefred(void) 
{ 
  register int i ;
  register int j ;
  int tmp ;
  int tmp___0 ;

  {
#line 321
  if (*(defred + 0)) {
#line 321
    tmp = (int )*(defred + 0) - 2;
  } else {
#line 321
    tmp = 0;
  }
  {
#line 321
  start_num_array((char *)"defred", 39, tmp);
#line 324
  j = 10;
#line 325
  i = 1;
  }
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if (! (i < nstates)) {
#line 325
      goto while_break;
    }
#line 327
    if (j < 10) {
#line 328
      j ++;
    } else {
#line 331
      if (! rflag) {
#line 331
        outline ++;
      }
      {
#line 332
      _IO_putc('\n', output_file);
#line 333
      j = 1;
      }
    }
#line 336
    if (*(defred + i)) {
#line 336
      tmp___0 = (int )*(defred + i) - 2;
    } else {
#line 336
      tmp___0 = 0;
    }
    {
#line 336
    write_num(tmp___0);
#line 325
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  if (! rflag) {
#line 339
    outline += 2;
  }
  {
#line 340
  end_num_array();
  }
#line 341
  return;
}
}
#line 345 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void output_actions(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 350
  nvectors = 2 * nstates + nvars;
#line 352
  tmp = allocate((unsigned int )((unsigned long )nvectors * sizeof(short *)));
#line 352
  froms = (short **)tmp;
#line 353
  tmp___0 = allocate((unsigned int )((unsigned long )nvectors * sizeof(short *)));
#line 353
  tos = (short **)tmp___0;
#line 354
  tmp___1 = allocate((unsigned int )((unsigned long )nvectors * sizeof(short )));
#line 354
  tally = (short *)tmp___1;
#line 355
  tmp___2 = allocate((unsigned int )((unsigned long )nvectors * sizeof(short )));
#line 355
  width = (short *)tmp___2;
#line 357
  token_actions();
#line 358
  free((void *)((char *)lookaheads));
#line 359
  free((void *)((char *)LA));
#line 360
  free((void *)((char *)LAruleno));
#line 361
  free((void *)((char *)accessing_symbol));
#line 363
  goto_actions();
#line 364
  free((void *)((char *)(goto_map + ntokens)));
#line 365
  free((void *)((char *)from_state));
#line 366
  free((void *)((char *)to_state));
#line 368
  sort_actions();
#line 369
  pack_table();
#line 370
  output_base();
#line 371
  output_table();
#line 372
  output_check();
  }
#line 373
  return;
}
}
#line 377 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void token_actions(void) 
{ 
  register int i ;
  register int j ;
  register int shiftcount ;
  register int reducecount ;
  register int max ;
  register int min ;
  register short *actionrow ;
  register short *r ;
  register short *s ;
  register action *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  short *tmp___2 ;
  short *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  short *tmp___6 ;
  short *tmp___7 ;

  {
  {
#line 388
  tmp = allocate((unsigned int )((unsigned long )(2 * ntokens) * sizeof(short )));
#line 388
  actionrow = (short *)tmp;
#line 389
  i = 0;
  }
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! (i < nstates)) {
#line 389
      goto while_break;
    }
#line 391
    if (*(parser + i)) {
#line 393
      j = 0;
      {
#line 393
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 393
        if (! (j < 2 * ntokens)) {
#line 393
          goto while_break___0;
        }
#line 394
        *(actionrow + j) = (short)0;
#line 393
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 396
      shiftcount = 0;
#line 397
      reducecount = 0;
#line 398
      p = *(parser + i);
      {
#line 398
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 398
        if (! p) {
#line 398
          goto while_break___1;
        }
#line 400
        if ((int )p->suppressed == 0) {
#line 402
          if ((int )p->action_code == 1) {
#line 404
            shiftcount ++;
#line 405
            *(actionrow + p->symbol) = p->number;
          } else
#line 407
          if ((int )p->action_code == 2) {
#line 407
            if ((int )p->number != (int )*(defred + i)) {
#line 409
              reducecount ++;
#line 410
              *(actionrow + ((int )p->symbol + ntokens)) = p->number;
            }
          }
        }
#line 398
        p = p->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 415
      *(tally + i) = (short )shiftcount;
#line 416
      *(tally + (nstates + i)) = (short )reducecount;
#line 417
      *(width + i) = (short)0;
#line 418
      *(width + (nstates + i)) = (short)0;
#line 419
      if (shiftcount > 0) {
        {
#line 421
        tmp___0 = allocate((unsigned int )((unsigned long )shiftcount * sizeof(short )));
#line 421
        r = (short *)tmp___0;
#line 421
        *(froms + i) = r;
#line 422
        tmp___1 = allocate((unsigned int )((unsigned long )shiftcount * sizeof(short )));
#line 422
        s = (short *)tmp___1;
#line 422
        *(tos + i) = s;
#line 423
        min = 32767;
#line 424
        max = 0;
#line 425
        j = 0;
        }
        {
#line 425
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 425
          if (! (j < ntokens)) {
#line 425
            goto while_break___2;
          }
#line 427
          if (*(actionrow + j)) {
#line 429
            if (min > (int )*(symbol_value + j)) {
#line 430
              min = (int )*(symbol_value + j);
            }
#line 431
            if (max < (int )*(symbol_value + j)) {
#line 432
              max = (int )*(symbol_value + j);
            }
#line 433
            tmp___2 = r;
#line 433
            r ++;
#line 433
            *tmp___2 = *(symbol_value + j);
#line 434
            tmp___3 = s;
#line 434
            s ++;
#line 434
            *tmp___3 = *(actionrow + j);
          }
#line 425
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 437
        *(width + i) = (short )((max - min) + 1);
      }
#line 439
      if (reducecount > 0) {
        {
#line 441
        tmp___4 = allocate((unsigned int )((unsigned long )reducecount * sizeof(short )));
#line 441
        r = (short *)tmp___4;
#line 441
        *(froms + (nstates + i)) = r;
#line 442
        tmp___5 = allocate((unsigned int )((unsigned long )reducecount * sizeof(short )));
#line 442
        s = (short *)tmp___5;
#line 442
        *(tos + (nstates + i)) = s;
#line 443
        min = 32767;
#line 444
        max = 0;
#line 445
        j = 0;
        }
        {
#line 445
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 445
          if (! (j < ntokens)) {
#line 445
            goto while_break___3;
          }
#line 447
          if (*(actionrow + (ntokens + j))) {
#line 449
            if (min > (int )*(symbol_value + j)) {
#line 450
              min = (int )*(symbol_value + j);
            }
#line 451
            if (max < (int )*(symbol_value + j)) {
#line 452
              max = (int )*(symbol_value + j);
            }
#line 453
            tmp___6 = r;
#line 453
            r ++;
#line 453
            *tmp___6 = *(symbol_value + j);
#line 454
            tmp___7 = s;
#line 454
            s ++;
#line 454
            *tmp___7 = (short )((int )*(actionrow + (ntokens + j)) - 2);
          }
#line 445
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 457
        *(width + (nstates + i)) = (short )((max - min) + 1);
      }
    }
#line 389
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 461
  free((void *)((char *)actionrow));
  }
#line 462
  return;
}
}
#line 465 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void goto_actions(void) 
{ 
  register int i ;
  register int j ;
  register int k ;
  char *tmp ;

  {
  {
#line 472
  tmp = allocate((unsigned int )((unsigned long )nstates * sizeof(short )));
#line 472
  state_count = (short *)tmp;
#line 474
  k = default_goto(start_symbol + 1);
#line 475
  start_num_array((char *)"dgoto", 40, k);
#line 476
  save_column(start_symbol + 1, k);
#line 478
  j = 10;
#line 479
  i = start_symbol + 2;
  }
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    if (! (i < nsyms)) {
#line 479
      goto while_break;
    }
#line 481
    if (j >= 10) {
#line 483
      if (! rflag) {
#line 483
        outline ++;
      }
      {
#line 484
      _IO_putc('\n', output_file);
#line 485
      j = 1;
      }
    } else {
#line 488
      j ++;
    }
    {
#line 490
    k = default_goto(i);
#line 491
    write_num(k);
#line 492
    save_column(i, k);
#line 479
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 495
  if (! rflag) {
#line 495
    outline += 2;
  }
  {
#line 496
  end_num_array();
#line 497
  free((void *)((char *)state_count));
  }
#line 498
  return;
}
}
#line 501 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static int default_goto(int symbol ) 
{ 
  register int i ;
  register int m ;
  register int n ;
  register int default_state ;
  register int max ;

  {
#line 513
  m = (int )*(goto_map + symbol);
#line 514
  n = (int )*(goto_map + (symbol + 1));
#line 516
  if (m == n) {
#line 516
    return (0);
  }
#line 518
  i = 0;
  {
#line 518
  while (1) {
    while_continue: /* CIL Label */ ;
#line 518
    if (! (i < nstates)) {
#line 518
      goto while_break;
    }
#line 519
    *(state_count + i) = (short)0;
#line 518
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 521
  i = m;
  {
#line 521
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 521
    if (! (i < n)) {
#line 521
      goto while_break___0;
    }
#line 522
    *(state_count + *(to_state + i)) = (short )((int )*(state_count + *(to_state + i)) + 1);
#line 521
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 524
  max = 0;
#line 525
  default_state = 0;
#line 526
  i = 0;
  {
#line 526
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 526
    if (! (i < nstates)) {
#line 526
      goto while_break___1;
    }
#line 528
    if ((int )*(state_count + i) > max) {
#line 530
      max = (int )*(state_count + i);
#line 531
      default_state = i;
    }
#line 526
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 535
  return (default_state);
}
}
#line 540 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void save_column(int symbol , int default_state ) 
{ 
  register int i ;
  register int m ;
  register int n ;
  register short *sp ;
  register short *sp1 ;
  register short *sp2 ;
  register int count ;
  register int symno ;
  char *tmp ;
  char *tmp___0 ;
  short *tmp___1 ;
  short *tmp___2 ;

  {
#line 556
  m = (int )*(goto_map + symbol);
#line 557
  n = (int )*(goto_map + (symbol + 1));
#line 559
  count = 0;
#line 560
  i = m;
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 560
    if (! (i < n)) {
#line 560
      goto while_break;
    }
#line 562
    if ((int )*(to_state + i) != default_state) {
#line 563
      count ++;
    }
#line 560
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 565
  if (count == 0) {
#line 565
    return;
  }
  {
#line 567
  symno = (int )*(symbol_value + symbol) + 2 * nstates;
#line 569
  tmp = allocate((unsigned int )((unsigned long )count * sizeof(short )));
#line 569
  sp = (short *)tmp;
#line 569
  sp1 = sp;
#line 569
  *(froms + symno) = sp1;
#line 570
  tmp___0 = allocate((unsigned int )((unsigned long )count * sizeof(short )));
#line 570
  sp2 = (short *)tmp___0;
#line 570
  *(tos + symno) = sp2;
#line 572
  i = m;
  }
  {
#line 572
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 572
    if (! (i < n)) {
#line 572
      goto while_break___0;
    }
#line 574
    if ((int )*(to_state + i) != default_state) {
#line 576
      tmp___1 = sp1;
#line 576
      sp1 ++;
#line 576
      *tmp___1 = *(from_state + i);
#line 577
      tmp___2 = sp2;
#line 577
      sp2 ++;
#line 577
      *tmp___2 = *(to_state + i);
    }
#line 572
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 581
  *(tally + symno) = (short )count;
#line 582
  *(width + symno) = (short )(((int )*(sp1 + -1) - (int )*(sp + 0)) + 1);
#line 583
  return;
}
}
#line 586 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void sort_actions(void) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register int t ;
  register int w ;
  char *tmp ;

  {
  {
#line 597
  tmp = allocate((unsigned int )((unsigned long )nvectors * sizeof(short )));
#line 597
  order = (short *)tmp;
#line 598
  nentries = 0;
#line 600
  i = 0;
  }
  {
#line 600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 600
    if (! (i < nvectors)) {
#line 600
      goto while_break;
    }
#line 602
    if ((int )*(tally + i) > 0) {
#line 604
      t = (int )*(tally + i);
#line 605
      w = (int )*(width + i);
#line 606
      j = nentries - 1;
      {
#line 608
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 608
        if (j >= 0) {
#line 608
          if (! ((int )*(width + *(order + j)) < w)) {
#line 608
            goto while_break___0;
          }
        } else {
#line 608
          goto while_break___0;
        }
#line 609
        j --;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 611
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 611
        if (j >= 0) {
#line 611
          if ((int )*(width + *(order + j)) == w) {
#line 611
            if (! ((int )*(tally + *(order + j)) < t)) {
#line 611
              goto while_break___1;
            }
          } else {
#line 611
            goto while_break___1;
          }
        } else {
#line 611
          goto while_break___1;
        }
#line 612
        j --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 614
      k = nentries - 1;
      {
#line 614
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 614
        if (! (k > j)) {
#line 614
          goto while_break___2;
        }
#line 615
        *(order + (k + 1)) = *(order + k);
#line 614
        k --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 617
      *(order + (j + 1)) = (short )i;
#line 618
      nentries ++;
    }
#line 600
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  return;
}
}
#line 625 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void pack_table(void) 
{ 
  register int i ;
  register int place ;
  register int state ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 634
  tmp = allocate((unsigned int )((unsigned long )nvectors * sizeof(short )));
#line 634
  base = (short *)tmp;
#line 635
  tmp___0 = allocate((unsigned int )((unsigned long )nentries * sizeof(short )));
#line 635
  pos = (short *)tmp___0;
#line 637
  maxtable = 1000;
#line 638
  tmp___1 = allocate((unsigned int )((unsigned long )maxtable * sizeof(short )));
#line 638
  table = (short *)tmp___1;
#line 639
  tmp___2 = allocate((unsigned int )((unsigned long )maxtable * sizeof(short )));
#line 639
  check = (short *)tmp___2;
#line 641
  lowzero = 0;
#line 642
  high = 0;
#line 644
  i = 0;
  }
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 644
    if (! (i < maxtable)) {
#line 644
      goto while_break;
    }
#line 645
    *(check + i) = (short)-1;
#line 644
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 647
  i = 0;
  {
#line 647
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 647
    if (! (i < nentries)) {
#line 647
      goto while_break___0;
    }
    {
#line 649
    state = matching_vector(i);
    }
#line 651
    if (state < 0) {
      {
#line 652
      place = pack_vector(i);
      }
    } else {
#line 654
      place = (int )*(base + state);
    }
#line 656
    *(pos + i) = (short )place;
#line 657
    *(base + *(order + i)) = (short )place;
#line 647
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 660
  i = 0;
  {
#line 660
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 660
    if (! (i < nvectors)) {
#line 660
      goto while_break___1;
    }
#line 662
    if (*(froms + i)) {
      {
#line 663
      free((void *)((char *)*(froms + i)));
      }
    }
#line 664
    if (*(tos + i)) {
      {
#line 665
      free((void *)((char *)*(tos + i)));
      }
    }
#line 660
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 668
  free((void *)((char *)froms));
#line 669
  free((void *)((char *)tos));
#line 670
  free((void *)((char *)pos));
  }
#line 671
  return;
}
}
#line 691 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static int matching_vector(int vector ) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register int t ;
  register int w ;
  register int match ;
  register int prev ;

  {
#line 705
  i = (int )*(order + vector);
#line 706
  if (i >= 2 * nstates) {
#line 707
    return (-1);
  }
#line 709
  t = (int )*(tally + i);
#line 710
  w = (int )*(width + i);
#line 712
  prev = vector - 1;
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
#line 712
    if (! (prev >= 0)) {
#line 712
      goto while_break;
    }
#line 714
    j = (int )*(order + prev);
#line 715
    if ((int )*(width + j) != w) {
#line 716
      return (-1);
    } else
#line 715
    if ((int )*(tally + j) != t) {
#line 716
      return (-1);
    }
#line 718
    match = 1;
#line 719
    k = 0;
    {
#line 719
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 719
      if (match) {
#line 719
        if (! (k < t)) {
#line 719
          goto while_break___0;
        }
      } else {
#line 719
        goto while_break___0;
      }
#line 721
      if ((int )*(*(tos + j) + k) != (int )*(*(tos + i) + k)) {
#line 722
        match = 0;
      } else
#line 721
      if ((int )*(*(froms + j) + k) != (int )*(*(froms + i) + k)) {
#line 722
        match = 0;
      }
#line 719
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 725
    if (match) {
#line 726
      return (j);
    }
#line 712
    prev --;
  }
  while_break: /* CIL Label */ ;
  }
#line 729
  return (-1);
}
}
#line 735 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static int pack_vector(int vector ) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register int l ;
  register int t ;
  register int loc ;
  register int ok ;
  register short *from ;
  register short *to ;
  int newmax ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 749
  i = (int )*(order + vector);
#line 750
  t = (int )*(tally + i);
#line 751
  if (! t) {
    {
#line 751
    __assert_fail("t", "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c", 751U,
                  "pack_vector");
    }
  }
#line 753
  from = *(froms + i);
#line 754
  to = *(tos + i);
#line 756
  j = lowzero - (int )*(from + 0);
#line 757
  k = 1;
  {
#line 757
  while (1) {
    while_continue: /* CIL Label */ ;
#line 757
    if (! (k < t)) {
#line 757
      goto while_break;
    }
#line 758
    if (lowzero - (int )*(from + k) > j) {
#line 759
      j = lowzero - (int )*(from + k);
    }
#line 757
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 760
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 762
    if (j == 0) {
#line 763
      goto __Cont;
    }
#line 764
    ok = 1;
#line 765
    k = 0;
    {
#line 765
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 765
      if (ok) {
#line 765
        if (! (k < t)) {
#line 765
          goto while_break___1;
        }
      } else {
#line 765
        goto while_break___1;
      }
#line 767
      loc = j + (int )*(from + k);
#line 768
      if (loc >= maxtable) {
#line 770
        if (loc >= 32500) {
          {
#line 771
          fatal((char *)"maximum table size exceeded");
          }
        }
#line 773
        newmax = maxtable;
        {
#line 774
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 774
          newmax += 200;
#line 774
          if (! (newmax <= loc)) {
#line 774
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 775
        tmp = my_realloc((char *)table, (unsigned int )((unsigned long )newmax * sizeof(short )));
#line 775
        table = (short *)tmp;
#line 776
        tmp___0 = my_realloc((char *)check, (unsigned int )((unsigned long )newmax * sizeof(short )));
#line 776
        check = (short *)tmp___0;
#line 777
        l = maxtable;
        }
        {
#line 777
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 777
          if (! (l < newmax)) {
#line 777
            goto while_break___3;
          }
#line 779
          *(table + l) = (short)0;
#line 780
          *(check + l) = (short)-1;
#line 777
          l ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 782
        maxtable = newmax;
      }
#line 785
      if ((int )*(check + loc) != -1) {
#line 786
        ok = 0;
      }
#line 765
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 788
    k = 0;
    {
#line 788
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 788
      if (ok) {
#line 788
        if (! (k < vector)) {
#line 788
          goto while_break___4;
        }
      } else {
#line 788
        goto while_break___4;
      }
#line 790
      if ((int )*(pos + k) == j) {
#line 791
        ok = 0;
      }
#line 788
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 793
    if (ok) {
#line 795
      k = 0;
      {
#line 795
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 795
        if (! (k < t)) {
#line 795
          goto while_break___5;
        }
#line 797
        loc = j + (int )*(from + k);
#line 798
        *(table + loc) = *(to + k);
#line 799
        *(check + loc) = *(from + k);
#line 800
        if (loc > high) {
#line 800
          high = loc;
        }
#line 795
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 803
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 803
        if (! ((int )*(check + lowzero) != -1)) {
#line 803
          goto while_break___6;
        }
#line 804
        lowzero ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 806
      return (j);
    }
    __Cont: /* CIL Label */ 
#line 760
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 814 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void output_base(void) 
{ 
  register int i ;
  register int j ;

  {
  {
#line 821
  start_num_array((char *)"sindex", 39, (int )*(base + 0));
#line 823
  j = 10;
#line 824
  i = 1;
  }
  {
#line 824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 824
    if (! (i < nstates)) {
#line 824
      goto while_break;
    }
#line 826
    if (j >= 10) {
#line 828
      if (! rflag) {
#line 828
        outline ++;
      }
      {
#line 829
      _IO_putc('\n', output_file);
#line 830
      j = 1;
      }
    } else {
#line 833
      j ++;
    }
    {
#line 835
    write_num((int )*(base + i));
#line 824
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  if (! rflag) {
#line 838
    outline += 2;
  }
  {
#line 839
  end_num_array();
#line 841
  start_num_array((char *)"rindex", 39, (int )*(base + nstates));
#line 843
  j = 10;
#line 844
  i = nstates + 1;
  }
  {
#line 844
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 844
    if (! (i < 2 * nstates)) {
#line 844
      goto while_break___0;
    }
#line 846
    if (j >= 10) {
#line 848
      if (! rflag) {
#line 848
        outline ++;
      }
      {
#line 849
      _IO_putc('\n', output_file);
#line 850
      j = 1;
      }
    } else {
#line 853
      j ++;
    }
    {
#line 855
    write_num((int )*(base + i));
#line 844
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 858
  if (! rflag) {
#line 858
    outline += 2;
  }
  {
#line 859
  end_num_array();
#line 861
  start_num_array((char *)"gindex", 39, (int )*(base + 2 * nstates));
#line 863
  j = 10;
#line 864
  i = 2 * nstates + 1;
  }
  {
#line 864
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 864
    if (! (i < nvectors - 1)) {
#line 864
      goto while_break___1;
    }
#line 866
    if (j >= 10) {
#line 868
      if (! rflag) {
#line 868
        outline ++;
      }
      {
#line 869
      _IO_putc('\n', output_file);
#line 870
      j = 1;
      }
    } else {
#line 873
      j ++;
    }
    {
#line 875
    write_num((int )*(base + i));
#line 864
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 878
  if (! rflag) {
#line 878
    outline += 2;
  }
  {
#line 879
  end_num_array();
#line 880
  free((void *)((char *)base));
  }
#line 881
  return;
}
}
#line 886 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void output_table(void) 
{ 
  register int i ;
  register int j ;

  {
  {
#line 894
  outline ++;
#line 895
  write_define((char *)"TABLESIZE", high);
#line 896
  start_num_array((char *)"table", 40, (int )*(table + 0));
#line 898
  j = 10;
#line 899
  i = 1;
  }
  {
#line 899
  while (1) {
    while_continue: /* CIL Label */ ;
#line 899
    if (! (i <= high)) {
#line 899
      goto while_break;
    }
#line 901
    if (j >= 10) {
#line 903
      if (! rflag) {
#line 903
        outline ++;
      }
      {
#line 904
      _IO_putc('\n', output_file);
#line 905
      j = 1;
      }
    } else {
#line 908
      j ++;
    }
    {
#line 910
    write_num((int )*(table + i));
#line 899
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 913
  if (! rflag) {
#line 913
    outline += 2;
  }
  {
#line 914
  end_num_array();
#line 915
  free((void *)((char *)table));
  }
#line 916
  return;
}
}
#line 921 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void output_check(void) 
{ 
  register int i ;
  register int j ;

  {
  {
#line 929
  start_num_array((char *)"check", 40, (int )*(check + 0));
#line 931
  j = 10;
#line 932
  i = 1;
  }
  {
#line 932
  while (1) {
    while_continue: /* CIL Label */ ;
#line 932
    if (! (i <= high)) {
#line 932
      goto while_break;
    }
#line 934
    if (j >= 10) {
#line 936
      if (! rflag) {
#line 936
        outline ++;
      }
      {
#line 937
      _IO_putc('\n', output_file);
#line 938
      j = 1;
      }
    } else {
#line 941
      j ++;
    }
    {
#line 943
    write_num((int )*(check + i));
#line 932
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 946
  if (! rflag) {
#line 946
    outline += 2;
  }
  {
#line 947
  end_num_array();
#line 948
  free((void *)((char *)check));
  }
#line 949
  return;
}
}
#line 953 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static int is_C_identifier(char *name ) 
{ 
  register char *s ;
  register int c ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 962
  s = name;
#line 963
  c = (int )*s;
#line 964
  if (c == 34) {
    {
#line 966
    s ++;
#line 966
    c = (int )*s;
#line 967
    tmp = __ctype_b_loc();
    }
#line 967
    if ((int const   )*(*tmp + c) & 1024) {
      _L___0: /* CIL Label */ 
#line 969
      if ((unsigned int )language == 1U) {
#line 969
        if (c == 36) {
#line 970
          return (0);
        }
      }
    } else
#line 967
    if (c != 95) {
#line 967
      if (c != 36) {
#line 968
        return (0);
      } else {
#line 967
        goto _L___0;
      }
    } else {
#line 967
      goto _L___0;
    }
    {
#line 971
    while (1) {
      while_continue: /* CIL Label */ ;
#line 971
      s ++;
#line 971
      c = (int )*s;
#line 971
      if (! (c != 34)) {
#line 971
        goto while_break;
      }
      {
#line 973
      tmp___0 = __ctype_b_loc();
      }
#line 973
      if ((int const   )*(*tmp___0 + c) & 8) {
        _L___2: /* CIL Label */ 
#line 975
        if ((unsigned int )language == 1U) {
#line 975
          if (c == 36) {
#line 976
            return (0);
          }
        }
      } else
#line 973
      if (c != 95) {
#line 973
        if (c != 36) {
#line 974
          return (0);
        } else {
#line 973
          goto _L___2;
        }
      } else {
#line 973
        goto _L___2;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 978
    return (1);
  }
  {
#line 981
  tmp___1 = __ctype_b_loc();
  }
#line 981
  if ((int const   )*(*tmp___1 + c) & 1024) {
    _L___4: /* CIL Label */ 
#line 983
    if ((unsigned int )language == 1U) {
#line 983
      if (c == 36) {
#line 984
        return (0);
      }
    }
  } else
#line 981
  if (c != 95) {
#line 981
    if (c != 36) {
#line 982
      return (0);
    } else {
#line 981
      goto _L___4;
    }
  } else {
#line 981
    goto _L___4;
  }
  {
#line 985
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 985
    s ++;
#line 985
    c = (int )*s;
#line 985
    if (! c) {
#line 985
      goto while_break___0;
    }
    {
#line 987
    tmp___2 = __ctype_b_loc();
    }
#line 987
    if ((int const   )*(*tmp___2 + c) & 8) {
      _L___6: /* CIL Label */ 
#line 989
      if ((unsigned int )language == 1U) {
#line 989
        if (c == 36) {
#line 990
          return (0);
        }
      }
    } else
#line 987
    if (c != 95) {
#line 987
      if (c != 36) {
#line 988
        return (0);
      } else {
#line 987
        goto _L___6;
      }
    } else {
#line 987
      goto _L___6;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 992
  return (1);
}
}
#line 997 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void output_defines(void) 
{ 
  register int c ;
  register int i ;
  register char *s ;
  int tmp ;

  {
#line 1005
  i = 2;
  {
#line 1005
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1005
    if (! (i < ntokens)) {
#line 1005
      goto while_break;
    }
    {
#line 1007
    s = *(symbol_name + i);
#line 1008
    tmp = is_C_identifier(s);
    }
#line 1008
    if (tmp) {
      {
#line 1010
      start_define(code_file);
      }
#line 1011
      if (dflag) {
        {
#line 1012
        start_define(defines_file);
        }
      }
#line 1013
      c = (int )*s;
#line 1014
      if (c == 34) {
        {
#line 1016
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1016
          s ++;
#line 1016
          c = (int )*s;
#line 1016
          if (! (c != 34)) {
#line 1016
            goto while_break___0;
          }
          {
#line 1018
          _IO_putc(c, code_file);
          }
#line 1019
          if (dflag) {
            {
#line 1019
            _IO_putc(c, defines_file);
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 1024
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1026
          _IO_putc(c, code_file);
          }
#line 1027
          if (dflag) {
            {
#line 1027
            _IO_putc(c, defines_file);
            }
          }
#line 1024
          s ++;
#line 1024
          c = (int )*s;
#line 1024
          if (! c) {
#line 1024
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 1031
      outline ++;
#line 1032
      end_define(code_file, (int )*(symbol_value + i));
      }
#line 1033
      if (dflag) {
        {
#line 1034
        end_define(defines_file, (int )*(symbol_value + i));
        }
      }
    }
#line 1005
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1038
  outline ++;
#line 1039
  write_define((char *)"ERRCODE", (int )*(symbol_value + 1));
  }
#line 1041
  if (dflag) {
#line 1041
    if (unionized) {
#line 1041
      if ((unsigned int )language == 0U) {
        {
#line 1043
        fclose(union_file);
#line 1044
        union_file = fopen((char const   */* __restrict  */)union_file_name, (char const   */* __restrict  */)"r");
        }
#line 1045
        if ((unsigned long )union_file == (unsigned long )((void *)0)) {
          {
#line 1045
          open_error(union_file_name);
          }
        }
        {
#line 1046
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 1046
          c = _IO_getc(union_file);
          }
#line 1046
          if (! (c != -1)) {
#line 1046
            goto while_break___2;
          }
          {
#line 1047
          _IO_putc(c, defines_file);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1048
        fprintf((FILE */* __restrict  */)defines_file, (char const   */* __restrict  */)" %sSTYPE;\nextern %sSTYPE %slval;\n",
                define_prefix, define_prefix, symbol_prefix);
        }
      }
    }
  }
#line 1051
  return;
}
}
#line 1055 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void output_stored_text(void) 
{ 
  register int c ;
  register FILE *in ;
  register FILE *out ;

  {
  {
#line 1063
  fclose(text_file);
#line 1064
  text_file = fopen((char const   */* __restrict  */)text_file_name, (char const   */* __restrict  */)"r");
  }
#line 1065
  if ((unsigned long )text_file == (unsigned long )((void *)0)) {
    {
#line 1066
    open_error(text_file_name);
    }
  }
  {
#line 1067
  in = text_file;
#line 1068
  c = _IO_getc(in);
  }
#line 1068
  if (c == -1) {
#line 1069
    return;
  }
#line 1070
  out = code_file;
#line 1071
  if (c == 10) {
#line 1072
    outline ++;
  }
  {
#line 1073
  _IO_putc(c, out);
  }
  {
#line 1074
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1074
    c = _IO_getc(in);
    }
#line 1074
    if (! (c != -1)) {
#line 1074
      goto while_break;
    }
#line 1076
    if (c == 10) {
#line 1077
      outline ++;
    }
    {
#line 1078
    _IO_putc(c, out);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1080
  if (! lflag) {
    {
#line 1081
    outline ++;
#line 1081
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)(line_format),
            outline + 1, code_file_name);
    }
  }
#line 1082
  return;
}
}
#line 1086 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void output_debug(void) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register int max ;
  char **symnam ;
  char *s ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 1094
  outline ++;
#line 1095
  write_define((char *)"FINAL", (int )final_state);
#line 1096
  outline += 3;
#line 1097
  fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"#ifndef %sDEBUG\n#define %sDEBUG %d\n#endif\n",
          define_prefix, define_prefix, (int )tflag);
  }
#line 1099
  if (rflag) {
    {
#line 1100
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"#ifndef %sDEBUG\n#define %sDEBUG %d\n#endif\n",
            define_prefix, define_prefix, (int )tflag);
    }
  }
#line 1103
  max = 0;
#line 1104
  i = 2;
  {
#line 1104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1104
    if (! (i < ntokens)) {
#line 1104
      goto while_break;
    }
#line 1105
    if ((int )*(symbol_value + i) > max) {
#line 1106
      max = (int )*(symbol_value + i);
    }
#line 1104
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1107
  outline ++;
#line 1108
  write_define((char *)"MAXTOKEN", max);
#line 1110
  tmp = my_malloc((unsigned int )((unsigned long )(max + 1) * sizeof(char *)));
#line 1110
  symnam = (char **)tmp;
#line 1114
  i = 0;
  }
  {
#line 1114
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1114
    if (! (i < max)) {
#line 1114
      goto while_break___0;
    }
#line 1115
    *(symnam + i) = (char *)0;
#line 1114
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1116
  i = ntokens - 1;
  {
#line 1116
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1116
    if (! (i >= 2)) {
#line 1116
      goto while_break___1;
    }
#line 1117
    *(symnam + *(symbol_value + i)) = *(symbol_name + i);
#line 1116
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1118
  *(symnam + 0) = (char *)"end-of-file";
#line 1120
  if (! rflag) {
#line 1120
    outline ++;
  }
  {
#line 1121
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"#if %sDEBUG\n",
          define_prefix);
#line 1122
  start_string_array((char *)"name", 0);
#line 1123
  j = 80;
#line 1124
  i = 0;
  }
  {
#line 1124
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1124
    if (! (i <= max)) {
#line 1124
      goto while_break___2;
    }
#line 1126
    s = *(symnam + i);
#line 1126
    if (s) {
#line 1128
      if ((int )*(s + 0) == 34) {
#line 1130
        k = 7;
        {
#line 1131
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1131
          s ++;
#line 1131
          if (! ((int )*s != 34)) {
#line 1131
            goto while_break___3;
          }
#line 1133
          k ++;
#line 1134
          if ((int )*s == 92) {
#line 1136
            k += 2;
#line 1137
            s ++;
#line 1137
            if ((int )*s == 92) {
#line 1138
              k ++;
            }
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1141
        j += k;
#line 1142
        if (j > 80) {
#line 1144
          if (! rflag) {
#line 1144
            outline ++;
          }
          {
#line 1145
          _IO_putc('\n', output_file);
#line 1146
          j = k;
          }
        }
        {
#line 1148
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\"\\\"");
#line 1149
        s = *(symnam + i);
        }
        {
#line 1150
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1150
          s ++;
#line 1150
          if (! ((int )*s != 34)) {
#line 1150
            goto while_break___4;
          }
#line 1152
          if ((int )*s == 92) {
            {
#line 1154
            fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\\");
#line 1155
            s ++;
            }
#line 1155
            if ((int )*s == 92) {
              {
#line 1156
              fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\\");
              }
            } else {
              {
#line 1158
              _IO_putc((int )*s, output_file);
              }
            }
          } else {
            {
#line 1161
            _IO_putc((int )*s, output_file);
            }
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 1163
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\"\",");
        }
      } else
#line 1165
      if ((int )*(s + 0) == 39) {
#line 1167
        if ((int )*(s + 1) == 34) {
#line 1169
          j += 7;
#line 1170
          if (j > 80) {
#line 1172
            if (! rflag) {
#line 1172
              outline ++;
            }
            {
#line 1173
            _IO_putc('\n', output_file);
#line 1174
            j = 7;
            }
          }
          {
#line 1176
          fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\"\'\\\"\'\",");
          }
        } else {
#line 1180
          k = 5;
          {
#line 1181
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1181
            s ++;
#line 1181
            if (! ((int )*s != 39)) {
#line 1181
              goto while_break___5;
            }
#line 1183
            k ++;
#line 1184
            if ((int )*s == 92) {
#line 1186
              k += 2;
#line 1187
              s ++;
#line 1187
              if ((int )*s == 92) {
#line 1188
                k ++;
              }
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1191
          j += k;
#line 1192
          if (j > 80) {
#line 1194
            if (! rflag) {
#line 1194
              outline ++;
            }
            {
#line 1195
            _IO_putc('\n', output_file);
#line 1196
            j = k;
            }
          }
          {
#line 1198
          fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\"\'");
#line 1199
          s = *(symnam + i);
          }
          {
#line 1200
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1200
            s ++;
#line 1200
            if (! ((int )*s != 39)) {
#line 1200
              goto while_break___6;
            }
#line 1202
            if ((int )*s == 92) {
              {
#line 1204
              fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\\");
#line 1205
              s ++;
              }
#line 1205
              if ((int )*s == 92) {
                {
#line 1206
                fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\\");
                }
              } else {
                {
#line 1208
                _IO_putc((int )*s, output_file);
                }
              }
            } else {
              {
#line 1211
              _IO_putc((int )*s, output_file);
              }
            }
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 1213
          fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\'\",");
          }
        }
      } else {
        {
#line 1218
        tmp___0 = strlen((char const   *)s);
#line 1218
        k = (int )(tmp___0 + 3UL);
#line 1219
        j += k;
        }
#line 1220
        if (j > 80) {
#line 1222
          if (! rflag) {
#line 1222
            outline ++;
          }
          {
#line 1223
          _IO_putc('\n', output_file);
#line 1224
          j = k;
          }
        }
        {
#line 1226
        _IO_putc('\"', output_file);
        }
        {
#line 1227
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 1227
          _IO_putc((int )*s, output_file);
#line 1227
          s ++;
          }
#line 1227
          if (! *s) {
#line 1227
            goto while_break___7;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 1228
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\",");
        }
      }
    } else {
#line 1233
      j += 2;
#line 1234
      if (j > 80) {
#line 1236
        if (! rflag) {
#line 1236
          outline ++;
        }
        {
#line 1237
        _IO_putc('\n', output_file);
#line 1238
        j = 2;
        }
      }
      {
#line 1240
      write_null();
      }
    }
#line 1124
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1243
  if (! rflag) {
#line 1243
    outline += 2;
  }
  {
#line 1244
  end_string_array(1);
#line 1245
  free((void *)((char *)symnam));
  }
#line 1247
  if (! rflag) {
#line 1247
    outline ++;
  }
  {
#line 1248
  start_string_array((char *)"rule", 1);
#line 1249
  i = 2;
  }
  {
#line 1249
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1249
    if (! (i < nrules)) {
#line 1249
      goto while_break___8;
    }
#line 1251
    if ((unsigned int )language == 1U) {
#line 1251
      if ((int )*(*(symbol_name + *(rlhs + i)) + 0) == 36) {
        {
#line 1252
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\"\\%s :",
                *(symbol_name + *(rlhs + i)));
        }
      } else {
        {
#line 1254
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\"%s :",
                *(symbol_name + *(rlhs + i)));
        }
      }
    } else {
      {
#line 1254
      fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\"%s :",
              *(symbol_name + *(rlhs + i)));
      }
    }
#line 1255
    j = (int )*(rrhs + i);
    {
#line 1255
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1255
      if (! ((int )*(ritem + j) > 0)) {
#line 1255
        goto while_break___9;
      }
#line 1257
      s = *(symbol_name + *(ritem + j));
#line 1258
      if ((int )*(s + 0) == 34) {
        {
#line 1260
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)" \\\"");
        }
        {
#line 1261
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 1261
          s ++;
#line 1261
          if (! ((int )*s != 34)) {
#line 1261
            goto while_break___10;
          }
#line 1263
          if ((int )*s == 92) {
#line 1265
            if ((int )*(s + 1) == 92) {
              {
#line 1266
              fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\\\\\\");
              }
            } else {
              {
#line 1268
              fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\\%c",
                      (int )*(s + 1));
              }
            }
#line 1269
            s ++;
          } else {
            {
#line 1272
            _IO_putc((int )*s, output_file);
            }
          }
        }
        while_break___10: /* CIL Label */ ;
        }
        {
#line 1274
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\"");
        }
      } else
#line 1276
      if ((int )*(s + 0) == 39) {
#line 1278
        if ((int )*(s + 1) == 34) {
          {
#line 1279
          fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)" \'\\\"\'");
          }
        } else
#line 1280
        if ((int )*(s + 1) == 92) {
#line 1282
          if ((int )*(s + 2) == 92) {
            {
#line 1283
            fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)" \'\\\\\\\\");
            }
          } else {
            {
#line 1285
            fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)" \'\\\\%c",
                    (int )*(s + 2));
            }
          }
#line 1286
          s += 2;
          {
#line 1287
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 1287
            s ++;
#line 1287
            if (! ((int )*s != 39)) {
#line 1287
              goto while_break___11;
            }
            {
#line 1288
            _IO_putc((int )*s, output_file);
            }
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 1289
          _IO_putc('\'', output_file);
          }
        } else {
          {
#line 1292
          fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)" \'%c\'",
                  (int )*(s + 1));
          }
        }
      } else {
        {
#line 1295
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)" %s",
                s);
        }
      }
#line 1255
      j ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 1297
    if (! rflag) {
#line 1297
      outline ++;
    }
    {
#line 1298
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\",\n");
#line 1249
    i ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 1301
  if (! rflag) {
#line 1301
    outline += 2;
  }
  {
#line 1302
  end_string_array(0);
#line 1303
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"#endif\n");
  }
#line 1304
  return;
}
}
#line 1308 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void output_stype(void) 
{ 


  {
#line 1313
  if (! unionized) {
#line 1313
    if (ntags == 0) {
#line 1313
      if ((unsigned int )language == 0U) {
        {
#line 1315
        outline += 3;
#line 1316
        fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"#ifndef %sSTYPE\ntypedef int %sSTYPE;\n#endif\n",
                define_prefix, define_prefix);
        }
      }
    }
  }
#line 1319
  return;
}
}
#line 1323 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void output_trailing_text(void) 
{ 
  register int c ;
  register int last ;
  register FILE *in ;
  register FILE *out ;

  {
#line 1331
  if ((unsigned long )line == (unsigned long )((char *)0)) {
#line 1332
    return;
  }
#line 1334
  in = input_file;
#line 1335
  out = code_file;
#line 1336
  c = (int )*cptr;
#line 1337
  if (c == 10) {
    {
#line 1339
    lineno ++;
#line 1340
    c = _IO_getc(in);
    }
#line 1340
    if (c == -1) {
#line 1341
      return;
    }
#line 1342
    if (! lflag) {
      {
#line 1344
      outline ++;
#line 1345
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)(line_format),
              lineno, input_file_name);
      }
    }
#line 1347
    if (c == 10) {
#line 1348
      outline ++;
    }
    {
#line 1349
    _IO_putc(c, out);
#line 1350
    last = c;
    }
  } else {
#line 1354
    if (! lflag) {
      {
#line 1356
      outline ++;
#line 1357
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)(line_format),
              lineno, input_file_name);
      }
    }
    {
#line 1359
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1359
      _IO_putc(c, out);
#line 1359
      cptr ++;
#line 1359
      c = (int )*cptr;
      }
#line 1359
      if (! (c != 10)) {
#line 1359
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1360
    outline ++;
#line 1361
    _IO_putc('\n', out);
#line 1362
    last = '\n';
    }
  }
  {
#line 1365
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1365
    c = _IO_getc(in);
    }
#line 1365
    if (! (c != -1)) {
#line 1365
      goto while_break___0;
    }
#line 1367
    if (c == 10) {
#line 1368
      outline ++;
    }
    {
#line 1369
    _IO_putc(c, out);
#line 1370
    last = c;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1373
  if (last != 10) {
    {
#line 1375
    outline ++;
#line 1376
    _IO_putc('\n', out);
    }
  }
#line 1378
  if (! lflag) {
    {
#line 1379
    outline ++;
#line 1379
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)(line_format),
            outline + 1, code_file_name);
    }
  }
#line 1380
  return;
}
}
#line 1384 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void output_semantic_actions(void) 
{ 
  register int c ;
  register int last ;
  register FILE *out ;

  {
  {
#line 1392
  fclose(action_file);
#line 1393
  action_file = fopen((char const   */* __restrict  */)action_file_name, (char const   */* __restrict  */)"r");
  }
#line 1394
  if ((unsigned long )action_file == (unsigned long )((void *)0)) {
    {
#line 1395
    open_error(action_file_name);
    }
  }
  {
#line 1397
  c = _IO_getc(action_file);
  }
#line 1397
  if (c == -1) {
#line 1398
    return;
  }
#line 1400
  out = code_file;
#line 1401
  last = c;
#line 1402
  if (c == 10) {
#line 1403
    outline ++;
  }
  {
#line 1404
  _IO_putc(c, out);
  }
  {
#line 1405
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1405
    c = _IO_getc(action_file);
    }
#line 1405
    if (! (c != -1)) {
#line 1405
      goto while_break;
    }
#line 1407
    if (c == 10) {
#line 1408
      outline ++;
    }
    {
#line 1409
    _IO_putc(c, out);
#line 1410
    last = c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1413
  if (last != 10) {
    {
#line 1415
    outline ++;
#line 1416
    _IO_putc('\n', out);
    }
  }
#line 1419
  if (! lflag) {
    {
#line 1420
    outline ++;
#line 1420
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)(line_format),
            outline + 1, code_file_name);
    }
  }
#line 1421
  return;
}
}
#line 1425 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void free_itemsets(void) 
{ 
  register core *cp ;
  register core *next ;

  {
  {
#line 1432
  free((void *)((char *)state_table));
#line 1433
  cp = first_state;
  }
  {
#line 1433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1433
    if (! cp) {
#line 1433
      goto while_break;
    }
    {
#line 1435
    next = cp->next;
#line 1436
    free((void *)((char *)cp));
#line 1433
    cp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1438
  return;
}
}
#line 1442 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void free_shifts(void) 
{ 
  register shifts *sp ;
  register shifts *next ;

  {
  {
#line 1449
  free((void *)((char *)shift_table));
#line 1450
  sp = first_shift;
  }
  {
#line 1450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1450
    if (! sp) {
#line 1450
      goto while_break;
    }
    {
#line 1452
    next = sp->next;
#line 1453
    free((void *)((char *)sp));
#line 1450
    sp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1455
  return;
}
}
#line 1460 "/home/wheatley/newnew/temp/perl-byacc-2.0/output.c"
static void free_reductions(void) 
{ 
  register reductions *rp ;
  register reductions *next ;

  {
  {
#line 1467
  free((void *)((char *)reduction_table));
#line 1468
  rp = first_reduction;
  }
  {
#line 1468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1468
    if (! rp) {
#line 1468
      goto while_break;
    }
    {
#line 1470
    next = rp->next;
#line 1471
    free((void *)((char *)rp));
#line 1468
    rp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1473
  return;
}
}
#line 3 "/home/wheatley/newnew/temp/perl-byacc-2.0/closure.c"
short *itemset  ;
#line 4 "/home/wheatley/newnew/temp/perl-byacc-2.0/closure.c"
short *itemsetend  ;
#line 5 "/home/wheatley/newnew/temp/perl-byacc-2.0/closure.c"
unsigned int *ruleset  ;
#line 7 "/home/wheatley/newnew/temp/perl-byacc-2.0/closure.c"
static unsigned int *first_derives  ;
#line 8 "/home/wheatley/newnew/temp/perl-byacc-2.0/closure.c"
static unsigned int *EFF  ;
#line 12 "/home/wheatley/newnew/temp/perl-byacc-2.0/closure.c"
static void set_EFF(void) 
{ 
  register unsigned int *row ;
  register int symbol ;
  register short *sp ;
  register int rowsize ;
  register int i ;
  register int rule ;
  char *tmp ;

  {
  {
#line 24
  rowsize = (nvars + 31) / 32;
#line 25
  tmp = allocate((unsigned int )((unsigned long )(nvars * rowsize) * sizeof(unsigned int )));
#line 25
  EFF = (unsigned int *)tmp;
#line 27
  row = EFF;
#line 28
  i = start_symbol;
  }
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! (i < nsyms)) {
#line 28
      goto while_break;
    }
#line 30
    sp = *(derives + i);
#line 31
    rule = (int )*sp;
    {
#line 31
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 31
      if (! (rule > 0)) {
#line 31
        goto while_break___0;
      }
#line 33
      symbol = (int )*(ritem + *(rrhs + rule));
#line 34
      if (symbol >= start_symbol) {
#line 36
        symbol -= start_symbol;
#line 37
        *(row + (symbol >> 5)) |= 1U << (symbol & 31);
      }
#line 31
      sp ++;
#line 31
      rule = (int )*sp;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 40
    row += rowsize;
#line 28
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 43
  reflexive_transitive_closure(EFF, nvars);
  }
#line 48
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/perl-byacc-2.0/closure.c"
void set_first_derives(void) 
{ 
  register unsigned int *rrow ;
  register unsigned int *vrow ;
  register int j ;
  register unsigned int mask ;
  register unsigned int cword ;
  register short *rp ;
  int rule ;
  int i ;
  int rulesetsize ;
  int varsetsize ;
  char *tmp ;
  unsigned int *tmp___0 ;
  short *tmp___1 ;
  unsigned int *tmp___2 ;

  {
  {
#line 69
  rulesetsize = (nrules + 31) / 32;
#line 70
  varsetsize = (nvars + 31) / 32;
#line 71
  tmp = allocate((unsigned int )((unsigned long )(nvars * rulesetsize) * sizeof(unsigned int )));
#line 71
  first_derives = (unsigned int *)tmp - ntokens * rulesetsize;
#line 73
  set_EFF();
#line 75
  rrow = first_derives + ntokens * rulesetsize;
#line 76
  i = start_symbol;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (i < nsyms)) {
#line 76
      goto while_break;
    }
#line 78
    vrow = EFF + (i - ntokens) * varsetsize;
#line 79
    tmp___0 = vrow;
#line 79
    vrow ++;
#line 79
    cword = *tmp___0;
#line 80
    mask = 1U;
#line 81
    j = start_symbol;
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 81
      if (! (j < nsyms)) {
#line 81
        goto while_break___0;
      }
#line 83
      if (cword & mask) {
#line 85
        rp = *(derives + j);
        {
#line 86
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 86
          tmp___1 = rp;
#line 86
          rp ++;
#line 86
          rule = (int )*tmp___1;
#line 86
          if (! (rule >= 0)) {
#line 86
            goto while_break___1;
          }
#line 88
          *(rrow + (rule >> 5)) |= 1U << (rule & 31);
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 92
      mask <<= 1;
#line 93
      if (mask == 0U) {
#line 95
        tmp___2 = vrow;
#line 95
        vrow ++;
#line 95
        cword = *tmp___2;
#line 96
        mask = 1U;
      }
#line 81
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 100
    vrow += varsetsize;
#line 101
    rrow += rulesetsize;
#line 76
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  free((void *)((char *)EFF));
  }
#line 109
  return;
}
}
#line 113 "/home/wheatley/newnew/temp/perl-byacc-2.0/closure.c"
void closure(short *nucleus , int n ) 
{ 
  register int ruleno ;
  register unsigned int word ;
  register unsigned int mask ;
  register short *csp ;
  register unsigned int *dsp ;
  register unsigned int *rsp ;
  register int rulesetsize ;
  short *csend ;
  unsigned int *rsend ;
  int symbol ;
  int itemno ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;
  short *tmp___1 ;
  short *tmp___2 ;
  short *tmp___3 ;
  short *tmp___4 ;
  short *tmp___5 ;

  {
#line 133
  rulesetsize = (nrules + 31) / 32;
#line 134
  rsp = ruleset;
#line 135
  rsend = ruleset + rulesetsize;
#line 136
  rsp = ruleset;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! ((unsigned long )rsp < (unsigned long )rsend)) {
#line 136
      goto while_break;
    }
#line 137
    *rsp = 0U;
#line 136
    rsp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  csend = nucleus + n;
#line 140
  csp = nucleus;
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 140
    if (! ((unsigned long )csp < (unsigned long )csend)) {
#line 140
      goto while_break___0;
    }
#line 142
    symbol = (int )*(ritem + *csp);
#line 143
    if (symbol >= start_symbol) {
#line 145
      dsp = first_derives + symbol * rulesetsize;
#line 146
      rsp = ruleset;
      {
#line 147
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 147
        if (! ((unsigned long )rsp < (unsigned long )rsend)) {
#line 147
          goto while_break___1;
        }
#line 148
        tmp = rsp;
#line 148
        rsp ++;
#line 148
        tmp___0 = dsp;
#line 148
        dsp ++;
#line 148
        *tmp |= *tmp___0;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 140
    csp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 152
  ruleno = 0;
#line 153
  itemsetend = itemset;
#line 154
  csp = nucleus;
#line 155
  rsp = ruleset;
  {
#line 155
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 155
    if (! ((unsigned long )rsp < (unsigned long )rsend)) {
#line 155
      goto while_break___2;
    }
#line 157
    word = *rsp;
#line 158
    if (word == 0U) {
#line 159
      ruleno += 32;
    } else {
#line 162
      mask = 1U;
      {
#line 163
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 163
        if (! mask) {
#line 163
          goto while_break___3;
        }
#line 165
        if (word & mask) {
#line 167
          itemno = (int )*(rrhs + ruleno);
          {
#line 168
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 168
            if ((unsigned long )csp < (unsigned long )csend) {
#line 168
              if (! ((int )*csp < itemno)) {
#line 168
                goto while_break___4;
              }
            } else {
#line 168
              goto while_break___4;
            }
#line 169
            tmp___1 = itemsetend;
#line 169
            itemsetend ++;
#line 169
            tmp___2 = csp;
#line 169
            csp ++;
#line 169
            *tmp___1 = *tmp___2;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 170
          tmp___3 = itemsetend;
#line 170
          itemsetend ++;
#line 170
          *tmp___3 = (short )itemno;
          {
#line 171
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 171
            if ((unsigned long )csp < (unsigned long )csend) {
#line 171
              if (! ((int )*csp == itemno)) {
#line 171
                goto while_break___5;
              }
            } else {
#line 171
              goto while_break___5;
            }
#line 172
            csp ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 175
        mask <<= 1;
#line 176
        ruleno ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 155
    rsp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 181
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 181
    if (! ((unsigned long )csp < (unsigned long )csend)) {
#line 181
      goto while_break___6;
    }
#line 182
    tmp___4 = itemsetend;
#line 182
    itemsetend ++;
#line 182
    tmp___5 = csp;
#line 182
    csp ++;
#line 182
    *tmp___4 = *tmp___5;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 187
  return;
}
}
#line 192 "/home/wheatley/newnew/temp/perl-byacc-2.0/closure.c"
void finalize_closure(void) 
{ 


  {
  {
#line 197
  free((void *)((char *)itemset));
#line 198
  free((void *)((char *)ruleset));
#line 199
  free((void *)((char *)(first_derives + ntokens * ((nrules + 31) / 32))));
  }
#line 200
  return;
}
}
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 216 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char *cptr  ;
#line 217 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char *line  ;
#line 255 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
int ntags  ;
#line 257 "/home/wheatley/newnew/temp/perl-byacc-2.0/defs.h"
char unionized  ;
#line 13 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
char *cache  ;
#line 14 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
int cinc  ;
#line 14 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
int cache_size  ;
#line 16 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
int tagmax  ;
#line 17 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
char **tag_table  ;
#line 19 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
char saw_eof  ;
#line 21 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
int linesize  ;
#line 23 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
bucket *goal  ;
#line 24 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
int prec  ;
#line 25 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
int gensym  ;
#line 26 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
char last_was_action  ;
#line 28 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
int maxitems  ;
#line 29 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
bucket **pitem  ;
#line 31 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
int maxrules  ;
#line 32 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
bucket **plhs  ;
#line 34 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
int name_pool_size  ;
#line 35 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
char *name_pool  ;
#line 37 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
char line_format[15]  = 
#line 37
  {      (char )'#',      (char )'l',      (char )'i',      (char )'n', 
        (char )'e',      (char )' ',      (char )'%',      (char )'d', 
        (char )' ',      (char )'\"',      (char )'%',      (char )'s', 
        (char )'\"',      (char )'\n',      (char )'\000'};
#line 43
static void cachec(int c ) ;
#line 44
static void get_line(void) ;
#line 45
static char *dup_line(void) ;
#line 46
static void skip_comment(void) ;
#line 47
static int nextc(void) ;
#line 48
static int keyword(void) ;
#line 49
static void copy_ident(void) ;
#line 50
static void copy_text(void) ;
#line 51
static void perl_comment(FILE *text_file___0 , FILE *other_file ) ;
#line 52
static void copy_union(void) ;
#line 53
static int hexval(int c ) ;
#line 54
static bucket *get_literal(void) ;
#line 55
static int is_reserved(char *name ) ;
#line 56
static bucket *get_name(void) ;
#line 57
static int get_number(void) ;
#line 58
static char *get_tag(void) ;
#line 59
static void declare_tokens(int assoc ) ;
#line 60
static void declare_types(void) ;
#line 61
static void declare_start(void) ;
#line 62
static void read_declarations(void) ;
#line 63
static void initialize_grammar(void) ;
#line 64
static void expand_items(void) ;
#line 65
static void expand_rules(void) ;
#line 66
static void advance_to_start(void) ;
#line 67
static void start_rule(bucket *bp , int s_lineno ) ;
#line 68
static void end_rule(void) ;
#line 69
static void insert_empty_rule(void) ;
#line 70
static void add_symbol(void) ;
#line 71
static void copy_action(void) ;
#line 72
static int mark_symbol(void) ;
#line 73
static void read_grammar(void) ;
#line 74
static void free_tags(void) ;
#line 75
static void pack_names(void) ;
#line 76
static void check_symbols(void) ;
#line 77
static void pack_symbols(void) ;
#line 78
static void pack_grammar(void) ;
#line 79
static void print_grammar(void) ;
#line 83 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void cachec(int c ) 
{ 


  {
#line 89
  if (! (cinc >= 0)) {
    {
#line 89
    __assert_fail("cinc >= 0", "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c",
                  89U, "cachec");
    }
  }
#line 90
  if (cinc >= cache_size) {
    {
#line 92
    cache_size += 256;
#line 93
    cache = my_realloc(cache, (unsigned int )cache_size);
    }
  }
#line 95
  *(cache + cinc) = (char )c;
#line 96
  cinc ++;
#line 97
  return;
}
}
#line 101 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void get_line(void) 
{ 
  register FILE *f ;
  register int c ;
  register int i ;

  {
#line 106
  f = input_file;
#line 110
  if (saw_eof) {
#line 110
    goto _L;
  } else {
    {
#line 110
    c = _IO_getc(f);
    }
#line 110
    if (c == -1) {
      _L: /* CIL Label */ 
#line 112
      if (line) {
        {
#line 112
        free((void *)line);
#line 112
        line = (char *)0;
        }
      }
#line 113
      cptr = (char *)0;
#line 114
      saw_eof = (char)1;
#line 115
      return;
    }
  }
#line 118
  if ((unsigned long )line == (unsigned long )((char *)0)) {
#line 118
    goto _L___0;
  } else
#line 118
  if (linesize != 101) {
    _L___0: /* CIL Label */ 
#line 120
    if (line) {
      {
#line 120
      free((void *)line);
      }
    }
    {
#line 121
    linesize = 101;
#line 122
    line = my_malloc((unsigned int )linesize);
    }
  }
#line 125
  i = 0;
#line 126
  lineno ++;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    *(line + i) = (char )c;
#line 130
    if (c == 10) {
#line 130
      cptr = line;
#line 130
      return;
    }
#line 131
    i ++;
#line 131
    if (i >= linesize) {
      {
#line 133
      linesize += 100;
#line 134
      line = my_realloc(line, (unsigned int )linesize);
      }
    }
    {
#line 136
    c = _IO_getc(f);
    }
#line 137
    if (c == -1) {
#line 139
      *(line + i) = (char )'\n';
#line 140
      saw_eof = (char)1;
#line 141
      cptr = line;
#line 142
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 149 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static char *dup_line(void) 
{ 
  register char *p ;
  register char *s ;
  register char *t ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;

  {
#line 156
  if ((unsigned long )line == (unsigned long )((char *)0)) {
#line 156
    return ((char *)0);
  }
#line 157
  s = line;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! ((int )*s != 10)) {
#line 158
      goto while_break;
    }
#line 158
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 159
  p = my_malloc((unsigned int )((s - line) + 1L));
#line 161
  s = line;
#line 162
  t = p;
  }
  {
#line 163
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 163
    tmp = t;
#line 163
    t ++;
#line 163
    tmp___1 = s;
#line 163
    s ++;
#line 163
    tmp___0 = *tmp___1;
#line 163
    *tmp = tmp___0;
#line 163
    if (! ((int )tmp___0 != 10)) {
#line 163
      goto while_break___0;
    }
#line 163
    goto while_continue___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 164
  return (p);
}
}
#line 169 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void skip_comment(void) 
{ 
  register char *s ;
  int st_lineno ;
  char *st_line ;
  char *tmp ;
  char *st_cptr ;

  {
  {
#line 176
  st_lineno = lineno;
#line 177
  tmp = dup_line();
#line 177
  st_line = tmp;
#line 178
  st_cptr = st_line + (cptr - line);
#line 180
  s = cptr + 2;
  }
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if ((int )*s == 42) {
#line 183
      if ((int )*(s + 1) == 47) {
        {
#line 185
        cptr = s + 2;
#line 186
        free((void *)st_line);
        }
#line 187
        return;
      }
    }
#line 189
    if ((int )*s == 10) {
      {
#line 191
      get_line();
      }
#line 192
      if ((unsigned long )line == (unsigned long )((char *)0)) {
        {
#line 193
        unterminated_comment(st_lineno, st_line, st_cptr);
        }
      }
#line 194
      s = cptr;
    } else {
#line 197
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 203 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static int nextc(void) 
{ 
  register char *s ;

  {
#line 210
  if ((unsigned long )line == (unsigned long )((char *)0)) {
    {
#line 212
    get_line();
    }
#line 213
    if ((unsigned long )line == (unsigned long )((char *)0)) {
#line 214
      return (-1);
    }
  }
#line 217
  s = cptr;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 222
    if ((int )*s == 10) {
#line 222
      goto case_10;
    }
#line 234
    if ((int )*s == 59) {
#line 234
      goto case_59;
    }
#line 234
    if ((int )*s == 44) {
#line 234
      goto case_59;
    }
#line 234
    if ((int )*s == 11) {
#line 234
      goto case_59;
    }
#line 234
    if ((int )*s == 13) {
#line 234
      goto case_59;
    }
#line 234
    if ((int )*s == 12) {
#line 234
      goto case_59;
    }
#line 234
    if ((int )*s == 9) {
#line 234
      goto case_59;
    }
#line 234
    if ((int )*s == 32) {
#line 234
      goto case_59;
    }
#line 238
    if ((int )*s == 92) {
#line 238
      goto case_92;
    }
#line 242
    if ((int )*s == 35) {
#line 242
      goto case_35;
    }
#line 252
    if ((int )*s == 47) {
#line 252
      goto case_47;
    }
#line 270
    goto switch_default;
    case_10: /* CIL Label */ 
    {
#line 223
    get_line();
    }
#line 224
    if ((unsigned long )line == (unsigned long )((char *)0)) {
#line 224
      return (-1);
    }
#line 225
    s = cptr;
#line 226
    goto switch_break;
    case_59: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 235
    s ++;
#line 236
    goto switch_break;
    case_92: /* CIL Label */ 
#line 239
    cptr = s;
#line 240
    return ('%');
    case_35: /* CIL Label */ 
#line 243
    if ((unsigned int )language == 1U) {
      {
#line 244
      get_line();
      }
#line 245
      if ((unsigned long )line == (unsigned long )((char *)0)) {
#line 245
        return (-1);
      }
#line 246
      s = cptr;
#line 247
      goto switch_break;
    }
#line 249
    cptr = s;
#line 250
    return ((int )*s);
    case_47: /* CIL Label */ 
#line 253
    if ((int )*(s + 1) == 42) {
      {
#line 255
      cptr = s;
#line 256
      skip_comment();
#line 257
      s = cptr;
      }
#line 258
      goto switch_break;
    } else
#line 260
    if ((int )*(s + 1) == 47) {
      {
#line 262
      get_line();
      }
#line 263
      if ((unsigned long )line == (unsigned long )((char *)0)) {
#line 263
        return (-1);
      }
#line 264
      s = cptr;
#line 265
      goto switch_break;
    }
#line 267
    cptr = s;
#line 268
    return ((int )*s);
    switch_default: /* CIL Label */ 
#line 271
    cptr = s;
#line 272
    return ((int )*s);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 279 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static int keyword(void) 
{ 
  register int c ;
  char *t_cptr ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned short const   **tmp___12 ;

  {
  {
#line 285
  t_cptr = cptr;
#line 287
  cptr ++;
#line 287
  c = (int )*cptr;
#line 288
  tmp___12 = __ctype_b_loc();
  }
#line 288
  if ((int const   )*(*tmp___12 + c) & 1024) {
#line 290
    cinc = 0;
    {
#line 291
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 293
      tmp___1 = __ctype_b_loc();
      }
#line 293
      if ((int const   )*(*tmp___1 + c) & 1024) {
        {
#line 295
        tmp = __ctype_b_loc();
        }
#line 295
        if ((int const   )*(*tmp + c) & 256) {
          {
#line 295
          c = tolower(c);
          }
        }
        {
#line 296
        cachec(c);
        }
      } else {
        {
#line 298
        tmp___0 = __ctype_b_loc();
        }
#line 298
        if ((int const   )*(*tmp___0 + c) & 2048) {
          {
#line 299
          cachec(c);
          }
        } else
#line 298
        if (c == 95) {
          {
#line 299
          cachec(c);
          }
        } else
#line 298
        if (c == 46) {
          {
#line 299
          cachec(c);
          }
        } else
#line 298
        if ((unsigned int )language == 0U) {
#line 298
          if (c == 36) {
            {
#line 299
            cachec(c);
            }
          } else {
#line 301
            goto while_break;
          }
        } else {
#line 301
          goto while_break;
        }
      }
#line 302
      cptr ++;
#line 302
      c = (int )*cptr;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 304
    cachec('\000');
#line 306
    tmp___2 = strcmp((char const   *)cache, "token");
    }
#line 306
    if (tmp___2 == 0) {
#line 307
      return (0);
    } else {
      {
#line 306
      tmp___3 = strcmp((char const   *)cache, "term");
      }
#line 306
      if (tmp___3 == 0) {
#line 307
        return (0);
      }
    }
    {
#line 308
    tmp___4 = strcmp((char const   *)cache, "type");
    }
#line 308
    if (tmp___4 == 0) {
#line 309
      return (6);
    }
    {
#line 310
    tmp___5 = strcmp((char const   *)cache, "left");
    }
#line 310
    if (tmp___5 == 0) {
#line 311
      return (1);
    }
    {
#line 312
    tmp___6 = strcmp((char const   *)cache, "right");
    }
#line 312
    if (tmp___6 == 0) {
#line 313
      return (2);
    }
    {
#line 314
    tmp___7 = strcmp((char const   *)cache, "nonassoc");
    }
#line 314
    if (tmp___7 == 0) {
#line 315
      return (3);
    } else {
      {
#line 314
      tmp___8 = strcmp((char const   *)cache, "binary");
      }
#line 314
      if (tmp___8 == 0) {
#line 315
        return (3);
      }
    }
    {
#line 316
    tmp___9 = strcmp((char const   *)cache, "start");
    }
#line 316
    if (tmp___9 == 0) {
#line 317
      return (7);
    }
    {
#line 318
    tmp___10 = strcmp((char const   *)cache, "union");
    }
#line 318
    if (tmp___10 == 0) {
#line 319
      return (8);
    }
    {
#line 320
    tmp___11 = strcmp((char const   *)cache, "ident");
    }
#line 320
    if (tmp___11 == 0) {
#line 321
      return (9);
    }
  } else {
#line 325
    cptr ++;
#line 326
    if (c == 123) {
#line 327
      return (5);
    }
#line 328
    if (c == 37) {
#line 329
      return (4);
    } else
#line 328
    if (c == 92) {
#line 329
      return (4);
    }
#line 330
    if (c == 60) {
#line 331
      return (1);
    }
#line 332
    if (c == 62) {
#line 333
      return (2);
    }
#line 334
    if (c == 48) {
#line 335
      return (0);
    }
#line 336
    if (c == 50) {
#line 337
      return (3);
    }
  }
  {
#line 339
  syntax_error(lineno, line, t_cptr);
  }
#line 341
  return (0);
}
}
#line 345 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void copy_ident(void) 
{ 
  register int c ;
  register FILE *f ;

  {
  {
#line 351
  f = output_file;
#line 353
  c = nextc();
  }
#line 354
  if (c == -1) {
    {
#line 354
    unexpected_EOF();
    }
  }
#line 355
  if (c != 34) {
    {
#line 355
    syntax_error(lineno, line, cptr);
    }
  }
  {
#line 356
  outline ++;
#line 357
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"#ident \"");
  }
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    cptr ++;
#line 360
    c = (int )*cptr;
#line 361
    if (c == 10) {
      {
#line 363
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\"\n");
      }
#line 364
      return;
    }
    {
#line 366
    _IO_putc(c, f);
    }
#line 367
    if (c == 34) {
      {
#line 369
      _IO_putc('\n', f);
#line 370
      cptr ++;
      }
#line 371
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 378 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void copy_text(void) 
{ 
  register int c ;
  int quote ;
  register FILE *f ;
  int need_newline ;
  int t_lineno ;
  char *t_line ;
  char *tmp ;
  char *t_cptr ;
  char *tmp___0 ;
  int s_lineno ;
  char *s_line ;
  char *tmp___1 ;
  char *s_cptr ;
  char *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  int c_lineno ;
  char *c_line ;
  char *tmp___5 ;
  char *c_cptr ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 385
  f = text_file;
#line 386
  need_newline = 0;
#line 387
  t_lineno = lineno;
#line 388
  tmp = dup_line();
#line 388
  t_line = tmp;
#line 389
  t_cptr = t_line + ((cptr - line) - 2L);
  }
#line 391
  if ((int )*cptr == 10) {
    {
#line 393
    get_line();
    }
#line 394
    if ((unsigned long )line == (unsigned long )((char *)0)) {
      {
#line 395
      unterminated_text(t_lineno, t_line, t_cptr);
      }
    }
  }
#line 397
  if (! lflag) {
    {
#line 397
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)(line_format),
            lineno, input_file_name);
    }
  }
  loop: 
#line 400
  tmp___0 = cptr;
#line 400
  cptr ++;
#line 400
  c = (int )*tmp___0;
  {
#line 403
  if (c == 10) {
#line 403
    goto next_line;
  }
#line 412
  if (c == 34) {
#line 412
    goto case_34;
  }
#line 412
  if (c == 39) {
#line 412
    goto case_34;
  }
#line 446
  if (c == 47) {
#line 446
    goto case_47;
  }
#line 502
  if (c == 92) {
#line 502
    goto case_92;
  }
#line 502
  if (c == 37) {
#line 502
    goto case_92;
  }
#line 514
  if (c == 35) {
#line 514
    goto case_35;
  }
#line 526
  goto switch_default;
  next_line: 
  case_10: /* CIL Label */ 
  {
#line 405
  _IO_putc('\n', f);
#line 406
  need_newline = 0;
#line 407
  get_line();
  }
#line 408
  if (line) {
#line 408
    goto loop;
  }
  {
#line 409
  unterminated_text(t_lineno, t_line, t_cptr);
  }
  case_34: /* CIL Label */ 
  case_39: /* CIL Label */ 
  {
#line 414
  s_lineno = lineno;
#line 415
  tmp___1 = dup_line();
#line 415
  s_line = tmp___1;
#line 416
  s_cptr = s_line + ((cptr - line) - 1L);
#line 418
  quote = c;
#line 419
  _IO_putc(c, f);
  }
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 422
    tmp___2 = cptr;
#line 422
    cptr ++;
#line 422
    c = (int )*tmp___2;
#line 423
    _IO_putc(c, f);
    }
#line 424
    if (c == quote) {
      {
#line 426
      need_newline = 1;
#line 427
      free((void *)s_line);
      }
#line 428
      goto loop;
    }
#line 430
    if (c == 10) {
      {
#line 431
      unterminated_string(s_lineno, s_line, s_cptr);
      }
    }
#line 432
    if (c == 92) {
      {
#line 434
      tmp___3 = cptr;
#line 434
      cptr ++;
#line 434
      c = (int )*tmp___3;
#line 435
      _IO_putc(c, f);
      }
#line 436
      if (c == 10) {
        {
#line 438
        get_line();
        }
#line 439
        if ((unsigned long )line == (unsigned long )((char *)0)) {
          {
#line 440
          unterminated_string(s_lineno, s_line, s_cptr);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  case_47: /* CIL Label */ 
#line 447
  need_newline = 1;
#line 448
  c = (int )*cptr;
#line 449
  if (c == 47) {
#line 451
    if ((unsigned int )language == 1U) {
#line 452
      if ((unsigned long )cptr == (unsigned long )(line + 1)) {
#line 452
        tmp___4 = ";#";
      } else {
#line 452
        tmp___4 = "#";
      }
      {
#line 452
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)tmp___4);
      }
    } else {
      {
#line 454
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"/*");
      }
    }
    {
#line 455
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 455
      cptr ++;
#line 455
      c = (int )*cptr;
#line 455
      if (! (c != 10)) {
#line 455
        goto while_break___0;
      }
#line 457
      if (c == 42) {
#line 457
        if ((int )*(cptr + 1) == 47) {
          {
#line 458
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* ");
          }
        } else {
          {
#line 460
          _IO_putc(c, f);
          }
        }
      } else {
        {
#line 460
        _IO_putc(c, f);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 462
    if ((unsigned int )language == 0U) {
      {
#line 463
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*/");
      }
    }
#line 464
    goto next_line;
  } else
#line 466
  if (c == 42) {
    {
#line 468
    c_lineno = lineno;
#line 469
    tmp___5 = dup_line();
#line 469
    c_line = tmp___5;
#line 470
    c_cptr = c_line + ((cptr - line) - 1L);
    }
#line 472
    if ((unsigned int )language == 1U) {
#line 473
      if ((unsigned long )cptr == (unsigned long )(line + 1)) {
#line 473
        tmp___6 = ";#";
      } else {
#line 473
        tmp___6 = "#";
      }
      {
#line 473
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)tmp___6);
      }
    } else {
      {
#line 475
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"/*");
      }
    }
#line 476
    cptr ++;
    {
#line 477
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 479
      tmp___7 = cptr;
#line 479
      cptr ++;
#line 479
      c = (int )*tmp___7;
#line 480
      _IO_putc(c, f);
      }
#line 481
      if (c == 42) {
#line 481
        if ((int )*cptr == 47) {
#line 483
          if ((unsigned int )language == 0U) {
            {
#line 484
            _IO_putc('/', f);
            }
          }
          {
#line 485
          cptr ++;
#line 486
          free((void *)c_line);
          }
#line 487
          goto loop;
        }
      }
#line 489
      if (c == 10) {
        {
#line 491
        get_line();
        }
#line 492
        if ((unsigned long )line == (unsigned long )((char *)0)) {
          {
#line 493
          unterminated_comment(c_lineno, c_line, c_cptr);
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 498
    _IO_putc('/', f);
    }
  }
#line 499
  goto loop;
  case_92: /* CIL Label */ 
  case_37: /* CIL Label */ 
#line 503
  if ((int )*cptr == 125) {
#line 505
    if (need_newline) {
      {
#line 505
      _IO_putc('\n', f);
      }
    }
    {
#line 506
    cptr ++;
#line 507
    free((void *)t_line);
    }
#line 508
    return;
  }
  {
#line 510
  _IO_putc(c, f);
#line 511
  need_newline = 1;
  }
#line 512
  goto loop;
  case_35: /* CIL Label */ 
#line 515
  if ((unsigned int )language == 1U) {
#line 516
    if ((unsigned long )cptr == (unsigned long )(line + 1)) {
#line 516
      tmp___8 = ";#";
    } else {
#line 516
      tmp___8 = "#";
    }
    {
#line 516
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)tmp___8);
#line 517
    need_newline = 1;
    }
    {
#line 518
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 518
      tmp___9 = cptr;
#line 518
      cptr ++;
#line 518
      c = (int )*tmp___9;
#line 518
      if (! (c != 10)) {
#line 518
        goto while_break___2;
      }
      {
#line 519
      _IO_putc(c, f);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 520
    goto next_line;
  }
  {
#line 522
  _IO_putc(c, f);
#line 523
  need_newline = 1;
  }
#line 524
  goto loop;
  switch_default: /* CIL Label */ 
  {
#line 527
  _IO_putc(c, f);
#line 528
  need_newline = 1;
  }
#line 529
  goto loop;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 534 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void perl_comment(FILE *text_file___0 , FILE *other_file ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 541
  if ((unsigned int )language == 1U) {
#line 543
    if ((unsigned long )cptr == (unsigned long )(line + 1)) {
#line 543
      tmp = ";#";
    } else {
#line 543
      tmp = "#";
    }
    {
#line 543
    fprintf((FILE */* __restrict  */)text_file___0, (char const   */* __restrict  */)tmp);
    }
#line 544
    if (dflag) {
#line 545
      if ((unsigned long )cptr == (unsigned long )(line + 1)) {
#line 545
        tmp___0 = ";#";
      } else {
#line 545
        tmp___0 = "#";
      }
      {
#line 545
      fprintf((FILE */* __restrict  */)other_file, (char const   */* __restrict  */)tmp___0);
      }
    }
  }
#line 547
  return;
}
}
#line 550 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void copy_union(void) 
{ 
  register int c ;
  int quote ;
  int depth ;
  int u_lineno ;
  char *u_line ;
  char *tmp ;
  char *u_cptr ;
  char *tmp___0 ;
  int s_lineno ;
  char *s_line ;
  char *tmp___1 ;
  char *s_cptr ;
  char *tmp___2 ;
  char *tmp___3 ;
  int c_lineno ;
  char *c_line ;
  char *tmp___4 ;
  char *c_cptr ;
  char *tmp___5 ;

  {
  {
#line 558
  u_lineno = lineno;
#line 559
  tmp = dup_line();
#line 559
  u_line = tmp;
#line 560
  u_cptr = u_line + ((cptr - line) - 6L);
  }
#line 562
  if (unionized) {
    {
#line 562
    over_unionized(cptr - 6);
    }
  }
#line 563
  unionized = (char)1;
#line 565
  if (! lflag) {
    {
#line 566
    fprintf((FILE */* __restrict  */)text_file, (char const   */* __restrict  */)(line_format),
            lineno, input_file_name);
    }
  }
  {
#line 568
  perl_comment(text_file, union_file);
#line 569
  fprintf((FILE */* __restrict  */)text_file, (char const   */* __restrict  */)"typedef union");
  }
#line 570
  if (dflag) {
    {
#line 570
    fprintf((FILE */* __restrict  */)union_file, (char const   */* __restrict  */)"typedef union");
    }
  }
#line 572
  depth = 0;
  loop: 
  {
#line 574
  tmp___0 = cptr;
#line 574
  cptr ++;
#line 574
  c = (int )*tmp___0;
#line 575
  _IO_putc(c, text_file);
  }
#line 576
  if (dflag) {
    {
#line 576
    _IO_putc(c, union_file);
    }
  }
  {
#line 579
  if (c == 10) {
#line 579
    goto next_line;
  }
#line 586
  if (c == 123) {
#line 586
    goto case_123;
  }
#line 590
  if (c == 125) {
#line 590
    goto case_125;
  }
#line 600
  if (c == 34) {
#line 600
    goto case_34;
  }
#line 600
  if (c == 39) {
#line 600
    goto case_34;
  }
#line 634
  if (c == 47) {
#line 634
    goto case_47;
  }
#line 689
  goto switch_default;
  next_line: 
  case_10: /* CIL Label */ 
  {
#line 581
  get_line();
  }
#line 582
  if ((unsigned long )line == (unsigned long )((char *)0)) {
    {
#line 582
    unterminated_union(u_lineno, u_line, u_cptr);
    }
  }
  {
#line 583
  perl_comment(text_file, union_file);
  }
#line 584
  goto loop;
  case_123: /* CIL Label */ 
#line 587
  depth ++;
#line 588
  goto loop;
  case_125: /* CIL Label */ 
#line 591
  depth --;
#line 591
  if (depth == 0) {
    {
#line 593
    fprintf((FILE */* __restrict  */)text_file, (char const   */* __restrict  */)" %sSTYPE;\n",
            define_prefix);
#line 594
    free((void *)u_line);
    }
#line 595
    return;
  }
#line 597
  goto loop;
  case_34: /* CIL Label */ 
  case_39: /* CIL Label */ 
  {
#line 602
  s_lineno = lineno;
#line 603
  tmp___1 = dup_line();
#line 603
  s_line = tmp___1;
#line 604
  s_cptr = s_line + ((cptr - line) - 1L);
#line 606
  quote = c;
  }
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 609
    tmp___2 = cptr;
#line 609
    cptr ++;
#line 609
    c = (int )*tmp___2;
#line 610
    _IO_putc(c, text_file);
    }
#line 611
    if (dflag) {
      {
#line 611
      _IO_putc(c, union_file);
      }
    }
#line 612
    if (c == quote) {
      {
#line 614
      free((void *)s_line);
      }
#line 615
      goto loop;
    }
#line 617
    if (c == 10) {
      {
#line 618
      unterminated_string(s_lineno, s_line, s_cptr);
      }
    }
#line 619
    if (c == 92) {
      {
#line 621
      tmp___3 = cptr;
#line 621
      cptr ++;
#line 621
      c = (int )*tmp___3;
#line 622
      _IO_putc(c, text_file);
      }
#line 623
      if (dflag) {
        {
#line 623
        _IO_putc(c, union_file);
        }
      }
#line 624
      if (c == 10) {
        {
#line 626
        get_line();
        }
#line 627
        if ((unsigned long )line == (unsigned long )((char *)0)) {
          {
#line 628
          unterminated_string(s_lineno, s_line, s_cptr);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  case_47: /* CIL Label */ 
#line 635
  c = (int )*cptr;
#line 636
  if (c == 47) {
    {
#line 638
    _IO_putc('*', text_file);
    }
#line 639
    if (dflag) {
      {
#line 639
      _IO_putc('*', union_file);
      }
    }
    {
#line 640
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 640
      cptr ++;
#line 640
      c = (int )*cptr;
#line 640
      if (! (c != 10)) {
#line 640
        goto while_break___0;
      }
#line 642
      if (c == 42) {
#line 642
        if ((int )*(cptr + 1) == 47) {
          {
#line 644
          fprintf((FILE */* __restrict  */)text_file, (char const   */* __restrict  */)"* ");
          }
#line 645
          if (dflag) {
            {
#line 645
            fprintf((FILE */* __restrict  */)union_file, (char const   */* __restrict  */)"* ");
            }
          }
        } else {
#line 642
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 649
        _IO_putc(c, text_file);
        }
#line 650
        if (dflag) {
          {
#line 650
          _IO_putc(c, union_file);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 653
    fprintf((FILE */* __restrict  */)text_file, (char const   */* __restrict  */)"*/\n");
    }
#line 654
    if (dflag) {
      {
#line 654
      fprintf((FILE */* __restrict  */)union_file, (char const   */* __restrict  */)"*/\n");
      }
    }
#line 655
    goto next_line;
  }
#line 657
  if (c == 42) {
    {
#line 659
    c_lineno = lineno;
#line 660
    tmp___4 = dup_line();
#line 660
    c_line = tmp___4;
#line 661
    c_cptr = c_line + ((cptr - line) - 1L);
#line 663
    _IO_putc('*', text_file);
    }
#line 664
    if (dflag) {
      {
#line 664
      _IO_putc('*', union_file);
      }
    }
#line 665
    cptr ++;
    {
#line 666
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 668
      tmp___5 = cptr;
#line 668
      cptr ++;
#line 668
      c = (int )*tmp___5;
#line 669
      _IO_putc(c, text_file);
      }
#line 670
      if (dflag) {
        {
#line 670
        _IO_putc(c, union_file);
        }
      }
#line 671
      if (c == 42) {
#line 671
        if ((int )*cptr == 47) {
          {
#line 673
          _IO_putc('/', text_file);
          }
#line 674
          if (dflag) {
            {
#line 674
            _IO_putc('/', union_file);
            }
          }
          {
#line 675
          cptr ++;
#line 676
          free((void *)c_line);
          }
#line 677
          goto loop;
        }
      }
#line 679
      if (c == 10) {
        {
#line 681
        get_line();
        }
#line 682
        if ((unsigned long )line == (unsigned long )((char *)0)) {
          {
#line 683
          unterminated_comment(c_lineno, c_line, c_cptr);
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 687
  goto loop;
  switch_default: /* CIL Label */ 
#line 690
  goto loop;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 696 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static int hexval(int c ) 
{ 


  {
#line 702
  if (c >= 48) {
#line 702
    if (c <= 57) {
#line 703
      return (c - 48);
    }
  }
#line 704
  if (c >= 65) {
#line 704
    if (c <= 70) {
#line 705
      return ((c - 65) + 10);
    }
  }
#line 706
  if (c >= 97) {
#line 706
    if (c <= 102) {
#line 707
      return ((c - 97) + 10);
    }
  }
#line 708
  return (-1);
}
}
#line 713 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static bucket *get_literal(void) 
{ 
  register int c ;
  register int quote ;
  register int i ;
  register int n ;
  register char *s ;
  register bucket *bp ;
  int s_lineno ;
  char *s_line ;
  char *tmp ;
  char *s_cptr ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *c_cptr ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 723
  s_lineno = lineno;
#line 724
  tmp = dup_line();
#line 724
  s_line = tmp;
#line 725
  s_cptr = s_line + (cptr - line);
#line 727
  tmp___0 = cptr;
#line 727
  cptr ++;
#line 727
  quote = (int )*tmp___0;
#line 728
  cinc = 0;
  }
  {
#line 729
  while (1) {
    while_continue: /* CIL Label */ ;
#line 731
    tmp___1 = cptr;
#line 731
    cptr ++;
#line 731
    c = (int )*tmp___1;
#line 732
    if (c == quote) {
#line 732
      goto while_break;
    }
#line 733
    if (c == 10) {
      {
#line 733
      unterminated_string(s_lineno, s_line, s_cptr);
      }
    }
#line 734
    if (c == 92) {
#line 736
      c_cptr = cptr - 1;
#line 738
      tmp___2 = cptr;
#line 738
      cptr ++;
#line 738
      c = (int )*tmp___2;
      {
#line 741
      if (c == 10) {
#line 741
        goto case_10;
      }
#line 747
      if (c == 55) {
#line 747
        goto case_55;
      }
#line 747
      if (c == 54) {
#line 747
        goto case_55;
      }
#line 747
      if (c == 53) {
#line 747
        goto case_55;
      }
#line 747
      if (c == 52) {
#line 747
        goto case_55;
      }
#line 747
      if (c == 51) {
#line 747
        goto case_55;
      }
#line 747
      if (c == 50) {
#line 747
        goto case_55;
      }
#line 747
      if (c == 49) {
#line 747
        goto case_55;
      }
#line 747
      if (c == 48) {
#line 747
        goto case_55;
      }
#line 764
      if (c == 120) {
#line 764
        goto case_120;
      }
#line 781
      if (c == 97) {
#line 781
        goto case_97;
      }
#line 782
      if (c == 98) {
#line 782
        goto case_98;
      }
#line 783
      if (c == 102) {
#line 783
        goto case_102;
      }
#line 784
      if (c == 110) {
#line 784
        goto case_110;
      }
#line 785
      if (c == 114) {
#line 785
        goto case_114;
      }
#line 786
      if (c == 116) {
#line 786
        goto case_116;
      }
#line 787
      if (c == 118) {
#line 787
        goto case_118;
      }
#line 739
      goto switch_break;
      case_10: /* CIL Label */ 
      {
#line 742
      get_line();
      }
#line 743
      if ((unsigned long )line == (unsigned long )((char *)0)) {
        {
#line 743
        unterminated_string(s_lineno, s_line, s_cptr);
        }
      }
#line 744
      goto __Cont;
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 748
      n = c - 48;
#line 749
      c = (int )*cptr;
#line 750
      if (c >= 48) {
#line 750
        if (c <= 55) {
#line 752
          n = (n << 3) + (c - 48);
#line 753
          cptr ++;
#line 753
          c = (int )*cptr;
#line 754
          if (c >= 48) {
#line 754
            if (c <= 55) {
#line 756
              n = (n << 3) + (c - 48);
#line 757
              cptr ++;
            }
          }
        }
      }
#line 760
      if (n > 255) {
        {
#line 760
        illegal_character(c_cptr);
        }
      }
#line 761
      c = n;
#line 762
      goto switch_break;
      case_120: /* CIL Label */ 
      {
#line 765
      tmp___3 = cptr;
#line 765
      cptr ++;
#line 765
      c = (int )*tmp___3;
#line 766
      n = hexval(c);
      }
#line 767
      if (n < 0) {
        {
#line 768
        illegal_character(c_cptr);
        }
      } else
#line 767
      if (n >= 16) {
        {
#line 768
        illegal_character(c_cptr);
        }
      }
      {
#line 769
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 771
        c = (int )*cptr;
#line 772
        i = hexval(c);
        }
#line 773
        if (i < 0) {
#line 773
          goto while_break___0;
        } else
#line 773
        if (i >= 16) {
#line 773
          goto while_break___0;
        }
#line 774
        cptr ++;
#line 775
        n = (n << 4) + i;
#line 776
        if (n > 255) {
          {
#line 776
          illegal_character(c_cptr);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 778
      c = n;
#line 779
      goto switch_break;
      case_97: /* CIL Label */ 
#line 781
      c = 7;
#line 781
      goto switch_break;
      case_98: /* CIL Label */ 
#line 782
      c = '\b';
#line 782
      goto switch_break;
      case_102: /* CIL Label */ 
#line 783
      c = '\f';
#line 783
      goto switch_break;
      case_110: /* CIL Label */ 
#line 784
      c = '\n';
#line 784
      goto switch_break;
      case_114: /* CIL Label */ 
#line 785
      c = '\r';
#line 785
      goto switch_break;
      case_116: /* CIL Label */ 
#line 786
      c = '\t';
#line 786
      goto switch_break;
      case_118: /* CIL Label */ 
#line 787
      c = '\v';
#line 787
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 790
    cachec(c);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 792
  free((void *)s_line);
#line 794
  n = cinc;
#line 795
  s = my_malloc((unsigned int )n);
#line 797
  i = 0;
  }
  {
#line 797
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 797
    if (! (i < n)) {
#line 797
      goto while_break___1;
    }
#line 798
    *(s + i) = *(cache + i);
#line 797
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 800
  cinc = 0;
#line 801
  if (n == 1) {
    {
#line 802
    cachec('\'');
    }
  } else {
    {
#line 804
    cachec('\"');
    }
  }
#line 806
  i = 0;
  {
#line 806
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 806
    if (! (i < n)) {
#line 806
      goto while_break___2;
    }
#line 808
    c = (int )*((unsigned char *)s + i);
#line 809
    if (c == 92) {
      {
#line 811
      cachec('\\');
#line 812
      cachec(c);
      }
    } else
#line 809
    if (c == (int )*(cache + 0)) {
      {
#line 811
      cachec('\\');
#line 812
      cachec(c);
      }
    } else {
      {
#line 814
      tmp___4 = __ctype_b_loc();
      }
#line 814
      if ((int const   )*(*tmp___4 + c) & 16384) {
        {
#line 815
        cachec(c);
        }
      } else {
        {
#line 818
        cachec('\\');
        }
        {
#line 821
        if (c == 7) {
#line 821
          goto case_7;
        }
#line 822
        if (c == 8) {
#line 822
          goto case_8;
        }
#line 823
        if (c == 12) {
#line 823
          goto case_12;
        }
#line 824
        if (c == 10) {
#line 824
          goto case_10___0;
        }
#line 825
        if (c == 13) {
#line 825
          goto case_13;
        }
#line 826
        if (c == 9) {
#line 826
          goto case_9;
        }
#line 827
        if (c == 11) {
#line 827
          goto case_11;
        }
#line 828
        goto switch_default;
        case_7: /* CIL Label */ 
        {
#line 821
        cachec('a');
        }
#line 821
        goto switch_break___0;
        case_8: /* CIL Label */ 
        {
#line 822
        cachec('b');
        }
#line 822
        goto switch_break___0;
        case_12: /* CIL Label */ 
        {
#line 823
        cachec('f');
        }
#line 823
        goto switch_break___0;
        case_10___0: /* CIL Label */ 
        {
#line 824
        cachec('n');
        }
#line 824
        goto switch_break___0;
        case_13: /* CIL Label */ 
        {
#line 825
        cachec('r');
        }
#line 825
        goto switch_break___0;
        case_9: /* CIL Label */ 
        {
#line 826
        cachec('t');
        }
#line 826
        goto switch_break___0;
        case_11: /* CIL Label */ 
        {
#line 827
        cachec('v');
        }
#line 827
        goto switch_break___0;
        switch_default: /* CIL Label */ 
        {
#line 829
        cachec(((c >> 6) & 7) + 48);
#line 830
        cachec(((c >> 3) & 7) + 48);
#line 831
        cachec((c & 7) + 48);
        }
#line 832
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
    }
#line 806
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 837
  if (n == 1) {
    {
#line 838
    cachec('\'');
    }
  } else {
    {
#line 840
    cachec('\"');
    }
  }
  {
#line 842
  cachec('\000');
#line 843
  bp = lookup(cache);
#line 844
  bp->class = (char)1;
  }
#line 845
  if (n == 1) {
#line 845
    if ((int )bp->value == -1) {
#line 846
      bp->value = (short )*((unsigned char *)s);
    }
  }
  {
#line 847
  free((void *)s);
  }
#line 849
  return (bp);
}
}
#line 854 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static int is_reserved(char *name ) 
{ 
  char *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  {
#line 862
  tmp = strcmp((char const   *)name, ".");
  }
#line 862
  if (tmp == 0) {
#line 865
    return (1);
  } else {
    {
#line 862
    tmp___0 = strcmp((char const   *)name, "$accept");
    }
#line 862
    if (tmp___0 == 0) {
#line 865
      return (1);
    } else {
      {
#line 862
      tmp___1 = strcmp((char const   *)name, "$end");
      }
#line 862
      if (tmp___1 == 0) {
#line 865
        return (1);
      }
    }
  }
#line 867
  if ((int )*(name + 0) == 36) {
#line 867
    if ((int )*(name + 1) == 36) {
      {
#line 867
      tmp___3 = __ctype_b_loc();
      }
#line 867
      if ((int const   )*(*tmp___3 + (int )*(name + 2)) & 2048) {
#line 869
        s = name + 3;
        {
#line 870
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 870
          tmp___2 = __ctype_b_loc();
          }
#line 870
          if (! ((int const   )*(*tmp___2 + (int )*s) & 2048)) {
#line 870
            goto while_break;
          }
#line 870
          s ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 871
        if ((int )*s == 0) {
#line 871
          return (1);
        }
      }
    }
  }
#line 874
  return (0);
}
}
#line 879 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static bucket *get_name(void) 
{ 
  register int c ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  bucket *tmp___1 ;

  {
#line 886
  cinc = 0;
#line 887
  c = (int )*cptr;
  {
#line 887
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 887
    tmp = __ctype_b_loc();
    }
#line 887
    if (! ((int const   )*(*tmp + c) & 8)) {
#line 887
      if (! (c == 95)) {
#line 887
        if (! (c == 46)) {
#line 887
          if (! (c == 36)) {
#line 887
            goto while_break;
          }
        }
      }
    }
    {
#line 888
    cachec(c);
#line 887
    cptr ++;
#line 887
    c = (int )*cptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 889
  cachec('\000');
#line 891
  tmp___0 = is_reserved(cache);
  }
#line 891
  if (tmp___0) {
    {
#line 891
    used_reserved(cache);
    }
  }
  {
#line 893
  tmp___1 = lookup(cache);
  }
#line 893
  return (tmp___1);
}
}
#line 898 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static int get_number(void) 
{ 
  register int c ;
  register int n ;
  unsigned short const   **tmp ;

  {
#line 906
  n = 0;
#line 907
  c = (int )*cptr;
  {
#line 907
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 907
    tmp = __ctype_b_loc();
    }
#line 907
    if (! ((int const   )*(*tmp + c) & 2048)) {
#line 907
      goto while_break;
    }
#line 908
    n = 10 * n + (c - 48);
#line 907
    cptr ++;
#line 907
    c = (int )*cptr;
  }
  while_break: /* CIL Label */ ;
  }
#line 910
  return (n);
}
}
#line 915 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static char *get_tag(void) 
{ 
  register int c ;
  register int i ;
  register char *s ;
  int t_lineno ;
  char *t_line ;
  char *tmp ;
  char *t_cptr ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 923
  t_lineno = lineno;
#line 924
  tmp = dup_line();
#line 924
  t_line = tmp;
#line 925
  t_cptr = t_line + (cptr - line);
#line 927
  cptr ++;
#line 928
  c = nextc();
  }
#line 929
  if (c == -1) {
    {
#line 929
    unexpected_EOF();
    }
  }
  {
#line 930
  tmp___0 = __ctype_b_loc();
  }
#line 930
  if ((int const   )*(*tmp___0 + c) & 1024) {
    _L___0: /* CIL Label */ 
#line 932
    if (! ((unsigned int )language == 0U)) {
#line 932
      if (c == 36) {
        {
#line 933
        illegal_tag(t_lineno, t_line, t_cptr);
        }
      }
    }
  } else
#line 930
  if (c != 95) {
#line 930
    if (c != 36) {
      {
#line 931
      illegal_tag(t_lineno, t_line, t_cptr);
      }
    } else {
#line 930
      goto _L___0;
    }
  } else {
#line 930
    goto _L___0;
  }
#line 935
  cinc = 0;
  {
#line 936
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 936
    cachec(c);
#line 936
    cptr ++;
#line 936
    c = (int )*cptr;
#line 936
    tmp___1 = __ctype_b_loc();
    }
#line 936
    if (! ((int const   )*(*tmp___1 + c) & 8)) {
#line 936
      if (! (c == 95)) {
#line 936
        if (! (c == 46)) {
#line 936
          if (! (c == 36)) {
#line 936
            goto while_break;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 937
  cachec('\000');
#line 939
  c = nextc();
  }
#line 940
  if (c == -1) {
    {
#line 940
    unexpected_EOF();
    }
  }
#line 941
  if (c != 62) {
    {
#line 942
    illegal_tag(t_lineno, t_line, t_cptr);
    }
  }
#line 943
  cptr ++;
#line 945
  i = 0;
  {
#line 945
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 945
    if (! (i < ntags)) {
#line 945
      goto while_break___0;
    }
    {
#line 947
    tmp___2 = strcmp((char const   *)cache, (char const   *)*(tag_table + i));
    }
#line 947
    if (tmp___2 == 0) {
#line 948
      return (*(tag_table + i));
    }
#line 945
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 951
  if (ntags >= tagmax) {
#line 953
    tagmax += 16;
#line 954
    if (tag_table) {
      {
#line 954
      tmp___3 = my_realloc((char *)tag_table, (unsigned int )((unsigned long )tagmax * sizeof(char *)));
#line 954
      tmp___5 = tmp___3;
      }
    } else {
      {
#line 954
      tmp___4 = my_malloc((unsigned int )((unsigned long )tagmax * sizeof(char *)));
#line 954
      tmp___5 = tmp___4;
      }
    }
#line 954
    tag_table = (char **)tmp___5;
  }
  {
#line 959
  s = my_malloc((unsigned int )cinc);
#line 960
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)cache);
#line 961
  *(tag_table + ntags) = s;
#line 962
  ntags ++;
#line 963
  free((void *)t_line);
  }
#line 964
  return (s);
}
}
#line 969 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void declare_tokens(int assoc ) 
{ 
  register int c ;
  register bucket *bp ;
  int value ;
  char *tag ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 978
  tag = (char *)0;
#line 980
  if (assoc != 0) {
#line 980
    prec ++;
  }
  {
#line 982
  c = nextc();
  }
#line 983
  if (c == -1) {
    {
#line 983
    unexpected_EOF();
    }
  }
#line 984
  if (c == 60) {
    {
#line 986
    tag = get_tag();
#line 987
    c = nextc();
    }
#line 988
    if (c == -1) {
      {
#line 988
      unexpected_EOF();
      }
    }
  }
  {
#line 991
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 993
    tmp = __ctype_b_loc();
    }
#line 993
    if ((int const   )*(*tmp + c) & 1024) {
      {
#line 994
      bp = get_name();
      }
    } else
#line 993
    if (c == 95) {
      {
#line 994
      bp = get_name();
      }
    } else
#line 993
    if (c == 46) {
      {
#line 994
      bp = get_name();
      }
    } else
#line 993
    if ((unsigned int )language == 0U) {
#line 993
      if (c == 36) {
        {
#line 994
        bp = get_name();
        }
      } else {
#line 993
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 995
    if (c == 39) {
      {
#line 996
      bp = get_literal();
      }
    } else
#line 995
    if (c == 34) {
      {
#line 996
      bp = get_literal();
      }
    } else {
#line 998
      return;
    }
#line 1000
    if ((unsigned long )bp == (unsigned long )goal) {
      {
#line 1000
      tokenized_start(bp->name);
      }
    }
#line 1001
    bp->class = (char)1;
#line 1003
    if (tag) {
#line 1005
      if (bp->tag) {
#line 1005
        if ((unsigned long )tag != (unsigned long )bp->tag) {
          {
#line 1006
          retyped_warning(bp->name);
          }
        }
      }
#line 1007
      bp->tag = tag;
    }
#line 1010
    if (assoc != 0) {
#line 1012
      if (bp->prec) {
#line 1012
        if (prec != (int )bp->prec) {
          {
#line 1013
          reprec_warning(bp->name);
          }
        }
      }
#line 1014
      bp->assoc = (char )assoc;
#line 1015
      bp->prec = (short )prec;
    }
    {
#line 1018
    c = nextc();
    }
#line 1019
    if (c == -1) {
      {
#line 1019
      unexpected_EOF();
      }
    }
    {
#line 1020
    value = -1;
#line 1021
    tmp___0 = __ctype_b_loc();
    }
#line 1021
    if ((int const   )*(*tmp___0 + c) & 2048) {
      {
#line 1023
      value = get_number();
      }
#line 1024
      if ((int )bp->value != -1) {
#line 1024
        if (value != (int )bp->value) {
          {
#line 1025
          revalued_warning(bp->name);
          }
        }
      }
      {
#line 1026
      bp->value = (short )value;
#line 1027
      c = nextc();
      }
#line 1028
      if (c == -1) {
        {
#line 1028
        unexpected_EOF();
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1035 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void declare_types(void) 
{ 
  register int c ;
  register bucket *bp ;
  char *tag ;
  unsigned short const   **tmp ;

  {
  {
#line 1044
  c = nextc();
  }
#line 1045
  if (c == -1) {
    {
#line 1045
    unexpected_EOF();
    }
  }
#line 1046
  if (c != 60) {
    {
#line 1046
    syntax_error(lineno, line, cptr);
    }
  }
  {
#line 1047
  tag = get_tag();
  }
  {
#line 1049
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1051
    c = nextc();
#line 1052
    tmp = __ctype_b_loc();
    }
#line 1052
    if ((int const   )*(*tmp + c) & 1024) {
      {
#line 1053
      bp = get_name();
      }
    } else
#line 1052
    if (c == 95) {
      {
#line 1053
      bp = get_name();
      }
    } else
#line 1052
    if (c == 46) {
      {
#line 1053
      bp = get_name();
      }
    } else
#line 1052
    if ((unsigned int )language == 0U) {
#line 1052
      if (c == 36) {
        {
#line 1053
        bp = get_name();
        }
      } else {
#line 1052
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1054
    if (c == 39) {
      {
#line 1055
      bp = get_literal();
      }
    } else
#line 1054
    if (c == 34) {
      {
#line 1055
      bp = get_literal();
      }
    } else {
#line 1057
      return;
    }
#line 1059
    if (bp->tag) {
#line 1059
      if ((unsigned long )tag != (unsigned long )bp->tag) {
        {
#line 1060
        retyped_warning(bp->name);
        }
      }
    }
#line 1061
    bp->tag = tag;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1067 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void declare_start(void) 
{ 
  register int c ;
  register bucket *bp ;
  unsigned short const   **tmp ;

  {
  {
#line 1075
  c = nextc();
  }
#line 1076
  if (c == -1) {
    {
#line 1076
    unexpected_EOF();
    }
  }
  {
#line 1077
  tmp = __ctype_b_loc();
  }
#line 1077
  if ((int const   )*(*tmp + c) & 1024) {
    _L___1: /* CIL Label */ 
#line 1079
    if (! ((unsigned int )language == 0U)) {
#line 1079
      if (c == 36) {
        {
#line 1080
        syntax_error(lineno, line, cptr);
        }
      }
    }
  } else
#line 1077
  if (c != 95) {
#line 1077
    if (c != 46) {
#line 1077
      if (c != 36) {
        {
#line 1078
        syntax_error(lineno, line, cptr);
        }
      } else {
#line 1077
        goto _L___1;
      }
    } else {
#line 1077
      goto _L___1;
    }
  } else {
#line 1077
    goto _L___1;
  }
  {
#line 1081
  bp = get_name();
  }
#line 1082
  if ((int )bp->class == 1) {
    {
#line 1083
    terminal_start(bp->name);
    }
  }
#line 1084
  if (goal) {
#line 1084
    if ((unsigned long )goal != (unsigned long )bp) {
      {
#line 1085
      restarted_warning();
      }
    }
  }
#line 1086
  goal = bp;
#line 1087
  return;
}
}
#line 1091 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void read_declarations(void) 
{ 
  register int c ;
  register int k ;

  {
  {
#line 1098
  cache_size = 256;
#line 1099
  cache = my_malloc((unsigned int )cache_size);
  }
  {
#line 1101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1103
    c = nextc();
    }
#line 1104
    if (c == -1) {
      {
#line 1104
      unexpected_EOF();
      }
    }
#line 1105
    if (c != 37) {
      {
#line 1105
      syntax_error(lineno, line, cptr);
      }
    }
    {
#line 1106
    k = keyword();
    }
    {
#line 1108
    if (k == 4) {
#line 1108
      goto case_4;
    }
#line 1111
    if (k == 9) {
#line 1111
      goto case_9;
    }
#line 1115
    if (k == 5) {
#line 1115
      goto case_5;
    }
#line 1119
    if (k == 8) {
#line 1119
      goto case_8;
    }
#line 1126
    if (k == 3) {
#line 1126
      goto case_3;
    }
#line 1126
    if (k == 2) {
#line 1126
      goto case_3;
    }
#line 1126
    if (k == 1) {
#line 1126
      goto case_3;
    }
#line 1126
    if (k == 0) {
#line 1126
      goto case_3;
    }
#line 1130
    if (k == 6) {
#line 1130
      goto case_6;
    }
#line 1134
    if (k == 7) {
#line 1134
      goto case_7;
    }
#line 1106
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1109
    return;
    case_9: /* CIL Label */ 
    {
#line 1112
    copy_ident();
    }
#line 1113
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1116
    copy_text();
    }
#line 1117
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 1120
    copy_union();
    }
#line 1121
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 1127
    declare_tokens(k);
    }
#line 1128
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1131
    declare_types();
    }
#line 1132
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 1135
    declare_start();
    }
#line 1136
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1143 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void initialize_grammar(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1148
  nitems = 4;
#line 1149
  maxitems = 300;
#line 1150
  tmp = my_malloc((unsigned int )((unsigned long )maxitems * sizeof(bucket *)));
#line 1150
  pitem = (bucket **)tmp;
#line 1151
  *(pitem + 0) = (bucket *)0;
#line 1152
  *(pitem + 1) = (bucket *)0;
#line 1153
  *(pitem + 2) = (bucket *)0;
#line 1154
  *(pitem + 3) = (bucket *)0;
#line 1156
  nrules = 3;
#line 1157
  maxrules = 100;
#line 1158
  tmp___0 = my_malloc((unsigned int )((unsigned long )maxrules * sizeof(bucket *)));
#line 1158
  plhs = (bucket **)tmp___0;
#line 1159
  *(plhs + 0) = (bucket *)0;
#line 1160
  *(plhs + 1) = (bucket *)0;
#line 1161
  *(plhs + 2) = (bucket *)0;
#line 1163
  tmp___1 = my_malloc((unsigned int )((unsigned long )maxrules * sizeof(short )));
#line 1163
  rprec = (short *)tmp___1;
#line 1164
  *(rprec + 0) = (short)0;
#line 1165
  *(rprec + 1) = (short)0;
#line 1166
  *(rprec + 2) = (short)0;
#line 1168
  tmp___2 = my_malloc((unsigned int )((unsigned long )maxrules * sizeof(char )));
#line 1168
  rassoc = tmp___2;
#line 1169
  *(rassoc + 0) = (char)0;
#line 1170
  *(rassoc + 1) = (char)0;
#line 1171
  *(rassoc + 2) = (char)0;
  }
#line 1172
  return;
}
}
#line 1176 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void expand_items(void) 
{ 
  char *tmp ;

  {
  {
#line 1181
  maxitems += 300;
#line 1182
  tmp = my_realloc((char *)pitem, (unsigned int )((unsigned long )maxitems * sizeof(bucket *)));
#line 1182
  pitem = (bucket **)tmp;
  }
#line 1183
  return;
}
}
#line 1187 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void expand_rules(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1192
  maxrules += 100;
#line 1193
  tmp = my_realloc((char *)plhs, (unsigned int )((unsigned long )maxrules * sizeof(bucket *)));
#line 1193
  plhs = (bucket **)tmp;
#line 1194
  tmp___0 = my_realloc((char *)rprec, (unsigned int )((unsigned long )maxrules * sizeof(short )));
#line 1194
  rprec = (short *)tmp___0;
#line 1195
  tmp___1 = my_realloc(rassoc, (unsigned int )((unsigned long )maxrules * sizeof(char )));
#line 1195
  rassoc = tmp___1;
  }
#line 1196
  return;
}
}
#line 1200 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void advance_to_start(void) 
{ 
  register int c ;
  register bucket *bp ;
  char *s_cptr ;
  int s_lineno ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 1210
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1212
    c = nextc();
    }
#line 1213
    if (c != 37) {
#line 1213
      goto while_break;
    }
    {
#line 1214
    s_cptr = cptr;
#line 1215
    tmp = keyword();
    }
    {
#line 1217
    if (tmp == 4) {
#line 1217
      goto case_4;
    }
#line 1220
    if (tmp == 5) {
#line 1220
      goto case_5;
    }
#line 1224
    if (tmp == 7) {
#line 1224
      goto case_7;
    }
#line 1228
    goto switch_default;
    case_4: /* CIL Label */ 
    {
#line 1218
    no_grammar();
    }
    case_5: /* CIL Label */ 
    {
#line 1221
    copy_text();
    }
#line 1222
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 1225
    declare_start();
    }
#line 1226
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1229
    syntax_error(lineno, line, s_cptr);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1233
  c = nextc();
#line 1234
  tmp___0 = __ctype_b_loc();
  }
#line 1234
  if (! ((int const   )*(*tmp___0 + c) & 1024)) {
#line 1234
    if (c != 95) {
#line 1234
      if (c != 46) {
        {
#line 1235
        syntax_error(lineno, line, cptr);
        }
      }
    }
  }
  {
#line 1236
  bp = get_name();
  }
#line 1237
  if ((unsigned long )goal == (unsigned long )((bucket *)0)) {
#line 1239
    if ((int )bp->class == 1) {
      {
#line 1240
      terminal_start(bp->name);
      }
    }
#line 1241
    goal = bp;
  }
  {
#line 1244
  s_lineno = lineno;
#line 1245
  c = nextc();
  }
#line 1246
  if (c == -1) {
    {
#line 1246
    unexpected_EOF();
    }
  }
#line 1247
  if (c != 58) {
    {
#line 1247
    syntax_error(lineno, line, cptr);
    }
  }
  {
#line 1248
  start_rule(bp, s_lineno);
#line 1249
  cptr ++;
  }
#line 1250
  return;
}
}
#line 1254 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void start_rule(bucket *bp , int s_lineno ) 
{ 


  {
#line 1261
  if ((int )bp->class == 1) {
    {
#line 1262
    terminal_lhs(s_lineno);
    }
  }
#line 1263
  bp->class = (char)2;
#line 1264
  if (nrules >= maxrules) {
    {
#line 1265
    expand_rules();
    }
  }
#line 1266
  *(plhs + nrules) = bp;
#line 1267
  *(rprec + nrules) = (short)-1;
#line 1268
  *(rassoc + nrules) = (char)0;
#line 1269
  return;
}
}
#line 1273 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void end_rule(void) 
{ 
  register int i ;

  {
#line 1280
  if (! last_was_action) {
#line 1280
    if ((*(plhs + nrules))->tag) {
#line 1282
      i = nitems - 1;
      {
#line 1282
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1282
        if (! *(pitem + i)) {
#line 1282
          goto while_break;
        }
#line 1282
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 1282
        i --;
      }
      while_break: /* CIL Label */ ;
      }
#line 1283
      if ((unsigned long )*(pitem + (i + 1)) == (unsigned long )((bucket *)0)) {
        {
#line 1284
        default_action_warning();
        }
      } else
#line 1283
      if ((unsigned long )(*(pitem + (i + 1)))->tag != (unsigned long )(*(plhs + nrules))->tag) {
        {
#line 1284
        default_action_warning();
        }
      }
    }
  }
#line 1287
  last_was_action = (char)0;
#line 1288
  if (nitems >= maxitems) {
    {
#line 1288
    expand_items();
    }
  }
#line 1289
  *(pitem + nitems) = (bucket *)0;
#line 1290
  nitems ++;
#line 1291
  nrules ++;
#line 1292
  return;
}
}
#line 1296 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void insert_empty_rule(void) 
{ 
  register bucket *bp ;
  register bucket **bpp ;
  bucket **tmp ;
  bucket *tmp___0 ;

  {
#line 1303
  if (! ((unsigned long )cache != (unsigned long )((char *)((void *)0)))) {
    {
#line 1303
    __assert_fail("cache != (char *) ((void *)0)", "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c",
                  1303U, "insert_empty_rule");
    }
  }
  {
#line 1304
  gensym ++;
#line 1304
  sprintf((char */* __restrict  */)cache, (char const   */* __restrict  */)"$$%d",
          gensym);
#line 1305
  bp = make_bucket(cache);
#line 1306
  last_symbol->next = bp;
#line 1307
  last_symbol = bp;
#line 1308
  bp->tag = (*(plhs + nrules))->tag;
#line 1309
  bp->class = (char)2;
#line 1311
  nitems += 2;
  }
#line 1311
  if (nitems > maxitems) {
    {
#line 1312
    expand_items();
    }
  }
#line 1313
  bpp = (pitem + nitems) - 1;
#line 1314
  tmp = bpp;
#line 1314
  bpp --;
#line 1314
  *tmp = bp;
  {
#line 1315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1315
    tmp___0 = *(bpp + -1);
#line 1315
    *(bpp + 0) = tmp___0;
#line 1315
    if (! tmp___0) {
#line 1315
      goto while_break;
    }
#line 1315
    bpp --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1317
  nrules ++;
#line 1317
  if (nrules >= maxrules) {
    {
#line 1318
    expand_rules();
    }
  }
#line 1319
  *(plhs + nrules) = *(plhs + (nrules - 1));
#line 1320
  *(plhs + (nrules - 1)) = bp;
#line 1321
  *(rprec + nrules) = *(rprec + (nrules - 1));
#line 1322
  *(rprec + (nrules - 1)) = (short)0;
#line 1323
  *(rassoc + nrules) = *(rassoc + (nrules - 1));
#line 1324
  *(rassoc + (nrules - 1)) = (char)0;
#line 1325
  return;
}
}
#line 1329 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void add_symbol(void) 
{ 
  register int c ;
  register bucket *bp ;
  int s_lineno ;

  {
#line 1336
  s_lineno = lineno;
#line 1338
  c = (int )*cptr;
#line 1339
  if (c == 39) {
    {
#line 1340
    bp = get_literal();
    }
  } else
#line 1339
  if (c == 34) {
    {
#line 1340
    bp = get_literal();
    }
  } else {
    {
#line 1342
    bp = get_name();
    }
  }
  {
#line 1344
  c = nextc();
  }
#line 1345
  if (c == 58) {
    {
#line 1347
    end_rule();
#line 1348
    start_rule(bp, s_lineno);
#line 1349
    cptr ++;
    }
#line 1350
    return;
  }
#line 1353
  if (last_was_action) {
    {
#line 1354
    insert_empty_rule();
    }
  }
#line 1355
  last_was_action = (char)0;
#line 1357
  nitems ++;
#line 1357
  if (nitems > maxitems) {
    {
#line 1358
    expand_items();
    }
  }
#line 1359
  *(pitem + (nitems - 1)) = bp;
#line 1360
  return;
}
}
#line 1364 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void copy_action(void) 
{ 
  register int c ;
  register int i ;
  register int n ;
  int depth ;
  int quote ;
  char *tag ;
  register FILE *f ;
  int a_lineno ;
  char *a_line ;
  char *tmp ;
  char *a_cptr ;
  int d_lineno ;
  char *d_line ;
  char *tmp___0 ;
  char *d_cptr ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int s_lineno ;
  char *s_line ;
  char *tmp___7 ;
  char *s_cptr ;
  char *tmp___8 ;
  char *tmp___9 ;
  int c_lineno ;
  char *c_line ;
  char *tmp___10 ;
  char *c_cptr ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 1374
  f = action_file;
#line 1375
  a_lineno = lineno;
#line 1376
  tmp = dup_line();
#line 1376
  a_line = tmp;
#line 1377
  a_cptr = a_line + (cptr - line);
  }
#line 1379
  if (last_was_action) {
    {
#line 1380
    insert_empty_rule();
    }
  }
#line 1381
  last_was_action = (char)1;
#line 1383
  if ((unsigned int )language == 1U) {
    {
#line 1384
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"if ($p->{%sn} == %d) {\n",
            symbol_prefix, nrules - 2);
    }
  } else {
    {
#line 1386
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"case %d:\n",
            nrules - 2);
    }
  }
#line 1387
  if (! lflag) {
    {
#line 1388
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)(line_format),
            lineno, input_file_name);
    }
  }
#line 1389
  if ((int )*cptr == 61) {
#line 1389
    cptr ++;
  }
#line 1391
  n = 0;
#line 1392
  i = nitems - 1;
  {
#line 1392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1392
    if (! *(pitem + i)) {
#line 1392
      goto while_break;
    }
#line 1392
    n ++;
#line 1392
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1394
  depth = 0;
  loop: 
#line 1396
  c = (int )*cptr;
#line 1397
  if (c == 36) {
#line 1399
    if ((int )*(cptr + 1) == 60) {
      {
#line 1401
      d_lineno = lineno;
#line 1402
      tmp___0 = dup_line();
#line 1402
      d_line = tmp___0;
#line 1403
      d_cptr = d_line + (cptr - line);
#line 1405
      cptr ++;
#line 1406
      tag = get_tag();
#line 1407
      c = (int )*cptr;
      }
#line 1408
      if (c == 36) {
#line 1410
        if ((unsigned int )language == 1U) {
          {
#line 1411
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"$p->{%sval}",
                  symbol_prefix);
          }
        } else {
          {
#line 1413
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%sval.%s",
                  symbol_prefix, tag);
          }
        }
        {
#line 1414
        cptr ++;
#line 1415
        free((void *)d_line);
        }
#line 1416
        goto loop;
      } else {
        {
#line 1418
        tmp___3 = __ctype_b_loc();
        }
#line 1418
        if ((int const   )*(*tmp___3 + c) & 2048) {
          {
#line 1420
          i = get_number();
          }
#line 1421
          if (i > n) {
            {
#line 1421
            dollar_warning(d_lineno, i);
            }
          }
#line 1422
          if ((unsigned int )language == 1U) {
            {
#line 1423
            fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"$p->{%svs}->[$p->{%svsp}-%d]",
                    symbol_prefix, symbol_prefix, n - i);
            }
          } else {
            {
#line 1426
            fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%svsp[%d].%s",
                    symbol_prefix, i - n, tag);
            }
          }
          {
#line 1427
          free((void *)d_line);
          }
#line 1428
          goto loop;
        } else
#line 1430
        if (c == 45) {
          {
#line 1430
          tmp___2 = __ctype_b_loc();
          }
#line 1430
          if ((int const   )*(*tmp___2 + (int )*(cptr + 1)) & 2048) {
            {
#line 1432
            cptr ++;
#line 1433
            tmp___1 = get_number();
#line 1433
            i = - tmp___1 - n;
            }
#line 1434
            if ((unsigned int )language == 1U) {
              {
#line 1435
              fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"$p->{%svsp}->[$p->{%svsp}-%d]",
                      symbol_prefix, symbol_prefix, - i);
              }
            } else {
              {
#line 1438
              fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%svsp[%d].%s",
                      symbol_prefix, i, tag);
              }
            }
            {
#line 1439
            free((void *)d_line);
            }
#line 1440
            goto loop;
          } else {
            {
#line 1443
            dollar_error(d_lineno, d_line, d_cptr);
            }
          }
        } else {
          {
#line 1443
          dollar_error(d_lineno, d_line, d_cptr);
          }
        }
      }
    } else
#line 1445
    if ((int )*(cptr + 1) == 36) {
#line 1447
      if (ntags) {
#line 1449
        tag = (*(plhs + nrules))->tag;
#line 1450
        if ((unsigned long )tag == (unsigned long )((char *)0)) {
          {
#line 1450
          untyped_lhs();
          }
        }
#line 1451
        if ((unsigned int )language == 1U) {
          {
#line 1452
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"$p->{%sval}",
                  symbol_prefix);
          }
        } else {
          {
#line 1454
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%sval.%s",
                  symbol_prefix, tag);
          }
        }
      } else
#line 1456
      if ((unsigned int )language == 1U) {
        {
#line 1457
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"$p->{%sval}",
                symbol_prefix);
        }
      } else {
        {
#line 1459
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%sval",
                symbol_prefix);
        }
      }
#line 1460
      cptr += 2;
#line 1461
      goto loop;
    } else {
      {
#line 1463
      tmp___4 = __ctype_b_loc();
      }
#line 1463
      if ((int const   )*(*tmp___4 + (int )*(cptr + 1)) & 2048) {
        {
#line 1465
        cptr ++;
#line 1466
        i = get_number();
        }
#line 1467
        if (ntags) {
#line 1469
          if (i <= 0) {
            {
#line 1470
            unknown_rhs(i);
            }
          } else
#line 1469
          if (i > n) {
            {
#line 1470
            unknown_rhs(i);
            }
          }
#line 1471
          tag = (*(pitem + (((nitems + i) - n) - 1)))->tag;
#line 1472
          if ((unsigned long )tag == (unsigned long )((char *)0)) {
            {
#line 1472
            untyped_rhs(i, (*(pitem + (((nitems + i) - n) - 1)))->name);
            }
          }
#line 1473
          if ((unsigned int )language == 1U) {
            {
#line 1474
            fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"$p->{%svs}->[$p->{%svsp}-%d]",
                    symbol_prefix, symbol_prefix, n - i);
            }
          } else {
            {
#line 1477
            fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%svsp[%d].%s",
                    symbol_prefix, i - n, tag);
            }
          }
        } else {
#line 1481
          if (i > n) {
            {
#line 1482
            dollar_warning(lineno, i);
            }
          }
#line 1483
          if ((unsigned int )language == 1U) {
            {
#line 1484
            fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"$p->{%svs}->[$p->{%svsp}-%d]",
                    symbol_prefix, symbol_prefix, n - i);
            }
          } else {
            {
#line 1487
            fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%svsp[%d]",
                    symbol_prefix, i - n);
            }
          }
        }
#line 1489
        goto loop;
      } else
#line 1491
      if ((int )*(cptr + 1) == 45) {
        {
#line 1493
        cptr += 2;
#line 1494
        i = get_number();
        }
#line 1495
        if (ntags) {
          {
#line 1496
          unknown_rhs(- i);
          }
        }
#line 1497
        if ((unsigned int )language == 1U) {
          {
#line 1498
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"$p->{%svs}->[$p->{%svsp}-%d]",
                  symbol_prefix, symbol_prefix, i + n);
          }
        } else {
          {
#line 1501
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%svsp[%d]",
                  symbol_prefix, - i - n);
          }
        }
#line 1502
        goto loop;
      }
    }
  }
  {
#line 1505
  tmp___6 = __ctype_b_loc();
  }
#line 1505
  if ((int const   )*(*tmp___6 + c) & 1024) {
#line 1505
    goto _L;
  } else
#line 1505
  if (c == 95) {
#line 1505
    goto _L;
  } else
#line 1505
  if ((unsigned int )language == 0U) {
#line 1505
    if (c == 36) {
      _L: /* CIL Label */ 
      {
#line 1507
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1509
        _IO_putc(c, f);
#line 1510
        cptr ++;
#line 1510
        c = (int )*cptr;
#line 1507
        tmp___5 = __ctype_b_loc();
        }
#line 1507
        if (! ((int const   )*(*tmp___5 + c) & 8)) {
#line 1507
          if (! (c == 95)) {
#line 1507
            if ((unsigned int )language == 0U) {
#line 1507
              if (! (c == 36)) {
#line 1507
                goto while_break___0;
              }
            } else {
#line 1507
              goto while_break___0;
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1512
      goto loop;
    }
  }
#line 1514
  cptr ++;
  {
#line 1517
  if (c == 10) {
#line 1517
    goto case_10;
  }
#line 1524
  if (c == 59) {
#line 1524
    goto case_59;
  }
#line 1534
  if (c == 123) {
#line 1534
    goto case_123;
  }
#line 1539
  if (c == 125) {
#line 1539
    goto case_125;
  }
#line 1553
  if (c == 34) {
#line 1553
    goto case_34;
  }
#line 1553
  if (c == 39) {
#line 1553
    goto case_34;
  }
#line 1586
  if (c == 47) {
#line 1586
    goto case_47;
  }
#line 1650
  if (c == 35) {
#line 1650
    goto perl_comment;
  }
#line 1666
  goto switch_default;
  case_10: /* CIL Label */ 
  {
#line 1518
  _IO_putc(c, f);
  }
  next_line: 
  {
#line 1520
  get_line();
  }
#line 1521
  if (line) {
#line 1521
    goto loop;
  }
  {
#line 1522
  unterminated_action(a_lineno, a_line, a_cptr);
  }
  case_59: /* CIL Label */ 
  {
#line 1525
  _IO_putc(c, f);
  }
#line 1526
  if (depth > 0) {
#line 1526
    goto loop;
  }
#line 1527
  if ((unsigned int )language == 1U) {
    {
#line 1528
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n}\n");
    }
  } else {
    {
#line 1530
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\nbreak;\n");
    }
  }
  {
#line 1531
  free((void *)a_line);
  }
#line 1532
  return;
  case_123: /* CIL Label */ 
  {
#line 1535
  _IO_putc(c, f);
#line 1536
  depth ++;
  }
#line 1537
  goto loop;
  case_125: /* CIL Label */ 
#line 1540
  depth --;
#line 1540
  if (depth > 0) {
    {
#line 1541
    _IO_putc(c, f);
    }
#line 1542
    goto loop;
  }
#line 1545
  if ((unsigned int )language == 1U) {
    {
#line 1546
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"}\n}\n");
    }
  } else {
    {
#line 1548
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"}\nbreak;\n");
    }
  }
  {
#line 1549
  free((void *)a_line);
  }
#line 1550
  return;
  case_34: /* CIL Label */ 
  case_39: /* CIL Label */ 
  {
#line 1555
  s_lineno = lineno;
#line 1556
  tmp___7 = dup_line();
#line 1556
  s_line = tmp___7;
#line 1557
  s_cptr = s_line + ((cptr - line) - 1L);
#line 1559
  _IO_putc(c, f);
#line 1560
  quote = c;
  }
  {
#line 1561
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1563
    tmp___8 = cptr;
#line 1563
    cptr ++;
#line 1563
    c = (int )*tmp___8;
#line 1564
    _IO_putc(c, f);
    }
#line 1565
    if (c == quote) {
      {
#line 1567
      free((void *)s_line);
      }
#line 1568
      goto loop;
    }
#line 1570
    if (c == 10) {
      {
#line 1571
      unterminated_string(s_lineno, s_line, s_cptr);
      }
    }
#line 1572
    if (c == 92) {
      {
#line 1574
      tmp___9 = cptr;
#line 1574
      cptr ++;
#line 1574
      c = (int )*tmp___9;
#line 1575
      _IO_putc(c, f);
      }
#line 1576
      if (c == 10) {
        {
#line 1578
        get_line();
        }
#line 1579
        if ((unsigned long )line == (unsigned long )((char *)0)) {
          {
#line 1580
          unterminated_string(s_lineno, s_line, s_cptr);
          }
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  case_47: /* CIL Label */ 
#line 1587
  c = (int )*cptr;
#line 1588
  if (c == 47) {
#line 1590
    if ((unsigned int )language == 1U) {
#line 1591
      cptr ++;
#line 1592
      goto perl_comment;
    }
    {
#line 1594
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"/*");
    }
    {
#line 1595
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1595
      cptr ++;
#line 1595
      c = (int )*cptr;
#line 1595
      if (! (c != 10)) {
#line 1595
        goto while_break___2;
      }
#line 1597
      if (c == 42) {
#line 1597
        if ((int )*(cptr + 1) == 47) {
          {
#line 1598
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"* ");
          }
        } else {
          {
#line 1600
          _IO_putc(c, f);
          }
        }
      } else {
        {
#line 1600
        _IO_putc(c, f);
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1602
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*/\n");
    }
#line 1603
    goto next_line;
  }
#line 1605
  if (c != 42) {
    {
#line 1607
    _IO_putc('/', f);
    }
  } else {
    {
#line 1611
    c_lineno = lineno;
#line 1612
    tmp___10 = dup_line();
#line 1612
    c_line = tmp___10;
#line 1613
    c_cptr = c_line + ((cptr - line) - 1L);
    }
#line 1615
    if ((unsigned int )language == 1U) {
#line 1616
      if ((unsigned long )cptr == (unsigned long )(line + 1)) {
#line 1616
        tmp___11 = ";#";
      } else {
#line 1616
        tmp___11 = "#";
      }
      {
#line 1616
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)tmp___11);
      }
    } else {
      {
#line 1618
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"/*");
      }
    }
#line 1619
    cptr ++;
    {
#line 1620
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1622
      tmp___12 = cptr;
#line 1622
      cptr ++;
#line 1622
      c = (int )*tmp___12;
#line 1623
      if ((unsigned int )language == 1U) {
#line 1623
        if (c == 42) {
#line 1623
          if ((int )*cptr == 47) {
            {
#line 1625
            _IO_putc('\n', f);
#line 1626
            cptr ++;
#line 1627
            free((void *)c_line);
            }
#line 1628
            goto loop;
          }
        }
      }
      {
#line 1630
      _IO_putc(c, f);
      }
#line 1631
      if (c == 42) {
#line 1631
        if ((int )*cptr == 47) {
          {
#line 1633
          _IO_putc('/', f);
#line 1634
          cptr ++;
#line 1635
          free((void *)c_line);
          }
#line 1636
          goto loop;
        }
      }
#line 1638
      if (c == 10) {
        {
#line 1640
        get_line();
        }
#line 1641
        if ((unsigned long )line == (unsigned long )((char *)0)) {
          {
#line 1642
          unterminated_comment(c_lineno, c_line, c_cptr);
          }
        }
#line 1643
        if ((unsigned int )language == 1U) {
          {
#line 1644
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)";# ");
          }
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1648
  goto loop;
  perl_comment: 
  case_35: /* CIL Label */ 
#line 1652
  if ((unsigned int )language == 1U) {
    {
#line 1654
    _IO_putc('#', f);
    }
    {
#line 1655
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1656
      _IO_putc((int )*cptr, f);
#line 1655
      tmp___13 = cptr;
#line 1655
      cptr ++;
      }
#line 1655
      if (! ((int )*tmp___13 != 10)) {
#line 1655
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1658
    goto next_line;
  } else {
    {
#line 1662
    _IO_putc(c, f);
    }
  }
#line 1664
  goto loop;
  switch_default: /* CIL Label */ 
  {
#line 1667
  _IO_putc(c, f);
  }
#line 1668
  goto loop;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1676 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static int mark_symbol(void) 
{ 
  register int c ;
  register bucket *bp ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 1684
  c = (int )*(cptr + 1);
#line 1685
  if (c == 37) {
#line 1687
    cptr += 2;
#line 1688
    return (1);
  } else
#line 1685
  if (c == 92) {
#line 1687
    cptr += 2;
#line 1688
    return (1);
  }
#line 1691
  if (c == 61) {
#line 1692
    cptr += 2;
  } else
#line 1693
  if (c == 112) {
#line 1693
    goto _L___2;
  } else
#line 1693
  if (c == 80) {
    _L___2: /* CIL Label */ 
#line 1693
    c = (int )*(cptr + 2);
#line 1693
    if (c == 114) {
#line 1693
      goto _L___1;
    } else
#line 1693
    if (c == 82) {
      _L___1: /* CIL Label */ 
#line 1693
      c = (int )*(cptr + 3);
#line 1693
      if (c == 101) {
#line 1693
        goto _L___0;
      } else
#line 1693
      if (c == 69) {
        _L___0: /* CIL Label */ 
#line 1693
        c = (int )*(cptr + 4);
#line 1693
        if (c == 99) {
#line 1693
          goto _L;
        } else
#line 1693
        if (c == 67) {
          _L: /* CIL Label */ 
          {
#line 1693
          c = (int )*(cptr + 5);
#line 1693
          tmp = __ctype_b_loc();
          }
#line 1693
          if ((int const   )*(*tmp + c) & 8) {
#line 1693
            tmp___0 = 0;
          } else
#line 1693
          if (c == 95) {
#line 1693
            tmp___0 = 0;
          } else
#line 1693
          if (c == 46) {
#line 1693
            tmp___0 = 0;
          } else
#line 1693
          if (c == 36) {
#line 1693
            tmp___0 = 0;
          } else {
#line 1693
            tmp___0 = 1;
          }
#line 1693
          if (tmp___0) {
#line 1698
            cptr += 5;
          } else {
            {
#line 1700
            syntax_error(lineno, line, cptr);
            }
          }
        } else {
          {
#line 1700
          syntax_error(lineno, line, cptr);
          }
        }
      } else {
        {
#line 1700
        syntax_error(lineno, line, cptr);
        }
      }
    } else {
      {
#line 1700
      syntax_error(lineno, line, cptr);
      }
    }
  } else {
    {
#line 1700
    syntax_error(lineno, line, cptr);
    }
  }
  {
#line 1702
  c = nextc();
#line 1703
  tmp___1 = __ctype_b_loc();
  }
#line 1703
  if ((int const   )*(*tmp___1 + c) & 1024) {
    {
#line 1704
    bp = get_name();
    }
  } else
#line 1703
  if (c == 95) {
    {
#line 1704
    bp = get_name();
    }
  } else
#line 1703
  if (c == 46) {
    {
#line 1704
    bp = get_name();
    }
  } else
#line 1703
  if ((unsigned int )language == 0U) {
#line 1703
    if (c == 36) {
      {
#line 1704
      bp = get_name();
      }
    } else {
#line 1703
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 1705
  if (c == 39) {
    {
#line 1706
    bp = get_literal();
    }
  } else
#line 1705
  if (c == 34) {
    {
#line 1706
    bp = get_literal();
    }
  } else {
    {
#line 1709
    syntax_error(lineno, line, cptr);
    }
  }
#line 1713
  if ((int )*(rprec + nrules) != -1) {
#line 1713
    if ((int )bp->prec != (int )*(rprec + nrules)) {
      {
#line 1714
      prec_redeclared();
      }
    }
  }
#line 1716
  *(rprec + nrules) = bp->prec;
#line 1717
  *(rassoc + nrules) = bp->assoc;
#line 1718
  return (0);
}
}
#line 1723 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void read_grammar(void) 
{ 
  register int c ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 1730
  initialize_grammar();
#line 1731
  advance_to_start();
  }
  {
#line 1733
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1735
    c = nextc();
    }
#line 1736
    if (c == -1) {
#line 1736
      goto while_break;
    }
    {
#line 1737
    tmp___0 = __ctype_b_loc();
    }
#line 1737
    if ((int const   )*(*tmp___0 + c) & 1024) {
      {
#line 1739
      add_symbol();
      }
    } else
#line 1737
    if (c == 95) {
      {
#line 1739
      add_symbol();
      }
    } else
#line 1737
    if (c == 46) {
      {
#line 1739
      add_symbol();
      }
    } else
#line 1737
    if ((unsigned int )language == 0U) {
#line 1737
      if (c == 36) {
        {
#line 1739
        add_symbol();
        }
      } else {
#line 1737
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1737
    if (c == 39) {
      {
#line 1739
      add_symbol();
      }
    } else
#line 1737
    if (c == 34) {
      {
#line 1739
      add_symbol();
      }
    } else
#line 1740
    if (c == 123) {
      {
#line 1741
      copy_action();
      }
    } else
#line 1740
    if (c == 61) {
      {
#line 1741
      copy_action();
      }
    } else
#line 1742
    if (c == 124) {
      {
#line 1744
      end_rule();
#line 1745
      start_rule(*(plhs + (nrules - 1)), 0);
#line 1746
      cptr ++;
      }
    } else
#line 1748
    if (c == 37) {
      {
#line 1750
      tmp = mark_symbol();
      }
#line 1750
      if (tmp) {
#line 1750
        goto while_break;
      }
    } else {
      {
#line 1753
      syntax_error(lineno, line, cptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1755
  end_rule();
  }
#line 1756
  return;
}
}
#line 1760 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void free_tags(void) 
{ 
  register int i ;

  {
#line 1767
  if ((unsigned long )tag_table == (unsigned long )((char **)0)) {
#line 1767
    return;
  }
#line 1769
  i = 0;
  {
#line 1769
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1769
    if (! (i < ntags)) {
#line 1769
      goto while_break;
    }
#line 1771
    if (! ((unsigned long )*(tag_table + i) != (unsigned long )((char *)((void *)0)))) {
      {
#line 1771
      __assert_fail("tag_table[i] != (char *) ((void *)0)", "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c",
                    1771U, "free_tags");
      }
    }
    {
#line 1772
    free((void *)*(tag_table + i));
#line 1769
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1774
  free((void *)((char *)tag_table));
  }
#line 1775
  return;
}
}
#line 1779 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void pack_names(void) 
{ 
  register bucket *bp ;
  register char *p ;
  register char *s ;
  register char *t ;
  size_t tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char *tmp___2 ;

  {
#line 1787
  name_pool_size = (int )(sizeof("$end") + sizeof("$accept"));
#line 1788
  bp = first_symbol;
  {
#line 1788
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1788
    if (! bp) {
#line 1788
      goto while_break;
    }
    {
#line 1789
    tmp = strlen((char const   *)bp->name);
#line 1789
    name_pool_size = (int )((size_t )name_pool_size + (tmp + 1UL));
#line 1788
    bp = bp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1790
  name_pool = my_malloc((unsigned int )name_pool_size);
#line 1792
  strcpy((char */* __restrict  */)name_pool, (char const   */* __restrict  */)"$accept");
#line 1793
  strcpy((char */* __restrict  */)(name_pool + sizeof("$accept")), (char const   */* __restrict  */)"$end");
#line 1794
  t = (name_pool + sizeof("$end")) + sizeof("$accept");
#line 1795
  bp = first_symbol;
  }
  {
#line 1795
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1795
    if (! bp) {
#line 1795
      goto while_break___0;
    }
#line 1797
    p = t;
#line 1798
    s = bp->name;
    {
#line 1799
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1799
      tmp___0 = t;
#line 1799
      t ++;
#line 1799
      tmp___2 = s;
#line 1799
      s ++;
#line 1799
      tmp___1 = *tmp___2;
#line 1799
      *tmp___0 = tmp___1;
#line 1799
      if (! tmp___1) {
#line 1799
        goto while_break___1;
      }
#line 1799
      goto while_continue___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1800
    free((void *)bp->name);
#line 1801
    bp->name = p;
#line 1795
    bp = bp->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1803
  return;
}
}
#line 1807 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void check_symbols(void) 
{ 
  register bucket *bp ;

  {
#line 1814
  if ((int )goal->class == 0) {
    {
#line 1815
    undefined_goal(goal->name);
    }
  }
#line 1817
  bp = first_symbol;
  {
#line 1817
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1817
    if (! bp) {
#line 1817
      goto while_break;
    }
#line 1819
    if ((int )bp->class == 0) {
      {
#line 1821
      undefined_symbol_warning(bp->name);
#line 1822
      bp->class = (char)1;
      }
    }
#line 1817
    bp = bp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1825
  return;
}
}
#line 1829 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void pack_symbols(void) 
{ 
  register bucket *bp ;
  register bucket **v ;
  register int i ;
  register int j ;
  register int k ;
  register int n ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1838
  nsyms = 2;
#line 1839
  ntokens = 1;
#line 1840
  bp = first_symbol;
  {
#line 1840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1840
    if (! bp) {
#line 1840
      goto while_break;
    }
#line 1842
    nsyms ++;
#line 1843
    if ((int )bp->class == 1) {
#line 1843
      ntokens ++;
    }
#line 1840
    bp = bp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1845
  start_symbol = ntokens;
#line 1846
  nvars = nsyms - ntokens;
#line 1848
  tmp = my_malloc((unsigned int )((unsigned long )nsyms * sizeof(char *)));
#line 1848
  symbol_name = (char **)tmp;
#line 1849
  tmp___0 = my_malloc((unsigned int )((unsigned long )nsyms * sizeof(short )));
#line 1849
  symbol_value = (short *)tmp___0;
#line 1850
  tmp___1 = my_malloc((unsigned int )((unsigned long )nsyms * sizeof(short )));
#line 1850
  symbol_prec = (short *)tmp___1;
#line 1851
  symbol_assoc = my_malloc((unsigned int )nsyms);
#line 1853
  tmp___2 = my_malloc((unsigned int )((unsigned long )nsyms * sizeof(bucket *)));
#line 1853
  v = (bucket **)tmp___2;
#line 1855
  *(v + 0) = (bucket *)0;
#line 1856
  *(v + start_symbol) = (bucket *)0;
#line 1858
  i = 1;
#line 1859
  j = start_symbol + 1;
#line 1860
  bp = first_symbol;
  }
  {
#line 1860
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1860
    if (! bp) {
#line 1860
      goto while_break___0;
    }
#line 1862
    if ((int )bp->class == 1) {
#line 1863
      tmp___3 = i;
#line 1863
      i ++;
#line 1863
      *(v + tmp___3) = bp;
    } else {
#line 1865
      tmp___4 = j;
#line 1865
      j ++;
#line 1865
      *(v + tmp___4) = bp;
    }
#line 1860
    bp = bp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1867
  if (i == ntokens) {
#line 1867
    if (! (j == nsyms)) {
      {
#line 1867
      __assert_fail("i == ntokens && j == nsyms", "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c",
                    1867U, "pack_symbols");
      }
    }
  } else {
    {
#line 1867
    __assert_fail("i == ntokens && j == nsyms", "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c",
                  1867U, "pack_symbols");
    }
  }
#line 1869
  i = 1;
  {
#line 1869
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1869
    if (! (i < ntokens)) {
#line 1869
      goto while_break___1;
    }
#line 1870
    (*(v + i))->index = (short )i;
#line 1869
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1872
  goal->index = (short )(start_symbol + 1);
#line 1873
  k = start_symbol + 2;
  {
#line 1874
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1874
    i ++;
#line 1874
    if (! (i < nsyms)) {
#line 1874
      goto while_break___2;
    }
#line 1875
    if ((unsigned long )*(v + i) != (unsigned long )goal) {
#line 1877
      (*(v + i))->index = (short )k;
#line 1878
      k ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1881
  goal->value = (short)0;
#line 1882
  k = 1;
#line 1883
  i = start_symbol + 1;
  {
#line 1883
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1883
    if (! (i < nsyms)) {
#line 1883
      goto while_break___3;
    }
#line 1885
    if ((unsigned long )*(v + i) != (unsigned long )goal) {
#line 1887
      (*(v + i))->value = (short )k;
#line 1888
      k ++;
    }
#line 1883
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1892
  k = 0;
#line 1893
  i = 1;
  {
#line 1893
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1893
    if (! (i < ntokens)) {
#line 1893
      goto while_break___4;
    }
#line 1895
    n = (int )(*(v + i))->value;
#line 1896
    if (n > 256) {
#line 1898
      tmp___5 = k;
#line 1898
      k ++;
#line 1898
      j = tmp___5;
      {
#line 1898
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1898
        if (j > 0) {
#line 1898
          if (! ((int )*(symbol_value + (j - 1)) > n)) {
#line 1898
            goto while_break___5;
          }
        } else {
#line 1898
          goto while_break___5;
        }
#line 1899
        *(symbol_value + j) = *(symbol_value + (j - 1));
#line 1898
        j --;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1900
      *(symbol_value + j) = (short )n;
    }
#line 1893
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1904
  if ((int )(*(v + 1))->value == -1) {
#line 1905
    (*(v + 1))->value = (short)256;
  }
#line 1907
  j = 0;
#line 1908
  n = 257;
#line 1909
  i = 2;
  {
#line 1909
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1909
    if (! (i < ntokens)) {
#line 1909
      goto while_break___6;
    }
#line 1911
    if ((int )(*(v + i))->value == -1) {
      {
#line 1913
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1913
        if (j < k) {
#line 1913
          if (! (n == (int )*(symbol_value + j))) {
#line 1913
            goto while_break___7;
          }
        } else {
#line 1913
          goto while_break___7;
        }
        {
#line 1915
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1915
          j ++;
#line 1915
          if (j < k) {
#line 1915
            if (! (n == (int )*(symbol_value + j))) {
#line 1915
              goto while_break___8;
            }
          } else {
#line 1915
            goto while_break___8;
          }
#line 1915
          goto while_continue___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 1916
        n ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1918
      (*(v + i))->value = (short )n;
#line 1919
      n ++;
    }
#line 1909
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1923
  *(symbol_name + 0) = name_pool + 8;
#line 1924
  *(symbol_value + 0) = (short)0;
#line 1925
  *(symbol_prec + 0) = (short)0;
#line 1926
  *(symbol_assoc + 0) = (char)0;
#line 1927
  i = 1;
  {
#line 1927
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1927
    if (! (i < ntokens)) {
#line 1927
      goto while_break___9;
    }
#line 1929
    *(symbol_name + i) = (*(v + i))->name;
#line 1930
    *(symbol_value + i) = (*(v + i))->value;
#line 1931
    *(symbol_prec + i) = (*(v + i))->prec;
#line 1932
    *(symbol_assoc + i) = (*(v + i))->assoc;
#line 1927
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 1934
  *(symbol_name + start_symbol) = name_pool;
#line 1935
  *(symbol_value + start_symbol) = (short)-1;
#line 1936
  *(symbol_prec + start_symbol) = (short)0;
#line 1937
  *(symbol_assoc + start_symbol) = (char)0;
#line 1938
  i ++;
  {
#line 1938
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 1938
    if (! (i < nsyms)) {
#line 1938
      goto while_break___10;
    }
#line 1940
    k = (int )(*(v + i))->index;
#line 1941
    *(symbol_name + k) = (*(v + i))->name;
#line 1942
    *(symbol_value + k) = (*(v + i))->value;
#line 1943
    *(symbol_prec + k) = (*(v + i))->prec;
#line 1944
    *(symbol_assoc + k) = (*(v + i))->assoc;
#line 1938
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 1947
  free((void *)((char *)v));
  }
#line 1948
  return;
}
}
#line 1952 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void pack_grammar(void) 
{ 
  register int i ;
  register int j ;
  int assoc ;
  int prec___0 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1960
  tmp = my_malloc((unsigned int )((unsigned long )nitems * sizeof(short )));
#line 1960
  ritem = (short *)tmp;
#line 1961
  tmp___0 = my_malloc((unsigned int )((unsigned long )nrules * sizeof(short )));
#line 1961
  rlhs = (short *)tmp___0;
#line 1962
  tmp___1 = my_malloc((unsigned int )((unsigned long )(nrules + 1) * sizeof(short )));
#line 1962
  rrhs = (short *)tmp___1;
#line 1963
  tmp___2 = my_realloc((char *)rprec, (unsigned int )((unsigned long )nrules * sizeof(short )));
#line 1963
  rprec = (short *)tmp___2;
#line 1964
  rassoc = my_realloc(rassoc, (unsigned int )nrules);
#line 1966
  *(ritem + 0) = (short)-1;
#line 1967
  *(ritem + 1) = goal->index;
#line 1968
  *(ritem + 2) = (short)0;
#line 1969
  *(ritem + 3) = (short)-2;
#line 1970
  *(rlhs + 0) = (short)0;
#line 1971
  *(rlhs + 1) = (short)0;
#line 1972
  *(rlhs + 2) = (short )start_symbol;
#line 1973
  *(rrhs + 0) = (short)0;
#line 1974
  *(rrhs + 1) = (short)0;
#line 1975
  *(rrhs + 2) = (short)1;
#line 1977
  j = 4;
#line 1978
  i = 3;
  }
  {
#line 1978
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1978
    if (! (i < nrules)) {
#line 1978
      goto while_break;
    }
#line 1980
    *(rlhs + i) = (*(plhs + i))->index;
#line 1981
    *(rrhs + i) = (short )j;
#line 1982
    assoc = 0;
#line 1983
    prec___0 = 0;
    {
#line 1984
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1984
      if (! *(pitem + j)) {
#line 1984
        goto while_break___0;
      }
#line 1986
      *(ritem + j) = (*(pitem + j))->index;
#line 1987
      if ((int )(*(pitem + j))->class == 1) {
#line 1989
        prec___0 = (int )(*(pitem + j))->prec;
#line 1990
        assoc = (int )(*(pitem + j))->assoc;
      }
#line 1992
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1994
    *(ritem + j) = (short )(- i);
#line 1995
    j ++;
#line 1996
    if ((int )*(rprec + i) == -1) {
#line 1998
      *(rprec + i) = (short )prec___0;
#line 1999
      *(rassoc + i) = (char )assoc;
    }
#line 1978
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2002
  *(rrhs + i) = (short )j;
#line 2004
  free((void *)((char *)plhs));
#line 2005
  free((void *)((char *)pitem));
  }
#line 2006
  return;
}
}
#line 2010 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
static void print_grammar(void) 
{ 
  register int i ;
  register int j ;
  register int k ;
  int spacing ;
  register FILE *f ;
  size_t tmp ;

  {
#line 2017
  f = verbose_file;
#line 2019
  if (! vflag) {
#line 2019
    return;
  }
#line 2021
  k = 1;
#line 2022
  i = 2;
  {
#line 2022
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2022
    if (! (i < nrules)) {
#line 2022
      goto while_break;
    }
#line 2024
    if ((int )*(rlhs + i) != (int )*(rlhs + (i - 1))) {
#line 2026
      if (i != 2) {
        {
#line 2026
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
        }
      }
      {
#line 2027
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%4d  %s :",
              i - 2, *(symbol_name + *(rlhs + i)));
#line 2028
      tmp = strlen((char const   *)*(symbol_name + *(rlhs + i)));
#line 2028
      spacing = (int )(tmp + 1UL);
      }
    } else {
      {
#line 2032
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%4d  ",
              i - 2);
#line 2033
      j = spacing;
      }
      {
#line 2034
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2034
        j --;
#line 2034
        if (! (j >= 0)) {
#line 2034
          goto while_break___0;
        }
        {
#line 2034
        _IO_putc(' ', f);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2035
      _IO_putc('|', f);
      }
    }
    {
#line 2038
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2038
      if (! ((int )*(ritem + k) >= 0)) {
#line 2038
        goto while_break___1;
      }
      {
#line 2040
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %s",
              *(symbol_name + *(ritem + k)));
#line 2041
      k ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2043
    k ++;
#line 2044
    _IO_putc('\n', f);
#line 2022
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2046
  return;
}
}
#line 2050 "/home/wheatley/newnew/temp/perl-byacc-2.0/reader.c"
void reader(void) 
{ 


  {
  {
#line 2055
  write_section(banner);
  }
#line 2056
  if ((unsigned int )language == 1U) {
    {
#line 2057
    fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"package %s;\n",
            perl_package);
    }
  }
  {
#line 2058
  create_symbol_table();
#line 2059
  read_declarations();
#line 2060
  read_grammar();
#line 2061
  free_symbol_table();
#line 2062
  free_tags();
#line 2063
  pack_names();
#line 2064
  check_symbols();
#line 2065
  pack_symbols();
#line 2066
  pack_grammar();
#line 2067
  free_symbols();
#line 2068
  print_grammar();
  }
#line 2069
  return;
}
}
#line 12 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static core **state_set___0  ;
#line 13 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static core *this_state___0  ;
#line 14 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static core *last_state___0  ;
#line 15 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static shifts *last_shift___0  ;
#line 16 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static reductions *last_reduction___0  ;
#line 18 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static int nshifts___0  ;
#line 19 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static short *shift_symbol___0  ;
#line 21 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static short *redset___0  ;
#line 22 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static short *shiftset___0  ;
#line 24 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static short **kernel_base___0  ;
#line 25 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static short **kernel_end___0  ;
#line 26 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static short *kernel_items___0  ;
#line 28
static void allocate_itemsets___0(void) ;
#line 29
static void allocate_storage___0(void) ;
#line 30
static void append_states___0(void) ;
#line 31
static void free_storage___0(void) ;
#line 32
static void generate_states___0(void) ;
#line 33
static int get_state___0(int symbol ) ;
#line 34
static void initialize_states___0(void) ;
#line 35
static void new_itemsets___0(void) ;
#line 36
static core *new_state___0(int symbol ) ;
#line 37
static void save_shifts___0(void) ;
#line 38
static void save_reductions___0(void) ;
#line 39
static void set_derives___0(void) ;
#line 40
static void set_nullable___0(void) ;
#line 50 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void allocate_itemsets___0(void) 
{ 
  register short *itemp ;
  register short *item_end ;
  register int symbol ;
  register int i ;
  register int count ;
  register int max ;
  register short *symbol_count ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 60
  count = 0;
#line 61
  tmp = allocate((unsigned int )((unsigned long )nsyms * sizeof(short )));
#line 61
  symbol_count = (short *)tmp;
#line 63
  item_end = ritem + nitems;
#line 64
  itemp = ritem;
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! ((unsigned long )itemp < (unsigned long )item_end)) {
#line 64
      goto while_break;
    }
#line 66
    symbol = (int )*itemp;
#line 67
    if (symbol >= 0) {
#line 69
      count ++;
#line 70
      *(symbol_count + symbol) = (short )((int )*(symbol_count + symbol) + 1);
    }
#line 64
    itemp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 74
  tmp___0 = allocate((unsigned int )((unsigned long )nsyms * sizeof(short *)));
#line 74
  kernel_base___0 = (short **)tmp___0;
#line 75
  tmp___1 = allocate((unsigned int )((unsigned long )count * sizeof(short )));
#line 75
  kernel_items___0 = (short *)tmp___1;
#line 77
  count = 0;
#line 78
  max = 0;
#line 79
  i = 0;
  }
  {
#line 79
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 79
    if (! (i < nsyms)) {
#line 79
      goto while_break___0;
    }
#line 81
    *(kernel_base___0 + i) = kernel_items___0 + count;
#line 82
    count += (int )*(symbol_count + i);
#line 83
    if (max < (int )*(symbol_count + i)) {
#line 84
      max = (int )*(symbol_count + i);
    }
#line 79
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 87
  shift_symbol___0 = symbol_count;
#line 88
  tmp___2 = allocate((unsigned int )((unsigned long )nsyms * sizeof(short *)));
#line 88
  kernel_end___0 = (short **)tmp___2;
  }
#line 89
  return;
}
}
#line 92 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void allocate_storage___0(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 94
  allocate_itemsets___0();
#line 95
  tmp = allocate((unsigned int )((unsigned long )nsyms * sizeof(short )));
#line 95
  shiftset___0 = (short *)tmp;
#line 96
  tmp___0 = allocate((unsigned int )((unsigned long )(nrules + 1) * sizeof(short )));
#line 96
  redset___0 = (short *)tmp___0;
#line 97
  tmp___1 = allocate((unsigned int )((unsigned long )nitems * sizeof(core *)));
#line 97
  state_set___0 = (core **)tmp___1;
  }
#line 98
  return;
}
}
#line 101 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void append_states___0(void) 
{ 
  register int i ;
  register int j ;
  register int symbol ;
  int tmp ;

  {
#line 110
  i = 1;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! (i < nshifts___0)) {
#line 110
      goto while_break;
    }
#line 112
    symbol = (int )*(shift_symbol___0 + i);
#line 113
    j = i;
    {
#line 114
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 114
      if (j > 0) {
#line 114
        if (! ((int )*(shift_symbol___0 + (j - 1)) > symbol)) {
#line 114
          goto while_break___0;
        }
      } else {
#line 114
        goto while_break___0;
      }
#line 116
      *(shift_symbol___0 + j) = *(shift_symbol___0 + (j - 1));
#line 117
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 119
    *(shift_symbol___0 + j) = (short )symbol;
#line 110
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  i = 0;
  {
#line 122
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 122
    if (! (i < nshifts___0)) {
#line 122
      goto while_break___1;
    }
    {
#line 124
    symbol = (int )*(shift_symbol___0 + i);
#line 125
    tmp = get_state___0(symbol);
#line 125
    *(shiftset___0 + i) = (short )tmp;
#line 122
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 127
  return;
}
}
#line 130 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void free_storage___0(void) 
{ 


  {
  {
#line 132
  free((void *)((char *)shift_symbol___0));
#line 133
  free((void *)((char *)redset___0));
#line 134
  free((void *)((char *)shiftset___0));
#line 135
  free((void *)((char *)kernel_base___0));
#line 136
  free((void *)((char *)kernel_end___0));
#line 137
  free((void *)((char *)kernel_items___0));
#line 138
  free((void *)((char *)state_set___0));
  }
#line 139
  return;
}
}
#line 143 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void generate_states___0(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 145
  allocate_storage___0();
#line 146
  tmp = allocate((unsigned int )((unsigned long )nitems * sizeof(short )));
#line 146
  itemset = (short *)tmp;
#line 147
  tmp___0 = allocate((unsigned int )((unsigned long )((nrules + 31) / 32) * sizeof(unsigned int )));
#line 147
  ruleset = (unsigned int *)tmp___0;
#line 148
  set_first_derives();
#line 149
  initialize_states___0();
  }
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! this_state___0) {
#line 151
      goto while_break;
    }
    {
#line 153
    closure(this_state___0->items, (int )this_state___0->nitems);
#line 154
    save_reductions___0();
#line 155
    new_itemsets___0();
#line 156
    append_states___0();
    }
#line 158
    if (nshifts___0 > 0) {
      {
#line 159
      save_shifts___0();
      }
    }
#line 161
    this_state___0 = this_state___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  finalize_closure();
#line 165
  free_storage___0();
  }
#line 166
  return;
}
}
#line 170 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static int get_state___0(int symbol ) 
{ 
  register int key ;
  register short *isp1 ;
  register short *isp2 ;
  register short *iend ;
  register core *sp ;
  register int found ;
  register int n ;
  short *tmp ;
  short *tmp___0 ;
  struct core *tmp___1 ;

  {
#line 185
  isp1 = *(kernel_base___0 + symbol);
#line 186
  iend = *(kernel_end___0 + symbol);
#line 187
  n = (int )(iend - isp1);
#line 189
  key = (int )*isp1;
#line 190
  if (0 <= key) {
#line 190
    if (! (key < nitems)) {
      {
#line 190
      __assert_fail("0 <= key && key < nitems", "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c",
                    190U, "get_state");
      }
    }
  } else {
    {
#line 190
    __assert_fail("0 <= key && key < nitems", "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c",
                  190U, "get_state");
    }
  }
#line 191
  sp = *(state_set___0 + key);
#line 192
  if (sp) {
#line 194
    found = 0;
    {
#line 195
    while (1) {
      while_continue: /* CIL Label */ ;
#line 195
      if (! (! found)) {
#line 195
        goto while_break;
      }
#line 197
      if ((int )sp->nitems == n) {
#line 199
        found = 1;
#line 200
        isp1 = *(kernel_base___0 + symbol);
#line 201
        isp2 = sp->items;
        {
#line 203
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 203
          if (found) {
#line 203
            if (! ((unsigned long )isp1 < (unsigned long )iend)) {
#line 203
              goto while_break___0;
            }
          } else {
#line 203
            goto while_break___0;
          }
#line 205
          tmp = isp1;
#line 205
          isp1 ++;
#line 205
          tmp___0 = isp2;
#line 205
          isp2 ++;
#line 205
          if ((int )*tmp != (int )*tmp___0) {
#line 206
            found = 0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 210
      if (! found) {
#line 212
        if (sp->link) {
#line 214
          sp = sp->link;
        } else {
          {
#line 218
          tmp___1 = new_state___0(symbol);
#line 218
          sp->link = tmp___1;
#line 218
          sp = tmp___1;
#line 219
          found = 1;
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 226
    sp = new_state___0(symbol);
#line 226
    *(state_set___0 + key) = sp;
    }
  }
#line 229
  return ((int )sp->number);
}
}
#line 234 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void initialize_states___0(void) 
{ 
  register int i ;
  register short *start_derives ;
  register core *p ;
  char *tmp ;

  {
#line 240
  start_derives = *(derives + start_symbol);
#line 241
  i = 0;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! ((int )*(start_derives + i) >= 0)) {
#line 241
      goto while_break;
    }
#line 242
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 241
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 244
  tmp = my_malloc((unsigned int )(sizeof(core ) + (unsigned long )i * sizeof(short )));
#line 244
  p = (core *)tmp;
#line 246
  p->next = (struct core *)0;
#line 247
  p->link = (struct core *)0;
#line 248
  p->number = (short)0;
#line 249
  p->accessing_symbol = (short)0;
#line 250
  p->nitems = (short )i;
#line 252
  i = 0;
  }
  {
#line 252
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 252
    if (! ((int )*(start_derives + i) >= 0)) {
#line 252
      goto while_break___0;
    }
#line 253
    p->items[i] = *(rrhs + *(start_derives + i));
#line 252
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 255
  this_state___0 = p;
#line 255
  last_state___0 = this_state___0;
#line 255
  first_state = last_state___0;
#line 256
  nstates = 1;
#line 257
  return;
}
}
#line 260 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void new_itemsets___0(void) 
{ 
  register int i ;
  register int shiftcount ;
  register short *isp ;
  register short *ksp ;
  register int symbol ;
  short *tmp ;
  int tmp___0 ;
  short *tmp___1 ;

  {
#line 268
  i = 0;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! (i < nsyms)) {
#line 268
      goto while_break;
    }
#line 269
    *(kernel_end___0 + i) = (short *)0;
#line 268
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  shiftcount = 0;
#line 272
  isp = itemset;
  {
#line 273
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 273
    if (! ((unsigned long )isp < (unsigned long )itemsetend)) {
#line 273
      goto while_break___0;
    }
#line 275
    tmp = isp;
#line 275
    isp ++;
#line 275
    i = (int )*tmp;
#line 276
    symbol = (int )*(ritem + i);
#line 277
    if (symbol > 0) {
#line 279
      ksp = *(kernel_end___0 + symbol);
#line 280
      if (! ksp) {
#line 282
        tmp___0 = shiftcount;
#line 282
        shiftcount ++;
#line 282
        *(shift_symbol___0 + tmp___0) = (short )symbol;
#line 283
        ksp = *(kernel_base___0 + symbol);
      }
#line 286
      tmp___1 = ksp;
#line 286
      ksp ++;
#line 286
      *tmp___1 = (short )(i + 1);
#line 287
      *(kernel_end___0 + symbol) = ksp;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 291
  nshifts___0 = shiftcount;
#line 292
  return;
}
}
#line 296 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static core *new_state___0(int symbol ) 
{ 
  register int n ;
  register core *p ;
  register short *isp1 ;
  register short *isp2 ;
  register short *iend ;
  char *tmp ;
  short *tmp___0 ;
  short *tmp___1 ;

  {
#line 309
  if (nstates >= 32767) {
    {
#line 310
    fatal((char *)"too many states");
    }
  }
  {
#line 312
  isp1 = *(kernel_base___0 + symbol);
#line 313
  iend = *(kernel_end___0 + symbol);
#line 314
  n = (int )(iend - isp1);
#line 316
  tmp = allocate((unsigned int )(sizeof(core ) + (unsigned long )(n - 1) * sizeof(short )));
#line 316
  p = (core *)tmp;
#line 317
  p->accessing_symbol = (short )symbol;
#line 318
  p->number = (short )nstates;
#line 319
  p->nitems = (short )n;
#line 321
  isp2 = p->items;
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! ((unsigned long )isp1 < (unsigned long )iend)) {
#line 322
      goto while_break;
    }
#line 323
    tmp___0 = isp2;
#line 323
    isp2 ++;
#line 323
    tmp___1 = isp1;
#line 323
    isp1 ++;
#line 323
    *tmp___0 = *tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  last_state___0->next = p;
#line 326
  last_state___0 = p;
#line 328
  nstates ++;
#line 330
  return (p);
}
}
#line 406 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void save_shifts___0(void) 
{ 
  register shifts *p ;
  register short *sp1 ;
  register short *sp2 ;
  register short *send ;
  char *tmp ;
  short *tmp___0 ;
  short *tmp___1 ;

  {
  {
#line 413
  tmp = allocate((unsigned int )(sizeof(shifts ) + (unsigned long )(nshifts___0 - 1) * sizeof(short )));
#line 413
  p = (shifts *)tmp;
#line 416
  p->number = this_state___0->number;
#line 417
  p->nshifts = (short )nshifts___0;
#line 419
  sp1 = shiftset___0;
#line 420
  sp2 = p->shift;
#line 421
  send = shiftset___0 + nshifts___0;
  }
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (! ((unsigned long )sp1 < (unsigned long )send)) {
#line 423
      goto while_break;
    }
#line 424
    tmp___0 = sp2;
#line 424
    sp2 ++;
#line 424
    tmp___1 = sp1;
#line 424
    sp1 ++;
#line 424
    *tmp___0 = *tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  if (last_shift___0) {
#line 428
    last_shift___0->next = p;
#line 429
    last_shift___0 = p;
  } else {
#line 433
    first_shift = p;
#line 434
    last_shift___0 = p;
  }
#line 436
  return;
}
}
#line 440 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void save_reductions___0(void) 
{ 
  register short *isp ;
  register short *rp1 ;
  register short *rp2 ;
  register int item ;
  register int count ;
  register reductions *p ;
  register short *rend ;
  int tmp ;
  char *tmp___0 ;
  short *tmp___1 ;
  short *tmp___2 ;

  {
#line 450
  count = 0;
#line 451
  isp = itemset;
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 451
    if (! ((unsigned long )isp < (unsigned long )itemsetend)) {
#line 451
      goto while_break;
    }
#line 453
    item = (int )*(ritem + *isp);
#line 454
    if (item < 0) {
#line 456
      tmp = count;
#line 456
      count ++;
#line 456
      *(redset___0 + tmp) = (short )(- item);
    }
#line 451
    isp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 460
  if (count) {
    {
#line 462
    tmp___0 = allocate((unsigned int )(sizeof(reductions ) + (unsigned long )(count - 1) * sizeof(short )));
#line 462
    p = (reductions *)tmp___0;
#line 465
    p->number = this_state___0->number;
#line 466
    p->nreds = (short )count;
#line 468
    rp1 = redset___0;
#line 469
    rp2 = p->rules;
#line 470
    rend = rp1 + count;
    }
    {
#line 472
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 472
      if (! ((unsigned long )rp1 < (unsigned long )rend)) {
#line 472
        goto while_break___0;
      }
#line 473
      tmp___1 = rp2;
#line 473
      rp2 ++;
#line 473
      tmp___2 = rp1;
#line 473
      rp1 ++;
#line 473
      *tmp___1 = *tmp___2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 475
    if (last_reduction___0) {
#line 477
      last_reduction___0->next = p;
#line 478
      last_reduction___0 = p;
    } else {
#line 482
      first_reduction = p;
#line 483
      last_reduction___0 = p;
    }
  }
#line 486
  return;
}
}
#line 489 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void set_derives___0(void) 
{ 
  register int i ;
  register int k ;
  register int lhs ;
  register short *rules ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 495
  tmp = allocate((unsigned int )((unsigned long )nsyms * sizeof(short *)));
#line 495
  derives = (short **)tmp;
#line 496
  tmp___0 = allocate((unsigned int )((unsigned long )(nvars + nrules) * sizeof(short )));
#line 496
  rules = (short *)tmp___0;
#line 498
  k = 0;
#line 499
  lhs = start_symbol;
  }
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! (lhs < nsyms)) {
#line 499
      goto while_break;
    }
#line 501
    *(derives + lhs) = rules + k;
#line 502
    i = 0;
    {
#line 502
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 502
      if (! (i < nrules)) {
#line 502
        goto while_break___0;
      }
#line 504
      if ((int )*(rlhs + i) == lhs) {
#line 506
        *(rules + k) = (short )i;
#line 507
        k ++;
      }
#line 502
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 510
    *(rules + k) = (short)-1;
#line 511
    k ++;
#line 499
    lhs ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  return;
}
}
#line 552 "/home/wheatley/newnew/temp/perl-byacc-2.0/lr0.c"
static void set_nullable___0(void) 
{ 
  register int i ;
  register int j ;
  register int empty ;
  int done___0 ;

  {
  {
#line 558
  nullable = my_malloc((unsigned int )nsyms);
#line 560
  i = 0;
  }
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 560
    if (! (i < nsyms)) {
#line 560
      goto while_break;
    }
#line 561
    *(nullable + i) = (char)0;
#line 560
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 563
  done___0 = 0;
  {
#line 564
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 564
    if (! (! done___0)) {
#line 564
      goto while_break___0;
    }
#line 566
    done___0 = 1;
#line 567
    i = 1;
    {
#line 567
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 567
      if (! (i < nitems)) {
#line 567
        goto while_break___1;
      }
#line 569
      empty = 1;
      {
#line 570
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 570
        j = (int )*(ritem + i);
#line 570
        if (! (j >= 0)) {
#line 570
          goto while_break___2;
        }
#line 572
        if (! *(nullable + j)) {
#line 573
          empty = 0;
        }
#line 574
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 576
      if (empty) {
#line 578
        j = (int )*(rlhs + - j);
#line 579
        if (! *(nullable + j)) {
#line 581
          *(nullable + j) = (char)1;
#line 582
          done___0 = 0;
        }
      }
#line 567
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 597
  return;
}
}
