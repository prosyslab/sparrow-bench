/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 193 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_30 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 193 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_30 XGCValues;
#line 422 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColor_40 {
   unsigned long pixel ;
   unsigned short red ;
   unsigned short green ;
   unsigned short blue ;
   char flags ;
   char pad ;
};
#line 422 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColor_40 XColor;
#line 108 "/usr/include/X11/Xmd.h"
typedef unsigned int CARD32;
#line 113 "/usr/include/X11/Xmd.h"
typedef unsigned short CARD16;
#line 114 "/usr/include/X11/Xmd.h"
typedef unsigned char CARD8;
#line 57 "./rfbproto.h"
struct __anonstruct_rfbRectangle_108 {
   CARD16 x ;
   CARD16 y ;
   CARD16 w ;
   CARD16 h ;
};
#line 57 "./rfbproto.h"
typedef struct __anonstruct_rfbRectangle_108 rfbRectangle;
#line 71 "./rfbproto.h"
struct __anonstruct_rfbPixelFormat_109 {
   CARD8 bitsPerPixel ;
   CARD8 depth ;
   CARD8 bigEndian ;
   CARD8 trueColour ;
   CARD16 redMax ;
   CARD16 greenMax ;
   CARD16 blueMax ;
   CARD8 redShift ;
   CARD8 greenShift ;
   CARD8 blueShift ;
   CARD8 pad1 ;
   CARD16 pad2 ;
};
#line 71 "./rfbproto.h"
typedef struct __anonstruct_rfbPixelFormat_109 rfbPixelFormat;
#line 158 "./rfbproto.h"
typedef char rfbProtocolVersionMsg[13];
#line 213 "./rfbproto.h"
struct __anonstruct_rfbClientInitMsg_110 {
   CARD8 shared ;
};
#line 213 "./rfbproto.h"
typedef struct __anonstruct_rfbClientInitMsg_110 rfbClientInitMsg;
#line 228 "./rfbproto.h"
struct __anonstruct_rfbServerInitMsg_111 {
   CARD16 framebufferWidth ;
   CARD16 framebufferHeight ;
   rfbPixelFormat format ;
   CARD32 nameLength ;
};
#line 228 "./rfbproto.h"
typedef struct __anonstruct_rfbServerInitMsg_111 rfbServerInitMsg;
#line 311 "./rfbproto.h"
struct __anonstruct_rfbFramebufferUpdateMsg_112 {
   CARD8 type ;
   CARD8 pad ;
   CARD16 nRects ;
};
#line 311 "./rfbproto.h"
typedef struct __anonstruct_rfbFramebufferUpdateMsg_112 rfbFramebufferUpdateMsg;
#line 328 "./rfbproto.h"
struct __anonstruct_rfbFramebufferUpdateRectHeader_113 {
   rfbRectangle r ;
   CARD32 encoding ;
};
#line 328 "./rfbproto.h"
typedef struct __anonstruct_rfbFramebufferUpdateRectHeader_113 rfbFramebufferUpdateRectHeader;
#line 347 "./rfbproto.h"
struct __anonstruct_rfbCopyRect_114 {
   CARD16 srcX ;
   CARD16 srcY ;
};
#line 347 "./rfbproto.h"
typedef struct __anonstruct_rfbCopyRect_114 rfbCopyRect;
#line 362 "./rfbproto.h"
struct __anonstruct_rfbRREHeader_115 {
   CARD32 nSubrects ;
};
#line 362 "./rfbproto.h"
typedef struct __anonstruct_rfbRREHeader_115 rfbRREHeader;
#line 449 "./rfbproto.h"
struct __anonstruct_rfbSetColourMapEntriesMsg_117 {
   CARD8 type ;
   CARD8 pad ;
   CARD16 firstColour ;
   CARD16 nColours ;
};
#line 449 "./rfbproto.h"
typedef struct __anonstruct_rfbSetColourMapEntriesMsg_117 rfbSetColourMapEntriesMsg;
#line 468 "./rfbproto.h"
struct __anonstruct_rfbBellMsg_118 {
   CARD8 type ;
};
#line 468 "./rfbproto.h"
typedef struct __anonstruct_rfbBellMsg_118 rfbBellMsg;
#line 480 "./rfbproto.h"
struct __anonstruct_rfbServerCutTextMsg_119 {
   CARD8 type ;
   CARD8 pad1 ;
   CARD16 pad2 ;
   CARD32 length ;
};
#line 480 "./rfbproto.h"
typedef struct __anonstruct_rfbServerCutTextMsg_119 rfbServerCutTextMsg;
#line 495 "./rfbproto.h"
union __anonunion_rfbServerToClientMsg_120 {
   CARD8 type ;
   rfbFramebufferUpdateMsg fu ;
   rfbSetColourMapEntriesMsg scme ;
   rfbBellMsg b ;
   rfbServerCutTextMsg sct ;
};
#line 495 "./rfbproto.h"
typedef union __anonunion_rfbServerToClientMsg_120 rfbServerToClientMsg;
#line 517 "./rfbproto.h"
struct __anonstruct_rfbSetPixelFormatMsg_121 {
   CARD8 type ;
   CARD8 pad1 ;
   CARD16 pad2 ;
   rfbPixelFormat format ;
};
#line 517 "./rfbproto.h"
typedef struct __anonstruct_rfbSetPixelFormatMsg_121 rfbSetPixelFormatMsg;
#line 554 "./rfbproto.h"
struct __anonstruct_rfbSetEncodingsMsg_123 {
   CARD8 type ;
   CARD8 pad ;
   CARD16 nEncodings ;
};
#line 554 "./rfbproto.h"
typedef struct __anonstruct_rfbSetEncodingsMsg_123 rfbSetEncodingsMsg;
#line 570 "./rfbproto.h"
struct __anonstruct_rfbFramebufferUpdateRequestMsg_124 {
   CARD8 type ;
   CARD8 incremental ;
   CARD16 x ;
   CARD16 y ;
   CARD16 w ;
   CARD16 h ;
};
#line 570 "./rfbproto.h"
typedef struct __anonstruct_rfbFramebufferUpdateRequestMsg_124 rfbFramebufferUpdateRequestMsg;
#line 613 "./rfbproto.h"
struct __anonstruct_rfbKeyEventMsg_125 {
   CARD8 type ;
   CARD8 down ;
   CARD16 pad ;
   CARD32 key ;
};
#line 613 "./rfbproto.h"
typedef struct __anonstruct_rfbKeyEventMsg_125 rfbKeyEventMsg;
#line 627 "./rfbproto.h"
struct __anonstruct_rfbPointerEventMsg_126 {
   CARD8 type ;
   CARD8 buttonMask ;
   CARD16 x ;
   CARD16 y ;
};
#line 627 "./rfbproto.h"
typedef struct __anonstruct_rfbPointerEventMsg_126 rfbPointerEventMsg;
#line 646 "./rfbproto.h"
struct __anonstruct_rfbClientCutTextMsg_127 {
   CARD8 type ;
   CARD8 pad1 ;
   CARD16 pad2 ;
   CARD32 length ;
};
#line 646 "./rfbproto.h"
typedef struct __anonstruct_rfbClientCutTextMsg_127 rfbClientCutTextMsg;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_6 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_6 fd_set;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_55 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_55 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_56 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_56 Depth;
#line 267
struct _XDisplay;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_57 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_57 Screen;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_58 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_58 ScreenFormat;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 502
struct _XPrivate;
#line 503
struct _XrmHashBucketRec;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_73 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_73 *_XPrivDisplay;
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 118 "./x2vnc.h"
enum edge_enum {
    EDGE_EAST = 0,
    EDGE_WEST = 1,
    EDGE_NORTH = 2,
    EDGE_SOUTH = 3
} ;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/wait.h"
union wait;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_43 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_44 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_43 __wait_terminated ;
   struct __anonstruct___wait_stopped_44 __wait_stopped ;
};
#line 155 "/usr/include/x86_64-linux-gnu/sys/wait.h"
struct rusage;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 103 "/usr/include/X11/X.h"
typedef XID Cursor;
#line 302 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSetWindowAttributes_59 {
   Pixmap background_pixmap ;
   unsigned long background_pixel ;
   Pixmap border_pixmap ;
   unsigned long border_pixel ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   long event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Colormap colormap ;
   Cursor cursor ;
};
#line 302 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSetWindowAttributes_59 XSetWindowAttributes;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_74 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_74 XKeyEvent;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_75 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_75 XButtonEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_76 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_76 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_77 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_77 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_78 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_78 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_79 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_79 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_80 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_80 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_81 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_81 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_82 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_82 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_83 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_83 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_84 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_84 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_85 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_85 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_86 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_86 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_87 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_87 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_88 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_88 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_89 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_89 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_90 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_90 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_91 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_91 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_92 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_92 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_93 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_93 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_94 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_94 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_95 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_95 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_96 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_96 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_97 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_97 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_98 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_98 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_99 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_99 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_100 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_100 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_102 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_101 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_102 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_101 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_103 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_103 XMappingEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_104 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_104 XErrorEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_105 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_105 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_106 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_106 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_107 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_107 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 106 "/usr/include/X11/X.h"
typedef XID KeySym;
#line 108 "/usr/include/X11/X.h"
typedef unsigned char KeyCode;
#line 320 "/usr/include/X11/Xlib.h"
struct __anonstruct_XWindowAttributes_36 {
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int depth ;
   Visual *visual ;
   Window root ;
   int class ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   Colormap colormap ;
   int map_installed ;
   int map_state ;
   long all_event_masks ;
   long your_event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Screen *screen ;
};
#line 320 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XWindowAttributes_36 XWindowAttributes;
#line 1855 "/usr/include/X11/Xlib.h"
typedef int (*XErrorHandler)(Display * , XErrorEvent * );
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_min_aspect_132 {
   int x ;
   int y ;
};
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_XSizeHints_131 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_132 min_aspect ;
   struct __anonstruct_min_aspect_132 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
#line 81 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XSizeHints_131 XSizeHints;
#line 231 "/usr/include/X11/Xutil.h"
struct _XComposeStatus {
   XPointer compose_ptr ;
   int chars_matched ;
};
#line 231 "/usr/include/X11/Xutil.h"
typedef struct _XComposeStatus XComposeStatus;
#line 36 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
struct coord {
   int x ;
   int y ;
};
#line 24 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.h"
void deskey(unsigned char *key , short edf ) ;
#line 31
void usekey(unsigned long *from ) ;
#line 36
void cpkey(unsigned long *into ) ;
#line 42
void des(unsigned char *inblock , unsigned char *outblock ) ;
#line 30 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
static void scrunch(unsigned char *outof , unsigned long *into ) ;
#line 31
static void unscrun(unsigned long *outof , unsigned char *into ) ;
#line 32
static void desfunc(unsigned long *block , unsigned long *keys ) ;
#line 33
static void cookey(unsigned long *raw1 ) ;
#line 35 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
static unsigned long KnL[32]  = {      0UL};
#line 43 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
static unsigned short bytebit[8]  = 
#line 43
  {      (unsigned short)1,      (unsigned short)2,      (unsigned short)4,      (unsigned short)8, 
        (unsigned short)16,      (unsigned short)32,      (unsigned short)64,      (unsigned short)128};
#line 46 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
static unsigned long bigbyte[24]  = 
#line 46
  {      8388608UL,      4194304UL,      2097152UL,      1048576UL, 
        524288UL,      262144UL,      131072UL,      65536UL, 
        32768UL,      16384UL,      8192UL,      4096UL, 
        2048UL,      1024UL,      512UL,      256UL, 
        128UL,      64UL,      32UL,      16UL, 
        8UL,      4UL,      2UL,      1UL};
#line 56 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
static unsigned char pc1[56]  = 
#line 56
  {      (unsigned char)56,      (unsigned char)48,      (unsigned char)40,      (unsigned char)32, 
        (unsigned char)24,      (unsigned char)16,      (unsigned char)8,      (unsigned char)0, 
        (unsigned char)57,      (unsigned char)49,      (unsigned char)41,      (unsigned char)33, 
        (unsigned char)25,      (unsigned char)17,      (unsigned char)9,      (unsigned char)1, 
        (unsigned char)58,      (unsigned char)50,      (unsigned char)42,      (unsigned char)34, 
        (unsigned char)26,      (unsigned char)18,      (unsigned char)10,      (unsigned char)2, 
        (unsigned char)59,      (unsigned char)51,      (unsigned char)43,      (unsigned char)35, 
        (unsigned char)62,      (unsigned char)54,      (unsigned char)46,      (unsigned char)38, 
        (unsigned char)30,      (unsigned char)22,      (unsigned char)14,      (unsigned char)6, 
        (unsigned char)61,      (unsigned char)53,      (unsigned char)45,      (unsigned char)37, 
        (unsigned char)29,      (unsigned char)21,      (unsigned char)13,      (unsigned char)5, 
        (unsigned char)60,      (unsigned char)52,      (unsigned char)44,      (unsigned char)36, 
        (unsigned char)28,      (unsigned char)20,      (unsigned char)12,      (unsigned char)4, 
        (unsigned char)27,      (unsigned char)19,      (unsigned char)11,      (unsigned char)3};
#line 62 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
static unsigned char totrot[16]  = 
#line 62
  {      (unsigned char)1,      (unsigned char)2,      (unsigned char)4,      (unsigned char)6, 
        (unsigned char)8,      (unsigned char)10,      (unsigned char)12,      (unsigned char)14, 
        (unsigned char)15,      (unsigned char)17,      (unsigned char)19,      (unsigned char)21, 
        (unsigned char)23,      (unsigned char)25,      (unsigned char)27,      (unsigned char)28};
#line 65 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
static unsigned char pc2[48]  = 
#line 65
  {      (unsigned char)13,      (unsigned char)16,      (unsigned char)10,      (unsigned char)23, 
        (unsigned char)0,      (unsigned char)4,      (unsigned char)2,      (unsigned char)27, 
        (unsigned char)14,      (unsigned char)5,      (unsigned char)20,      (unsigned char)9, 
        (unsigned char)22,      (unsigned char)18,      (unsigned char)11,      (unsigned char)3, 
        (unsigned char)25,      (unsigned char)7,      (unsigned char)15,      (unsigned char)6, 
        (unsigned char)26,      (unsigned char)19,      (unsigned char)12,      (unsigned char)1, 
        (unsigned char)40,      (unsigned char)51,      (unsigned char)30,      (unsigned char)36, 
        (unsigned char)46,      (unsigned char)54,      (unsigned char)29,      (unsigned char)39, 
        (unsigned char)50,      (unsigned char)44,      (unsigned char)32,      (unsigned char)47, 
        (unsigned char)43,      (unsigned char)48,      (unsigned char)38,      (unsigned char)55, 
        (unsigned char)33,      (unsigned char)52,      (unsigned char)45,      (unsigned char)41, 
        (unsigned char)49,      (unsigned char)35,      (unsigned char)28,      (unsigned char)31};
#line 71 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
void deskey(unsigned char *key , short edf ) 
{ 
  register int i ;
  register int j ;
  register int l ;
  register int m ;
  register int n ;
  unsigned char pc1m[56] ;
  unsigned char pcr[56] ;
  unsigned long kn[32] ;
  unsigned long tmp ;

  {
#line 79
  j = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (j < 56)) {
#line 79
      goto while_break;
    }
#line 80
    l = (int )pc1[j];
#line 81
    m = l & 7;
#line 82
    if ((int )*(key + (l >> 3)) & (int )bytebit[m]) {
#line 82
      pc1m[j] = (unsigned char)1;
    } else {
#line 82
      pc1m[j] = (unsigned char)0;
    }
#line 79
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    if (! (i < 16)) {
#line 84
      goto while_break___0;
    }
#line 85
    if ((int )edf == 1) {
#line 85
      m = (15 - i) << 1;
    } else {
#line 86
      m = i << 1;
    }
#line 87
    n = m + 1;
#line 88
    tmp = 0UL;
#line 88
    kn[n] = tmp;
#line 88
    kn[m] = tmp;
#line 89
    j = 0;
    {
#line 89
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 89
      if (! (j < 28)) {
#line 89
        goto while_break___1;
      }
#line 90
      l = j + (int )totrot[i];
#line 91
      if (l < 28) {
#line 91
        pcr[j] = pc1m[l];
      } else {
#line 92
        pcr[j] = pc1m[l - 28];
      }
#line 89
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 94
    j = 28;
    {
#line 94
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 94
      if (! (j < 56)) {
#line 94
        goto while_break___2;
      }
#line 95
      l = j + (int )totrot[i];
#line 96
      if (l < 56) {
#line 96
        pcr[j] = pc1m[l];
      } else {
#line 97
        pcr[j] = pc1m[l - 28];
      }
#line 94
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 99
    j = 0;
    {
#line 99
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 99
      if (! (j < 24)) {
#line 99
        goto while_break___3;
      }
#line 100
      if (pcr[pc2[j]]) {
#line 100
        kn[m] |= bigbyte[j];
      }
#line 101
      if (pcr[pc2[j + 24]]) {
#line 101
        kn[n] |= bigbyte[j];
      }
#line 99
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 84
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 104
  cookey(kn);
  }
#line 105
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
static void cookey(unsigned long *raw1 ) 
{ 
  register unsigned long *cook ;
  register unsigned long *raw0 ;
  unsigned long dough[32] ;
  register int i ;
  unsigned long *tmp ;
  unsigned long *tmp___0 ;
  unsigned long *tmp___1 ;

  {
#line 115
  cook = dough;
#line 116
  i = 0;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (i < 16)) {
#line 116
      goto while_break;
    }
#line 117
    tmp = raw1;
#line 117
    raw1 ++;
#line 117
    raw0 = tmp;
#line 118
    *cook = (*raw0 & 16515072UL) << 6;
#line 119
    *cook |= (*raw0 & 4032UL) << 10;
#line 120
    *cook |= (*raw1 & 16515072UL) >> 10;
#line 121
    tmp___0 = cook;
#line 121
    cook ++;
#line 121
    *tmp___0 |= (*raw1 & 4032UL) >> 6;
#line 122
    *cook = (*raw0 & 258048UL) << 12;
#line 123
    *cook |= (*raw0 & 63UL) << 16;
#line 124
    *cook |= (*raw1 & 258048UL) >> 4;
#line 125
    tmp___1 = cook;
#line 125
    cook ++;
#line 125
    *tmp___1 |= *raw1 & 63UL;
#line 116
    i ++;
#line 116
    raw1 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  usekey(dough);
  }
#line 128
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
void cpkey(unsigned long *into ) 
{ 
  register unsigned long *from ;
  register unsigned long *endp ;
  unsigned long *tmp ;
  unsigned long *tmp___0 ;

  {
#line 136
  from = KnL;
#line 136
  endp = & KnL[32];
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! ((unsigned long )from < (unsigned long )endp)) {
#line 137
      goto while_break;
    }
#line 137
    tmp = into;
#line 137
    into ++;
#line 137
    tmp___0 = from;
#line 137
    from ++;
#line 137
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
void usekey(unsigned long *from ) 
{ 
  register unsigned long *to ;
  register unsigned long *endp ;
  unsigned long *tmp ;
  unsigned long *tmp___0 ;

  {
#line 146
  to = KnL;
#line 146
  endp = & KnL[32];
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! ((unsigned long )to < (unsigned long )endp)) {
#line 147
      goto while_break;
    }
#line 147
    tmp = to;
#line 147
    to ++;
#line 147
    tmp___0 = from;
#line 147
    from ++;
#line 147
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
void des(unsigned char *inblock , unsigned char *outblock ) 
{ 
  unsigned long work[2] ;

  {
  {
#line 156
  scrunch(inblock, work);
#line 157
  desfunc(work, KnL);
#line 158
  unscrun(work, outblock);
  }
#line 159
  return;
}
}
#line 162 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
static void scrunch(unsigned char *outof , unsigned long *into ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned long *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;

  {
#line 166
  tmp = outof;
#line 166
  outof ++;
#line 166
  *into = (unsigned long )(((long )*tmp & 255L) << 24);
#line 167
  tmp___0 = outof;
#line 167
  outof ++;
#line 167
  *into |= (unsigned long )(((long )*tmp___0 & 255L) << 16);
#line 168
  tmp___1 = outof;
#line 168
  outof ++;
#line 168
  *into |= (unsigned long )(((long )*tmp___1 & 255L) << 8);
#line 169
  tmp___2 = into;
#line 169
  into ++;
#line 169
  tmp___3 = outof;
#line 169
  outof ++;
#line 169
  *tmp___2 |= (unsigned long )((long )*tmp___3 & 255L);
#line 170
  tmp___4 = outof;
#line 170
  outof ++;
#line 170
  *into = (unsigned long )(((long )*tmp___4 & 255L) << 24);
#line 171
  tmp___5 = outof;
#line 171
  outof ++;
#line 171
  *into |= (unsigned long )(((long )*tmp___5 & 255L) << 16);
#line 172
  tmp___6 = outof;
#line 172
  outof ++;
#line 172
  *into |= (unsigned long )(((long )*tmp___6 & 255L) << 8);
#line 173
  *into |= (unsigned long )((long )*outof & 255L);
#line 174
  return;
}
}
#line 177 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
static void unscrun(unsigned long *outof , unsigned char *into ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned long *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;

  {
#line 181
  tmp = into;
#line 181
  into ++;
#line 181
  *tmp = (unsigned char )((*outof >> 24) & 255UL);
#line 182
  tmp___0 = into;
#line 182
  into ++;
#line 182
  *tmp___0 = (unsigned char )((*outof >> 16) & 255UL);
#line 183
  tmp___1 = into;
#line 183
  into ++;
#line 183
  *tmp___1 = (unsigned char )((*outof >> 8) & 255UL);
#line 184
  tmp___2 = into;
#line 184
  into ++;
#line 184
  tmp___3 = outof;
#line 184
  outof ++;
#line 184
  *tmp___2 = (unsigned char )(*tmp___3 & 255UL);
#line 185
  tmp___4 = into;
#line 185
  into ++;
#line 185
  *tmp___4 = (unsigned char )((*outof >> 24) & 255UL);
#line 186
  tmp___5 = into;
#line 186
  into ++;
#line 186
  *tmp___5 = (unsigned char )((*outof >> 16) & 255UL);
#line 187
  tmp___6 = into;
#line 187
  into ++;
#line 187
  *tmp___6 = (unsigned char )((*outof >> 8) & 255UL);
#line 188
  *into = (unsigned char )(*outof & 255UL);
#line 189
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
static unsigned long SP1[64]  = 
#line 192
  {      16843776UL,      0UL,      65536UL,      16843780UL, 
        16842756UL,      66564UL,      4UL,      65536UL, 
        1024UL,      16843776UL,      16843780UL,      1024UL, 
        16778244UL,      16842756UL,      16777216UL,      4UL, 
        1028UL,      16778240UL,      16778240UL,      66560UL, 
        66560UL,      16842752UL,      16842752UL,      16778244UL, 
        65540UL,      16777220UL,      16777220UL,      65540UL, 
        0UL,      1028UL,      66564UL,      16777216UL, 
        65536UL,      16843780UL,      4UL,      16842752UL, 
        16843776UL,      16777216UL,      16777216UL,      1024UL, 
        16842756UL,      65536UL,      66560UL,      16777220UL, 
        1024UL,      4UL,      16778244UL,      66564UL, 
        16843780UL,      65540UL,      16842752UL,      16778244UL, 
        16777220UL,      1028UL,      66564UL,      16843776UL, 
        1028UL,      16778240UL,      16778240UL,      0UL, 
        65540UL,      66560UL,      0UL,      16842756UL};
#line 210 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
static unsigned long SP2[64]  = 
#line 210
  {      2148565024UL,      2147516416UL,      32768UL,      1081376UL, 
        1048576UL,      32UL,      2148532256UL,      2147516448UL, 
        2147483680UL,      2148565024UL,      2148564992UL,      2147483648UL, 
        2147516416UL,      1048576UL,      32UL,      2148532256UL, 
        1081344UL,      1048608UL,      2147516448UL,      0UL, 
        2147483648UL,      32768UL,      1081376UL,      2148532224UL, 
        1048608UL,      2147483680UL,      0UL,      1081344UL, 
        32800UL,      2148564992UL,      2148532224UL,      32800UL, 
        0UL,      1081376UL,      2148532256UL,      1048576UL, 
        2147516448UL,      2148532224UL,      2148564992UL,      32768UL, 
        2148532224UL,      2147516416UL,      32UL,      2148565024UL, 
        1081376UL,      32UL,      32768UL,      2147483648UL, 
        32800UL,      2148564992UL,      1048576UL,      2147483680UL, 
        1048608UL,      2147516448UL,      2147483680UL,      1048608UL, 
        1081344UL,      0UL,      2147516416UL,      32800UL, 
        2147483648UL,      2148532256UL,      2148565024UL,      1081344UL};
#line 228 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
static unsigned long SP3[64]  = 
#line 228
  {      520UL,      134349312UL,      0UL,      134348808UL, 
        134218240UL,      0UL,      131592UL,      134218240UL, 
        131080UL,      134217736UL,      134217736UL,      131072UL, 
        134349320UL,      131080UL,      134348800UL,      520UL, 
        134217728UL,      8UL,      134349312UL,      512UL, 
        131584UL,      134348800UL,      134348808UL,      131592UL, 
        134218248UL,      131584UL,      131072UL,      134218248UL, 
        8UL,      134349320UL,      512UL,      134217728UL, 
        134349312UL,      134217728UL,      131080UL,      520UL, 
        131072UL,      134349312UL,      134218240UL,      0UL, 
        512UL,      131080UL,      134349320UL,      134218240UL, 
        134217736UL,      512UL,      0UL,      134348808UL, 
        134218248UL,      131072UL,      134217728UL,      134349320UL, 
        8UL,      131592UL,      131584UL,      134217736UL, 
        134348800UL,      134218248UL,      520UL,      134348800UL, 
        131592UL,      8UL,      134348808UL,      131584UL};
#line 246 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
static unsigned long SP4[64]  = 
#line 246
  {      8396801UL,      8321UL,      8321UL,      128UL, 
        8396928UL,      8388737UL,      8388609UL,      8193UL, 
        0UL,      8396800UL,      8396800UL,      8396929UL, 
        129UL,      0UL,      8388736UL,      8388609UL, 
        1UL,      8192UL,      8388608UL,      8396801UL, 
        128UL,      8388608UL,      8193UL,      8320UL, 
        8388737UL,      1UL,      8320UL,      8388736UL, 
        8192UL,      8396928UL,      8396929UL,      129UL, 
        8388736UL,      8388609UL,      8396800UL,      8396929UL, 
        129UL,      0UL,      0UL,      8396800UL, 
        8320UL,      8388736UL,      8388737UL,      1UL, 
        8396801UL,      8321UL,      8321UL,      128UL, 
        8396929UL,      129UL,      1UL,      8192UL, 
        8388609UL,      8193UL,      8396928UL,      8388737UL, 
        8193UL,      8320UL,      8388608UL,      8396801UL, 
        128UL,      8388608UL,      8192UL,      8396928UL};
#line 264 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
static unsigned long SP5[64]  = 
#line 264
  {      256UL,      34078976UL,      34078720UL,      1107296512UL, 
        524288UL,      256UL,      1073741824UL,      34078720UL, 
        1074266368UL,      524288UL,      33554688UL,      1074266368UL, 
        1107296512UL,      1107820544UL,      524544UL,      1073741824UL, 
        33554432UL,      1074266112UL,      1074266112UL,      0UL, 
        1073742080UL,      1107820800UL,      1107820800UL,      33554688UL, 
        1107820544UL,      1073742080UL,      0UL,      1107296256UL, 
        34078976UL,      33554432UL,      1107296256UL,      524544UL, 
        524288UL,      1107296512UL,      256UL,      33554432UL, 
        1073741824UL,      34078720UL,      1107296512UL,      1074266368UL, 
        33554688UL,      1073741824UL,      1107820544UL,      34078976UL, 
        1074266368UL,      256UL,      33554432UL,      1107820544UL, 
        1107820800UL,      524544UL,      1107296256UL,      1107820800UL, 
        34078720UL,      0UL,      1074266112UL,      1107296256UL, 
        524544UL,      33554688UL,      1073742080UL,      524288UL, 
        0UL,      1074266112UL,      34078976UL,      1073742080UL};
#line 282 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
static unsigned long SP6[64]  = 
#line 282
  {      536870928UL,      541065216UL,      16384UL,      541081616UL, 
        541065216UL,      16UL,      541081616UL,      4194304UL, 
        536887296UL,      4210704UL,      4194304UL,      536870928UL, 
        4194320UL,      536887296UL,      536870912UL,      16400UL, 
        0UL,      4194320UL,      536887312UL,      16384UL, 
        4210688UL,      536887312UL,      16UL,      541065232UL, 
        541065232UL,      0UL,      4210704UL,      541081600UL, 
        16400UL,      4210688UL,      541081600UL,      536870912UL, 
        536887296UL,      16UL,      541065232UL,      4210688UL, 
        541081616UL,      4194304UL,      16400UL,      536870928UL, 
        4194304UL,      536887296UL,      536870912UL,      16400UL, 
        536870928UL,      541081616UL,      4210688UL,      541065216UL, 
        4210704UL,      541081600UL,      0UL,      541065232UL, 
        16UL,      16384UL,      541065216UL,      4210704UL, 
        16384UL,      4194320UL,      536887312UL,      0UL, 
        541081600UL,      536870912UL,      4194320UL,      536887312UL};
#line 300 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
static unsigned long SP7[64]  = 
#line 300
  {      2097152UL,      69206018UL,      67110914UL,      0UL, 
        2048UL,      67110914UL,      2099202UL,      69208064UL, 
        69208066UL,      2097152UL,      0UL,      67108866UL, 
        2UL,      67108864UL,      69206018UL,      2050UL, 
        67110912UL,      2099202UL,      2097154UL,      67110912UL, 
        67108866UL,      69206016UL,      69208064UL,      2097154UL, 
        69206016UL,      2048UL,      2050UL,      69208066UL, 
        2099200UL,      2UL,      67108864UL,      2099200UL, 
        67108864UL,      2099200UL,      2097152UL,      67110914UL, 
        67110914UL,      69206018UL,      69206018UL,      2UL, 
        2097154UL,      67108864UL,      67110912UL,      2097152UL, 
        69208064UL,      2050UL,      2099202UL,      69208064UL, 
        2050UL,      67108866UL,      69208066UL,      69206016UL, 
        2099200UL,      0UL,      2UL,      69208066UL, 
        0UL,      2099202UL,      69206016UL,      2048UL, 
        67108866UL,      67110912UL,      2048UL,      2097154UL};
#line 318 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
static unsigned long SP8[64]  = 
#line 318
  {      268439616UL,      4096UL,      262144UL,      268701760UL, 
        268435456UL,      268439616UL,      64UL,      268435456UL, 
        262208UL,      268697600UL,      268701760UL,      266240UL, 
        268701696UL,      266304UL,      4096UL,      64UL, 
        268697600UL,      268435520UL,      268439552UL,      4160UL, 
        266240UL,      262208UL,      268697664UL,      268701696UL, 
        4160UL,      0UL,      0UL,      268697664UL, 
        268435520UL,      268439552UL,      266304UL,      262144UL, 
        266304UL,      262144UL,      268701696UL,      4096UL, 
        64UL,      268697664UL,      4096UL,      266304UL, 
        268439552UL,      64UL,      268435520UL,      268697600UL, 
        268697664UL,      268435456UL,      262144UL,      268439616UL, 
        0UL,      268701760UL,      262208UL,      268435520UL, 
        268697600UL,      268439552UL,      268439616UL,      0UL, 
        268701760UL,      266240UL,      266240UL,      4160UL, 
        4160UL,      262208UL,      268435456UL,      268701696UL};
#line 336 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/d3des.c"
static void desfunc(unsigned long *block , unsigned long *keys ) 
{ 
  register unsigned long fval ;
  register unsigned long work ;
  register unsigned long right ;
  register unsigned long leftt ;
  register int round ;
  unsigned long *tmp ;
  unsigned long *tmp___0 ;
  unsigned long *tmp___1 ;
  unsigned long *tmp___2 ;
  unsigned long *tmp___3 ;

  {
#line 342
  leftt = *(block + 0);
#line 343
  right = *(block + 1);
#line 344
  work = ((leftt >> 4) ^ right) & 252645135UL;
#line 345
  right ^= work;
#line 346
  leftt ^= work << 4;
#line 347
  work = ((leftt >> 16) ^ right) & 65535UL;
#line 348
  right ^= work;
#line 349
  leftt ^= work << 16;
#line 350
  work = ((right >> 2) ^ leftt) & 858993459UL;
#line 351
  leftt ^= work;
#line 352
  right ^= work << 2;
#line 353
  work = ((right >> 8) ^ leftt) & 16711935UL;
#line 354
  leftt ^= work;
#line 355
  right ^= work << 8;
#line 356
  right = ((right << 1) | ((right >> 31) & 1UL)) & 4294967295UL;
#line 357
  work = (leftt ^ right) & 2863311530UL;
#line 358
  leftt ^= work;
#line 359
  right ^= work;
#line 360
  leftt = ((leftt << 1) | ((leftt >> 31) & 1UL)) & 4294967295UL;
#line 362
  round = 0;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! (round < 8)) {
#line 362
      goto while_break;
    }
#line 363
    work = (right << 28) | (right >> 4);
#line 364
    tmp = keys;
#line 364
    keys ++;
#line 364
    work ^= *tmp;
#line 365
    fval = SP7[work & 63UL];
#line 366
    fval |= SP5[(work >> 8) & 63UL];
#line 367
    fval |= SP3[(work >> 16) & 63UL];
#line 368
    fval |= SP1[(work >> 24) & 63UL];
#line 369
    tmp___0 = keys;
#line 369
    keys ++;
#line 369
    work = right ^ *tmp___0;
#line 370
    fval |= SP8[work & 63UL];
#line 371
    fval |= SP6[(work >> 8) & 63UL];
#line 372
    fval |= SP4[(work >> 16) & 63UL];
#line 373
    fval |= SP2[(work >> 24) & 63UL];
#line 374
    leftt ^= fval;
#line 375
    work = (leftt << 28) | (leftt >> 4);
#line 376
    tmp___1 = keys;
#line 376
    keys ++;
#line 376
    work ^= *tmp___1;
#line 377
    fval = SP7[work & 63UL];
#line 378
    fval |= SP5[(work >> 8) & 63UL];
#line 379
    fval |= SP3[(work >> 16) & 63UL];
#line 380
    fval |= SP1[(work >> 24) & 63UL];
#line 381
    tmp___2 = keys;
#line 381
    keys ++;
#line 381
    work = leftt ^ *tmp___2;
#line 382
    fval |= SP8[work & 63UL];
#line 383
    fval |= SP6[(work >> 8) & 63UL];
#line 384
    fval |= SP4[(work >> 16) & 63UL];
#line 385
    fval |= SP2[(work >> 24) & 63UL];
#line 386
    right ^= fval;
#line 362
    round ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  right = (right << 31) | (right >> 1);
#line 390
  work = (leftt ^ right) & 2863311530UL;
#line 391
  leftt ^= work;
#line 392
  right ^= work;
#line 393
  leftt = (leftt << 31) | (leftt >> 1);
#line 394
  work = ((leftt >> 8) ^ right) & 16711935UL;
#line 395
  right ^= work;
#line 396
  leftt ^= work << 8;
#line 397
  work = ((leftt >> 2) ^ right) & 858993459UL;
#line 398
  right ^= work;
#line 399
  leftt ^= work << 2;
#line 400
  work = ((right >> 16) ^ leftt) & 65535UL;
#line 401
  leftt ^= work;
#line 402
  right ^= work << 16;
#line 403
  work = ((right >> 4) ^ leftt) & 252645135UL;
#line 404
  leftt ^= work;
#line 405
  right ^= work << 4;
#line 406
  tmp___3 = block;
#line 406
  block ++;
#line 406
  *tmp___3 = right;
#line 407
  *block = leftt;
#line 408
  return;
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 435
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 324
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 27 "./vncauth.h"
int vncEncryptAndStorePasswd(char *passwd , char *fname ) ;
#line 28
char *vncDecryptPasswdFromFile(char *fname ) ;
#line 29
void vncRandomBytes(unsigned char *bytes ) ;
#line 30
void vncEncryptBytes(unsigned char *bytes , char *passwd ) ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/vncauth.c"
int temp_file_fd ;
#line 40 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/vncauth.c"
unsigned char fixedkey[8]  = 
#line 40
  {      (unsigned char)23,      (unsigned char)82,      (unsigned char)107,      (unsigned char)6, 
        (unsigned char)35,      (unsigned char)78,      (unsigned char)88,      (unsigned char)7};
#line 58
extern int ( /* missing proto */  dup)() ;
#line 48 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/vncauth.c"
int vncEncryptAndStorePasswd(char *passwd , char *fname ) 
{ 
  FILE *fp ;
  int i ;
  unsigned char encryptedPasswd[8] ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 55
  if (! fname) {
#line 57
    if (! temp_file_fd) {
#line 57
      return (1);
    }
    {
#line 58
    tmp = dup(temp_file_fd);
#line 58
    fp = fdopen(tmp, "r+");
    }
  } else {
    {
#line 60
    fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"w");
    }
#line 60
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 60
      return (1);
    }
    {
#line 61
    chmod((char const   *)fname, (__mode_t )384);
    }
  }
#line 66
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (i < 8)) {
#line 66
      goto while_break;
    }
    {
#line 67
    tmp___0 = strlen((char const   *)passwd);
    }
#line 67
    if ((size_t )i < tmp___0) {
#line 68
      encryptedPasswd[i] = (unsigned char )*(passwd + i);
    } else {
#line 70
      encryptedPasswd[i] = (unsigned char)0;
    }
#line 66
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  deskey(fixedkey, (short)0);
#line 78
  des(encryptedPasswd, encryptedPasswd);
#line 80
  i = 0;
  }
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 80
    if (! (i < 8)) {
#line 80
      goto while_break___0;
    }
    {
#line 81
    _IO_putc((int )encryptedPasswd[i], fp);
#line 80
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 84
  fclose(fp);
  }
#line 85
  return (0);
}
}
#line 105
extern int ( /* missing proto */  lseek)() ;
#line 95 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/vncauth.c"
char *vncDecryptPasswdFromFile(char *fname ) 
{ 
  FILE *fp ;
  int i ;
  int ch ;
  unsigned char *passwd ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 100
  tmp = malloc((size_t )9);
#line 100
  passwd = (unsigned char *)tmp;
  }
#line 102
  if (! fname) {
#line 104
    if (! temp_file_fd) {
#line 104
      return ((char *)((void *)0));
    }
    {
#line 105
    lseek(temp_file_fd, 0, 0);
#line 106
    tmp___0 = dup(temp_file_fd);
#line 106
    fp = fdopen(tmp___0, "r");
    }
  } else {
    {
#line 108
    fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
    }
#line 108
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 108
      return ((char *)((void *)0));
    }
  }
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i < 8)) {
#line 111
      goto while_break;
    }
    {
#line 112
    ch = _IO_getc(fp);
    }
#line 113
    if (ch == -1) {
      {
#line 114
      fclose(fp);
      }
#line 115
      return ((char *)((void *)0));
    }
#line 117
    *(passwd + i) = (unsigned char )ch;
#line 111
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  fclose(fp);
#line 122
  deskey(fixedkey, (short)1);
#line 123
  des(passwd, passwd);
#line 125
  *(passwd + 8) = (unsigned char)0;
  }
#line 127
  return ((char *)passwd);
}
}
#line 140
extern int ( /* missing proto */  time)() ;
#line 136 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/vncauth.c"
void vncRandomBytes(unsigned char *bytes ) 
{ 
  int i ;
  unsigned int seed ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 140
  tmp = time(0);
#line 140
  seed = (unsigned int )tmp;
#line 142
  srandom(seed);
#line 143
  i = 0;
  }
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (i < 16)) {
#line 143
      goto while_break;
    }
    {
#line 144
    tmp___0 = random();
#line 144
    *(bytes + i) = (unsigned char )(tmp___0 & 255L);
#line 143
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/vncauth.c"
void vncEncryptBytes(unsigned char *bytes , char *passwd ) 
{ 
  unsigned char key[8] ;
  int i ;
  size_t tmp ;

  {
#line 161
  i = 0;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (i < 8)) {
#line 161
      goto while_break;
    }
    {
#line 162
    tmp = strlen((char const   *)passwd);
    }
#line 162
    if ((size_t )i < tmp) {
#line 163
      key[i] = (unsigned char )*(passwd + i);
    } else {
#line 165
      key[i] = (unsigned char)0;
    }
#line 161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 169
  deskey(key, (short)0);
#line 171
  i = 0;
  }
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 171
    if (! (i < 16)) {
#line 171
      goto while_break___0;
    }
    {
#line 172
    des(bytes + i, bytes + i);
#line 171
    i += 8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 174
  return;
}
}
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 948
extern char *( __attribute__((__nonnull__(1))) getpass)(char const   *__prompt ) ;
#line 1016
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 33 "./x2vnc.h"
int endianTest ;
#line 49
char *programName ;
#line 52
int listenSpecified ;
#line 55
int shareDesktop ;
#line 57
CARD32 explicitEncodings[10] ;
#line 58
int nExplicitEncodings ;
#line 59
int addCopyRect ;
#line 60
int addRRE ;
#line 61
int addCoRRE ;
#line 62
int addHextile ;
#line 70
char *passwdFile ;
#line 72
int updateRequestX ;
#line 73
int updateRequestY ;
#line 74
int updateRequestW ;
#line 75
int updateRequestH ;
#line 79
int trimsel ;
#line 86
int last_event_time ;
#line 95 "./x2vnc.h"
int rfbsock  ;
#line 98 "./x2vnc.h"
char *desktopName  ;
#line 100 "./x2vnc.h"
rfbServerInitMsg si  ;
#line 101 "./x2vnc.h"
struct timeval updateRequestTime  ;
#line 102 "./x2vnc.h"
int sendUpdateRequest  ;
#line 104
int ConnectToRFBServer(char const   *hostname___0 , int port___0 ) ;
#line 105
int InitialiseRFBConnection(int sock ) ;
#line 106
int SetFormatAndEncodings(void) ;
#line 108
int SendFramebufferUpdateRequest(int x , int y , int w , int h , int incremental ) ;
#line 110
int SendPointerEvent(int x , int y , int buttonMask ) ;
#line 111
int SendKeyEvent(CARD32 key , int down ) ;
#line 112
int SendClientCutText(char *str , int len ) ;
#line 113
int HandleRFBServerMessage(void) ;
#line 137
int errorMessageFromReadExact ;
#line 139
int ReadExact(int sock , char *buf , int n ) ;
#line 140
int WriteExact(int sock , char *buf , int n ) ;
#line 143
int ConnectToTcpAddr(unsigned int host , int port___0 ) ;
#line 145
int StringToIPAddr(char const   *str , unsigned int *addr ) ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/rfbproto.c"
static int HandleHextileEncoding8(int rx , int ry , int rw , int rh ) ;
#line 35
static int HandleHextileEncoding16(int rx , int ry , int rw , int rh ) ;
#line 36
static int HandleHextileEncoding32(int rx , int ry , int rw , int rh ) ;
#line 45 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/rfbproto.c"
int endianTest  =    1;
#line 53 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/rfbproto.c"
static char buffer[307200]  ;
#line 60 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/rfbproto.c"
int ConnectToRFBServer(char const   *hostname___0 , int port___0 ) 
{ 
  unsigned int host ;
  int tmp ;

  {
  {
#line 65
  tmp = StringToIPAddr(hostname___0, & host);
  }
#line 65
  if (! tmp) {
    {
#line 66
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: couldn\'t convert \'%s\' to host address\n",
            programName, hostname___0);
    }
#line 68
    return (0);
  }
  {
#line 71
  rfbsock = ConnectToTcpAddr(host, port___0);
  }
#line 73
  if (rfbsock < 0) {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unable to connect to VNC server\n",
            programName);
    }
#line 76
    return (0);
  }
#line 79
  return (1);
}
}
#line 195 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/rfbproto.c"
static char password[128]  ;
#line 87 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/rfbproto.c"
int InitialiseRFBConnection(int sock ) 
{ 
  rfbProtocolVersionMsg pv ;
  int major ;
  int minor ;
  int authWillWork ;
  CARD32 authScheme ;
  CARD32 reasonLen ;
  CARD32 authResult ;
  char *reason ;
  CARD8 challenge[16] ;
  char *passwd ;
  rfbClientInitMsg ci ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;

  {
#line 92
  authWillWork = 1;
#line 96
  passwd = (char *)0;
#line 103
  if (listenSpecified) {
#line 104
    errorMessageFromReadExact = 0;
  }
  {
#line 106
  tmp = ReadExact(sock, pv, 12);
  }
#line 106
  if (! tmp) {
#line 106
    return (0);
  }
  {
#line 108
  errorMessageFromReadExact = 1;
#line 110
  pv[12] = (char)0;
#line 112
  tmp___0 = sscanf((char const   */* __restrict  */)(pv), (char const   */* __restrict  */)"RFB %03d.%03d\n",
                   & major, & minor);
  }
#line 112
  if (tmp___0 != 2) {
    {
#line 113
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Not a valid VNC server\n",
            programName);
    }
#line 114
    return (0);
  }
  {
#line 117
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: VNC server supports protocol version %d.%d (viewer %d.%d)\n",
          programName, major, minor, 3, 3);
  }
#line 122
  if (major == 3) {
#line 122
    if (minor < 3) {
#line 124
      authWillWork = 0;
    } else {
#line 127
      major = 3;
#line 128
      minor = 3;
    }
  } else {
#line 127
    major = 3;
#line 128
    minor = 3;
  }
  {
#line 131
  sprintf((char */* __restrict  */)(pv), (char const   */* __restrict  */)"RFB %03d.%03d\n",
          major, minor);
#line 133
  tmp___1 = WriteExact(sock, pv, 12);
  }
#line 133
  if (! tmp___1) {
#line 133
    return (0);
  }
  {
#line 135
  tmp___2 = ReadExact(sock, (char *)(& authScheme), 4);
  }
#line 135
  if (! tmp___2) {
#line 135
    return (0);
  }
#line 137
  if (*((char *)(& endianTest))) {
#line 137
    authScheme = ((((authScheme & 4278190080U) >> 24) | ((authScheme & 16711680U) >> 8)) | ((authScheme & 65280U) << 8)) | ((authScheme & 255U) << 24);
  } else {
#line 137
    authScheme = authScheme;
  }
  {
#line 141
  if (authScheme == 0U) {
#line 141
    goto case_0;
  }
#line 153
  if (authScheme == 1U) {
#line 153
    goto case_1;
  }
#line 157
  if (authScheme == 2U) {
#line 157
    goto case_2;
  }
#line 241
  goto switch_default___0;
  case_0: /* CIL Label */ 
  {
#line 142
  tmp___3 = ReadExact(sock, (char *)(& reasonLen), 4);
  }
#line 142
  if (! tmp___3) {
#line 142
    return (0);
  }
#line 143
  if (*((char *)(& endianTest))) {
#line 143
    reasonLen = ((((reasonLen & 4278190080U) >> 24) | ((reasonLen & 16711680U) >> 8)) | ((reasonLen & 65280U) << 8)) | ((reasonLen & 255U) << 24);
  } else {
#line 143
    reasonLen = reasonLen;
  }
  {
#line 145
  tmp___4 = malloc((size_t )reasonLen);
#line 145
  reason = (char *)tmp___4;
#line 147
  tmp___5 = ReadExact(sock, reason, (int )reasonLen);
  }
#line 147
  if (! tmp___5) {
#line 147
    return (0);
  }
  {
#line 149
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: VNC connection failed: %.*s\n",
          programName, (int )reasonLen, reason);
  }
#line 151
  return (0);
  case_1: /* CIL Label */ 
  {
#line 154
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: No authentication needed\n",
          programName);
  }
#line 155
  goto switch_break;
  case_2: /* CIL Label */ 
#line 158
  if (! authWillWork) {
    {
#line 159
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: VNC server uses the old authentication scheme.\nYou should kill your old desktop(s) and restart.\nIf you really need to connect to this desktop use vncviewer3.2\n\n",
            programName);
    }
#line 165
    return (0);
  }
  {
#line 168
  tmp___6 = ReadExact(sock, (char *)(challenge), 16);
  }
#line 168
  if (! tmp___6) {
#line 168
    return (0);
  }
  {
#line 170
  passwd = vncDecryptPasswdFromFile(passwdFile);
  }
#line 170
  if (! passwd) {
#line 172
    if (passwdFile) {
      {
#line 174
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Couldn\'t open password file: %s\n",
              programName, passwdFile);
#line 176
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"If you wish to create this password file, enter a password below.\n");
#line 177
      passwd = getpass("Password: ");
      }
#line 179
      if (! passwd) {
        {
#line 180
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Reading password failed\n",
                programName);
        }
#line 181
        return (0);
      } else {
        {
#line 179
        tmp___7 = strlen((char const   *)passwd);
        }
#line 179
        if (tmp___7 == 0UL) {
          {
#line 180
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Reading password failed\n",
                  programName);
          }
#line 181
          return (0);
        }
      }
      {
#line 183
      tmp___8 = strlen((char const   *)passwd);
      }
#line 183
      if (tmp___8 > 8UL) {
#line 184
        *(passwd + 8) = (char )'\000';
      }
      {
#line 186
      vncEncryptAndStorePasswd(passwd, passwdFile);
      }
#line 187
      return (0);
    } else {
      {
#line 191
      tmp___9 = isatty(0);
      }
#line 191
      if (tmp___9) {
        {
#line 193
        passwd = getpass("Password: ");
        }
      } else {
        {
#line 196
        passwd = fgets((char */* __restrict  */)(password), (int )(sizeof(password) - 1UL),
                       (FILE */* __restrict  */)stdin);
        }
      }
      {
#line 199
      tmp___10 = strlen((char const   *)passwd);
      }
#line 199
      if (tmp___10 == 0UL) {
        {
#line 200
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Reading password failed\n",
                programName);
        }
#line 201
        return (0);
      }
      {
#line 204
      tmp___11 = strlen((char const   *)passwd);
      }
#line 204
      if (tmp___11 > 8UL) {
#line 205
        *(passwd + 8) = (char )'\000';
      }
    }
  }
  {
#line 210
  vncEncryptBytes(challenge, passwd);
  }
#line 213
  if (temp_file_fd) {
    {
#line 214
    vncEncryptAndStorePasswd(passwd, (char *)0);
    }
  }
  {
#line 216
  tmp___12 = WriteExact(sock, (char *)(challenge), 16);
  }
#line 216
  if (! tmp___12) {
#line 216
    return (0);
  }
  {
#line 218
  tmp___13 = ReadExact(sock, (char *)(& authResult), 4);
  }
#line 218
  if (! tmp___13) {
#line 218
    return (0);
  }
#line 220
  if (*((char *)(& endianTest))) {
#line 220
    authResult = ((((authResult & 4278190080U) >> 24) | ((authResult & 16711680U) >> 8)) | ((authResult & 65280U) << 8)) | ((authResult & 255U) << 24);
  } else {
#line 220
    authResult = authResult;
  }
  {
#line 223
  if (authResult == 0U) {
#line 223
    goto case_0___0;
  }
#line 226
  if (authResult == 1U) {
#line 226
    goto case_1___0;
  }
#line 230
  if (authResult == 2U) {
#line 230
    goto case_2___0;
  }
#line 234
  goto switch_default;
  case_0___0: /* CIL Label */ 
  {
#line 224
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: VNC authentication succeeded\n",
          programName);
  }
#line 225
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 227
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: VNC authentication failed\n",
          programName);
  }
#line 228
  if (temp_file_fd) {
    {
#line 228
    ftruncate(temp_file_fd, (__off_t )0);
    }
  }
#line 229
  return (0);
  case_2___0: /* CIL Label */ 
  {
#line 231
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: VNC authentication failed - too many tries\n",
          programName);
  }
#line 233
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 235
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Unknown VNC authentication result: %d\n",
          programName, (int )authResult);
  }
#line 237
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
#line 239
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 242
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Unknown authentication scheme from VNC server: %d\n",
          programName, (int )authScheme);
  }
#line 245
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 248
  if (shareDesktop) {
#line 248
    ci.shared = (CARD8 )1;
  } else {
#line 248
    ci.shared = (CARD8 )0;
  }
  {
#line 250
  tmp___14 = WriteExact(sock, (char *)(& ci), 1);
  }
#line 250
  if (! tmp___14) {
#line 250
    return (0);
  }
  {
#line 252
  tmp___15 = ReadExact(sock, (char *)(& si), 24);
  }
#line 252
  if (! tmp___15) {
#line 252
    return (0);
  }
#line 254
  if (*((char *)(& endianTest))) {
#line 254
    si.framebufferWidth = (CARD16 )((((int )si.framebufferWidth & 255) << 8) | (((int )si.framebufferWidth >> 8) & 255));
  } else {
#line 254
    si.framebufferWidth = si.framebufferWidth;
  }
#line 255
  if (*((char *)(& endianTest))) {
#line 255
    si.framebufferHeight = (CARD16 )((((int )si.framebufferHeight & 255) << 8) | (((int )si.framebufferHeight >> 8) & 255));
  } else {
#line 255
    si.framebufferHeight = si.framebufferHeight;
  }
#line 256
  if (*((char *)(& endianTest))) {
#line 256
    si.format.redMax = (CARD16 )((((int )si.format.redMax & 255) << 8) | (((int )si.format.redMax >> 8) & 255));
  } else {
#line 256
    si.format.redMax = si.format.redMax;
  }
#line 257
  if (*((char *)(& endianTest))) {
#line 257
    si.format.greenMax = (CARD16 )((((int )si.format.greenMax & 255) << 8) | (((int )si.format.greenMax >> 8) & 255));
  } else {
#line 257
    si.format.greenMax = si.format.greenMax;
  }
#line 258
  if (*((char *)(& endianTest))) {
#line 258
    si.format.blueMax = (CARD16 )((((int )si.format.blueMax & 255) << 8) | (((int )si.format.blueMax >> 8) & 255));
  } else {
#line 258
    si.format.blueMax = si.format.blueMax;
  }
#line 259
  if (*((char *)(& endianTest))) {
#line 259
    si.nameLength = ((((si.nameLength & 4278190080U) >> 24) | ((si.nameLength & 16711680U) >> 8)) | ((si.nameLength & 65280U) << 8)) | ((si.nameLength & 255U) << 24);
  } else {
#line 259
    si.nameLength = si.nameLength;
  }
#line 261
  if (updateRequestX + updateRequestW > (int )si.framebufferWidth) {
    {
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: region requested is outside server\'s framebuffer\n",
            programName);
    }
#line 267
    return (0);
  } else
#line 261
  if (updateRequestY + updateRequestH > (int )si.framebufferHeight) {
    {
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: region requested is outside server\'s framebuffer\n",
            programName);
    }
#line 267
    return (0);
  }
#line 269
  if (updateRequestW == 0) {
#line 270
    updateRequestW = (int )si.framebufferWidth - updateRequestX;
  }
#line 271
  if (updateRequestH == 0) {
#line 272
    updateRequestH = (int )si.framebufferHeight - updateRequestY;
  }
  {
#line 274
  tmp___16 = malloc((size_t )(si.nameLength + 1U));
#line 274
  desktopName = (char *)tmp___16;
#line 276
  tmp___17 = ReadExact(sock, desktopName, (int )si.nameLength);
  }
#line 276
  if (! tmp___17) {
#line 276
    return (0);
  }
  {
#line 278
  *(desktopName + si.nameLength) = (char)0;
#line 280
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Desktop name \"%s\"\n",
          programName, desktopName);
#line 282
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Connected to VNC server, using protocol version %d.%d\n",
          programName, 3, 3);
#line 286
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: VNC server default format:\n",
          programName);
  }
#line 288
  return (1);
}
}
#line 296 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/rfbproto.c"
int SetFormatAndEncodings(void) 
{ 
  rfbSetPixelFormatMsg spf ;
  char buf[44] ;
  rfbSetEncodingsMsg *se ;
  CARD32 *encs ;
  int len ;
  int i ;
  int tmp ;
  CARD16 tmp___0 ;
  CARD16 tmp___1 ;
  CARD16 tmp___2 ;
  CARD16 tmp___3 ;
  CARD16 tmp___4 ;
  int tmp___5 ;

  {
#line 301
  se = (rfbSetEncodingsMsg *)(buf);
#line 302
  encs = (CARD32 *)(& buf[4]);
#line 303
  len = 0;
#line 306
  spf.type = (CARD8 )0;
#line 307
  spf.format = si.format;
#line 309
  if (*((char *)(& endianTest))) {
#line 309
    spf.format.redMax = (CARD16 )((((int )spf.format.redMax & 255) << 8) | (((int )spf.format.redMax >> 8) & 255));
  } else {
#line 309
    spf.format.redMax = spf.format.redMax;
  }
#line 310
  if (*((char *)(& endianTest))) {
#line 310
    spf.format.greenMax = (CARD16 )((((int )spf.format.greenMax & 255) << 8) | (((int )spf.format.greenMax >> 8) & 255));
  } else {
#line 310
    spf.format.greenMax = spf.format.greenMax;
  }
#line 311
  if (*((char *)(& endianTest))) {
#line 311
    spf.format.blueMax = (CARD16 )((((int )spf.format.blueMax & 255) << 8) | (((int )spf.format.blueMax >> 8) & 255));
  } else {
#line 311
    spf.format.blueMax = spf.format.blueMax;
  }
  {
#line 313
  tmp = WriteExact(rfbsock, (char *)(& spf), 20);
  }
#line 313
  if (! tmp) {
#line 314
    return (0);
  }
#line 316
  se->type = (CARD8 )2;
#line 317
  se->nEncodings = (CARD16 )0;
#line 319
  i = 0;
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! (i < nExplicitEncodings)) {
#line 319
      goto while_break;
    }
#line 320
    tmp___0 = se->nEncodings;
#line 320
    se->nEncodings = (CARD16 )((int )se->nEncodings + 1);
#line 320
    if (*((char *)(& endianTest))) {
#line 320
      *(encs + tmp___0) = ((((explicitEncodings[i] & 4278190080U) >> 24) | ((explicitEncodings[i] & 16711680U) >> 8)) | ((explicitEncodings[i] & 65280U) << 8)) | ((explicitEncodings[i] & 255U) << 24);
    } else {
#line 320
      *(encs + tmp___0) = explicitEncodings[i];
    }
#line 319
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  if (addCopyRect) {
#line 330
    tmp___1 = se->nEncodings;
#line 330
    se->nEncodings = (CARD16 )((int )se->nEncodings + 1);
#line 330
    if (*((char *)(& endianTest))) {
#line 330
      *(encs + tmp___1) = (unsigned int )(1 << 24);
    } else {
#line 330
      *(encs + tmp___1) = (CARD32 )1;
    }
  }
#line 331
  if (addHextile) {
#line 332
    tmp___2 = se->nEncodings;
#line 332
    se->nEncodings = (CARD16 )((int )se->nEncodings + 1);
#line 332
    if (*((char *)(& endianTest))) {
#line 332
      *(encs + tmp___2) = (unsigned int )(5 << 24);
    } else {
#line 332
      *(encs + tmp___2) = (CARD32 )5;
    }
  }
#line 333
  if (addCoRRE) {
#line 334
    tmp___3 = se->nEncodings;
#line 334
    se->nEncodings = (CARD16 )((int )se->nEncodings + 1);
#line 334
    if (*((char *)(& endianTest))) {
#line 334
      *(encs + tmp___3) = (unsigned int )(4 << 24);
    } else {
#line 334
      *(encs + tmp___3) = (CARD32 )4;
    }
  }
#line 335
  if (addRRE) {
#line 336
    tmp___4 = se->nEncodings;
#line 336
    se->nEncodings = (CARD16 )((int )se->nEncodings + 1);
#line 336
    if (*((char *)(& endianTest))) {
#line 336
      *(encs + tmp___4) = (unsigned int )(2 << 24);
    } else {
#line 336
      *(encs + tmp___4) = (CARD32 )2;
    }
  }
#line 338
  len = 4 + (int )se->nEncodings * 4;
#line 340
  if (*((char *)(& endianTest))) {
#line 340
    se->nEncodings = (CARD16 )((((int )se->nEncodings & 255) << 8) | (((int )se->nEncodings >> 8) & 255));
  } else {
#line 340
    se->nEncodings = se->nEncodings;
  }
  {
#line 342
  tmp___5 = WriteExact(rfbsock, buf, len);
  }
#line 342
  if (! tmp___5) {
#line 342
    return (0);
  }
#line 344
  return (1);
}
}
#line 351 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/rfbproto.c"
int SendFramebufferUpdateRequest(int x , int y , int w , int h , int incremental ) 
{ 
  rfbFramebufferUpdateRequestMsg fur ;
  int tmp ;

  {
#line 356
  fur.type = (CARD8 )3;
#line 357
  if (incremental) {
#line 357
    fur.incremental = (CARD8 )1;
  } else {
#line 357
    fur.incremental = (CARD8 )0;
  }
#line 358
  if (*((char *)(& endianTest))) {
#line 358
    fur.x = (CARD16 )(((x & 255) << 8) | ((x >> 8) & 255));
  } else {
#line 358
    fur.x = (CARD16 )x;
  }
#line 359
  if (*((char *)(& endianTest))) {
#line 359
    fur.y = (CARD16 )(((y & 255) << 8) | ((y >> 8) & 255));
  } else {
#line 359
    fur.y = (CARD16 )y;
  }
#line 360
  if (*((char *)(& endianTest))) {
#line 360
    fur.w = (CARD16 )(((w & 255) << 8) | ((w >> 8) & 255));
  } else {
#line 360
    fur.w = (CARD16 )w;
  }
#line 361
  if (*((char *)(& endianTest))) {
#line 361
    fur.h = (CARD16 )(((h & 255) << 8) | ((h >> 8) & 255));
  } else {
#line 361
    fur.h = (CARD16 )h;
  }
  {
#line 363
  tmp = WriteExact(rfbsock, (char *)(& fur), 10);
  }
#line 363
  if (! tmp) {
#line 364
    return (0);
  }
#line 366
  return (1);
}
}
#line 373 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/rfbproto.c"
int SendPointerEvent(int x , int y , int buttonMask ) 
{ 
  rfbPointerEventMsg pe ;
  int tmp ;

  {
  {
#line 378
  last_event_time = time(0);
#line 380
  pe.type = (CARD8 )5;
#line 381
  pe.buttonMask = (CARD8 )buttonMask;
  }
#line 386
  if (*((char *)(& endianTest))) {
#line 386
    pe.x = (CARD16 )(((x & 255) << 8) | ((x >> 8) & 255));
  } else {
#line 386
    pe.x = (CARD16 )x;
  }
#line 387
  if (*((char *)(& endianTest))) {
#line 387
    pe.y = (CARD16 )(((y & 255) << 8) | ((y >> 8) & 255));
  } else {
#line 387
    pe.y = (CARD16 )y;
  }
  {
#line 389
  tmp = WriteExact(rfbsock, (char *)(& pe), 6);
  }
#line 389
  return (tmp);
}
}
#line 397 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/rfbproto.c"
int SendKeyEvent(CARD32 key , int down ) 
{ 
  rfbKeyEventMsg ke ;
  int tmp ;

  {
  {
#line 402
  last_event_time = time(0);
#line 404
  ke.type = (CARD8 )4;
  }
#line 405
  if (down) {
#line 405
    ke.down = (CARD8 )1;
  } else {
#line 405
    ke.down = (CARD8 )0;
  }
#line 406
  if (*((char *)(& endianTest))) {
#line 406
    ke.key = ((((key & 4278190080U) >> 24) | ((key & 16711680U) >> 8)) | ((key & 65280U) << 8)) | ((key & 255U) << 24);
  } else {
#line 406
    ke.key = key;
  }
  {
#line 407
  tmp = WriteExact(rfbsock, (char *)(& ke), 8);
  }
#line 407
  return (tmp);
}
}
#line 420
extern int ( /* missing proto */  isspace)() ;
#line 433
extern int ( /* missing proto */  isalpha)() ;
#line 433
extern int ( /* missing proto */  isdigit)() ;
#line 414 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/rfbproto.c"
static int LooksLikeURL(char const   *str , int len ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 420
    if (len != 0) {
      {
#line 420
      tmp = isspace((int const   )*str);
      }
#line 420
      if (! tmp) {
#line 420
        goto while_break;
      }
    } else {
#line 420
      goto while_break;
    }
#line 421
    str ++;
#line 421
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 423
  if (len == 0) {
#line 424
    return (0);
  }
  {
#line 431
  tmp___2 = isalpha((int const   )*str);
  }
#line 431
  if (tmp___2) {
#line 432
    str ++;
#line 432
    len --;
    {
#line 433
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 433
      if (len != 0) {
        {
#line 433
        tmp___0 = isalpha((int const   )*str);
        }
#line 433
        if (! tmp___0) {
          {
#line 433
          tmp___1 = isdigit((int const   )*str);
          }
#line 433
          if (! tmp___1) {
#line 433
            if (! ((int const   )*str == 46)) {
#line 433
              if (! ((int const   )*str == 43)) {
#line 433
                if (! ((int const   )*str == 45)) {
#line 433
                  goto while_break___0;
                }
              }
            }
          }
        }
      } else {
#line 433
        goto while_break___0;
      }
#line 436
      str ++;
#line 436
      len --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 438
    if (len >= 3) {
#line 438
      if ((int const   )*(str + 0) == 58) {
#line 438
        if ((int const   )*(str + 1) == 47) {
#line 438
          if ((int const   )*(str + 2) == 47) {
#line 439
            return (1);
          }
        }
      }
    }
  }
#line 443
  return (0);
}
}
#line 450 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/rfbproto.c"
int SendClientCutText(char *str , int len ) 
{ 
  rfbClientCutTextMsg cct ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 455
  last_event_time = time(0);
  }
#line 457
  if (trimsel) {
    {
#line 457
    tmp___1 = LooksLikeURL((char const   *)str, len);
    }
#line 457
    if (tmp___1) {
      {
#line 461
      while (1) {
        while_continue: /* CIL Label */ ;
#line 461
        if (len != 0) {
          {
#line 461
          tmp = isspace((int )*(str + 0));
          }
#line 461
          if (! tmp) {
#line 461
            goto while_break;
          }
        } else {
#line 461
          goto while_break;
        }
#line 462
        str ++;
#line 463
        len --;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 465
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 465
        if (len != 0) {
          {
#line 465
          tmp___0 = isspace((int )*(str + (len - 1)));
          }
#line 465
          if (! tmp___0) {
#line 465
            goto while_break___0;
          }
        } else {
#line 465
          goto while_break___0;
        }
#line 466
        *(str + (len - 1)) = (char )'\000';
#line 467
        len --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 471
  cct.type = (CARD8 )6;
#line 472
  if (*((char *)(& endianTest))) {
#line 472
    cct.length = (((((unsigned int )len & 4278190080U) >> 24) | (unsigned int )((len & 16711680) >> 8)) | (unsigned int )((len & 65280) << 8)) | (unsigned int )((len & 255) << 24);
  } else {
#line 472
    cct.length = (CARD32 )len;
  }
  {
#line 473
  tmp___2 = WriteExact(rfbsock, (char *)(& cct), 8);
  }
#line 473
  if (tmp___2) {
    {
#line 473
    tmp___3 = WriteExact(rfbsock, str, len);
    }
#line 473
    if (tmp___3) {
#line 473
      tmp___4 = 1;
    } else {
#line 473
      tmp___4 = 0;
    }
  } else {
#line 473
    tmp___4 = 0;
  }
#line 473
  return (tmp___4);
}
}
#line 762
void handle_cut_text(char *str , size_t len ) ;
#line 483 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/rfbproto.c"
int HandleRFBServerMessage(void) 
{ 
  rfbServerToClientMsg msg ;
  int tmp ;
  int i ;
  CARD16 rgb[3] ;
  int tmp___0 ;
  int tmp___1 ;
  rfbFramebufferUpdateRectHeader rect ;
  int linesToRead ;
  int bytesPerLine ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  rfbCopyRect cr ;
  int tmp___5 ;
  rfbRREHeader hdr ;
  CARD8 pix8 ;
  CARD16 pix16 ;
  CARD32 pix32 ;
  rfbRectangle subrect ;
  int j ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  rfbRREHeader hdr___0 ;
  CARD8 pix8___0 ;
  CARD16 pix16___0 ;
  CARD32 pix32___0 ;
  CARD8 *ptr ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char *str ;
  int tmp___26 ;
  void *tmp___27 ;
  int tmp___28 ;

  {
  {
#line 488
  tmp = ReadExact(rfbsock, (char *)(& msg), 1);
  }
#line 488
  if (! tmp) {
#line 489
    return (0);
  }
  {
#line 493
  if ((int )msg.type == 1) {
#line 493
    goto case_1;
  }
#line 514
  if ((int )msg.type == 0) {
#line 514
    goto case_0;
  }
#line 753
  if ((int )msg.type == 2) {
#line 753
    goto case_2___0;
  }
#line 759
  if ((int )msg.type == 3) {
#line 759
    goto case_3;
  }
#line 780
  goto switch_default___0;
  case_1: /* CIL Label */ 
  {
#line 499
  tmp___0 = ReadExact(rfbsock, (char *)(& msg) + 1, 5);
  }
#line 499
  if (! tmp___0) {
#line 501
    return (0);
  }
#line 503
  if (*((char *)(& endianTest))) {
#line 503
    msg.scme.firstColour = (CARD16 )((((int )msg.scme.firstColour & 255) << 8) | (((int )msg.scme.firstColour >> 8) & 255));
  } else {
#line 503
    msg.scme.firstColour = msg.scme.firstColour;
  }
#line 504
  if (*((char *)(& endianTest))) {
#line 504
    msg.scme.nColours = (CARD16 )((((int )msg.scme.nColours & 255) << 8) | (((int )msg.scme.nColours >> 8) & 255));
  } else {
#line 504
    msg.scme.nColours = msg.scme.nColours;
  }
#line 506
  i = 0;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (i < (int )msg.scme.nColours)) {
#line 506
      goto while_break;
    }
    {
#line 507
    tmp___1 = ReadExact(rfbsock, (char *)(rgb), 6);
    }
#line 507
    if (! tmp___1) {
#line 508
      return (0);
    }
#line 506
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 511
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 524
  tmp___2 = ReadExact(rfbsock, (char *)(& msg.fu) + 1, 3);
  }
#line 524
  if (! tmp___2) {
#line 526
    return (0);
  }
#line 528
  if (*((char *)(& endianTest))) {
#line 528
    msg.fu.nRects = (CARD16 )((((int )msg.fu.nRects & 255) << 8) | (((int )msg.fu.nRects >> 8) & 255));
  } else {
#line 528
    msg.fu.nRects = msg.fu.nRects;
  }
#line 530
  i___0 = 0;
  {
#line 530
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 530
    if (! (i___0 < (int )msg.fu.nRects)) {
#line 530
      goto while_break___0;
    }
    {
#line 531
    tmp___3 = ReadExact(rfbsock, (char *)(& rect), 12);
    }
#line 531
    if (! tmp___3) {
#line 533
      return (0);
    }
#line 535
    if (*((char *)(& endianTest))) {
#line 535
      rect.r.x = (CARD16 )((((int )rect.r.x & 255) << 8) | (((int )rect.r.x >> 8) & 255));
    } else {
#line 535
      rect.r.x = rect.r.x;
    }
#line 536
    if (*((char *)(& endianTest))) {
#line 536
      rect.r.y = (CARD16 )((((int )rect.r.y & 255) << 8) | (((int )rect.r.y >> 8) & 255));
    } else {
#line 536
      rect.r.y = rect.r.y;
    }
#line 537
    if (*((char *)(& endianTest))) {
#line 537
      rect.r.w = (CARD16 )((((int )rect.r.w & 255) << 8) | (((int )rect.r.w >> 8) & 255));
    } else {
#line 537
      rect.r.w = rect.r.w;
    }
#line 538
    if (*((char *)(& endianTest))) {
#line 538
      rect.r.h = (CARD16 )((((int )rect.r.h & 255) << 8) | (((int )rect.r.h >> 8) & 255));
    } else {
#line 538
      rect.r.h = rect.r.h;
    }
#line 540
    if (*((char *)(& endianTest))) {
#line 540
      rect.encoding = ((((rect.encoding & 4278190080U) >> 24) | ((rect.encoding & 16711680U) >> 8)) | ((rect.encoding & 65280U) << 8)) | ((rect.encoding & 255U) << 24);
    } else {
#line 540
      rect.encoding = rect.encoding;
    }
#line 542
    if ((int )rect.r.x + (int )rect.r.w > (int )si.framebufferWidth) {
      {
#line 545
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: rect too large: %dx%d at (%d, %d)\n",
              programName, (int )rect.r.w, (int )rect.r.h, (int )rect.r.x, (int )rect.r.y);
      }
#line 547
      return (0);
    } else
#line 542
    if ((int )rect.r.y + (int )rect.r.h > (int )si.framebufferHeight) {
      {
#line 545
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: rect too large: %dx%d at (%d, %d)\n",
              programName, (int )rect.r.w, (int )rect.r.h, (int )rect.r.x, (int )rect.r.y);
      }
#line 547
      return (0);
    }
#line 550
    if ((int )rect.r.h * (int )rect.r.w == 0) {
      {
#line 551
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: zero size rect - ignoring\n",
              programName);
      }
#line 552
      goto __Cont;
    }
    {
#line 557
    if (rect.encoding == 0U) {
#line 557
      goto case_0___0;
    }
#line 576
    if (rect.encoding == 1U) {
#line 576
      goto case_1___0;
    }
#line 589
    if (rect.encoding == 2U) {
#line 589
      goto case_2;
    }
#line 660
    if (rect.encoding == 4U) {
#line 660
      goto case_4;
    }
#line 716
    if (rect.encoding == 5U) {
#line 716
      goto case_5;
    }
#line 741
    goto switch_default;
    case_0___0: /* CIL Label */ 
#line 559
    bytesPerLine = ((int )rect.r.w * (int )si.format.bitsPerPixel) / 8;
#line 560
    linesToRead = 307200 / bytesPerLine;
    {
#line 562
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 562
      if (! ((int )rect.r.h > 0)) {
#line 562
        goto while_break___1;
      }
#line 563
      if (linesToRead > (int )rect.r.h) {
#line 564
        linesToRead = (int )rect.r.h;
      }
      {
#line 566
      tmp___4 = ReadExact(rfbsock, buffer, bytesPerLine * linesToRead);
      }
#line 566
      if (! tmp___4) {
#line 567
        return (0);
      }
#line 570
      rect.r.h = (CARD16 )((int )rect.r.h - linesToRead);
#line 571
      rect.r.y = (CARD16 )((int )rect.r.y + linesToRead);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 574
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 583
    tmp___5 = ReadExact(rfbsock, (char *)(& cr), 4);
    }
#line 583
    if (! tmp___5) {
#line 584
      return (0);
    }
#line 586
    goto switch_break___0;
    case_2: /* CIL Label */ 
    {
#line 603
    tmp___6 = ReadExact(rfbsock, (char *)(& hdr), 4);
    }
#line 603
    if (! tmp___6) {
#line 604
      return (0);
    }
#line 606
    if (*((char *)(& endianTest))) {
#line 606
      hdr.nSubrects = ((((hdr.nSubrects & 4278190080U) >> 24) | ((hdr.nSubrects & 16711680U) >> 8)) | ((hdr.nSubrects & 65280U) << 8)) | ((hdr.nSubrects & 255U) << 24);
    } else {
#line 606
      hdr.nSubrects = hdr.nSubrects;
    }
    {
#line 610
    if ((int )si.format.bitsPerPixel == 8) {
#line 610
      goto case_8;
    }
#line 625
    if ((int )si.format.bitsPerPixel == 16) {
#line 625
      goto case_16;
    }
#line 641
    if ((int )si.format.bitsPerPixel == 32) {
#line 641
      goto case_32;
    }
#line 608
    goto switch_break___1;
    case_8: /* CIL Label */ 
    {
#line 611
    tmp___7 = ReadExact(rfbsock, (char *)(& pix8), 1);
    }
#line 611
    if (! tmp___7) {
#line 612
      return (0);
    }
#line 615
    j = 0;
    {
#line 615
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 615
      if (! ((CARD32 )j < hdr.nSubrects)) {
#line 615
        goto while_break___2;
      }
      {
#line 616
      tmp___8 = ReadExact(rfbsock, (char *)(& pix8), 1);
      }
#line 616
      if (! tmp___8) {
#line 617
        return (0);
      }
      {
#line 619
      tmp___9 = ReadExact(rfbsock, (char *)(& subrect), 8);
      }
#line 619
      if (! tmp___9) {
#line 621
        return (0);
      }
#line 615
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 623
    goto switch_break___1;
    case_16: /* CIL Label */ 
    {
#line 626
    tmp___10 = ReadExact(rfbsock, (char *)(& pix16), 2);
    }
#line 626
    if (! tmp___10) {
#line 627
      return (0);
    }
#line 630
    j = 0;
    {
#line 630
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 630
      if (! ((CARD32 )j < hdr.nSubrects)) {
#line 630
        goto while_break___3;
      }
      {
#line 631
      tmp___11 = ReadExact(rfbsock, (char *)(& pix16), 2);
      }
#line 631
      if (! tmp___11) {
#line 632
        return (0);
      }
      {
#line 634
      tmp___12 = ReadExact(rfbsock, (char *)(& subrect), 8);
      }
#line 634
      if (! tmp___12) {
#line 636
        return (0);
      }
#line 630
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 639
    goto switch_break___1;
    case_32: /* CIL Label */ 
    {
#line 642
    tmp___13 = ReadExact(rfbsock, (char *)(& pix32), 4);
    }
#line 642
    if (! tmp___13) {
#line 643
      return (0);
    }
#line 646
    j = 0;
    {
#line 646
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 646
      if (! ((CARD32 )j < hdr.nSubrects)) {
#line 646
        goto while_break___4;
      }
      {
#line 647
      tmp___14 = ReadExact(rfbsock, (char *)(& pix32), 4);
      }
#line 647
      if (! tmp___14) {
#line 648
        return (0);
      }
      {
#line 650
      tmp___15 = ReadExact(rfbsock, (char *)(& subrect), 8);
      }
#line 650
      if (! tmp___15) {
#line 652
        return (0);
      }
#line 646
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 655
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 657
    goto switch_break___0;
    case_4: /* CIL Label */ 
    {
#line 676
    tmp___16 = ReadExact(rfbsock, (char *)(& hdr___0), 4);
    }
#line 676
    if (! tmp___16) {
#line 677
      return (0);
    }
#line 679
    if (*((char *)(& endianTest))) {
#line 679
      hdr___0.nSubrects = ((((hdr___0.nSubrects & 4278190080U) >> 24) | ((hdr___0.nSubrects & 16711680U) >> 8)) | ((hdr___0.nSubrects & 65280U) << 8)) | ((hdr___0.nSubrects & 255U) << 24);
    } else {
#line 679
      hdr___0.nSubrects = hdr___0.nSubrects;
    }
    {
#line 683
    if ((int )si.format.bitsPerPixel == 8) {
#line 683
      goto case_8___0;
    }
#line 691
    if ((int )si.format.bitsPerPixel == 16) {
#line 691
      goto case_16___0;
    }
#line 703
    if ((int )si.format.bitsPerPixel == 32) {
#line 703
      goto case_32___0;
    }
#line 681
    goto switch_break___2;
    case_8___0: /* CIL Label */ 
    {
#line 684
    tmp___17 = ReadExact(rfbsock, (char *)(& pix8___0), 1);
    }
#line 684
    if (! tmp___17) {
#line 685
      return (0);
    }
    {
#line 687
    tmp___18 = ReadExact(rfbsock, buffer, (int )(hdr___0.nSubrects * 5U));
    }
#line 687
    if (! tmp___18) {
#line 688
      return (0);
    }
#line 689
    goto switch_break___2;
    case_16___0: /* CIL Label */ 
    {
#line 692
    tmp___19 = ReadExact(rfbsock, (char *)(& pix16___0), 2);
    }
#line 692
    if (! tmp___19) {
#line 693
      return (0);
    }
    {
#line 696
    tmp___20 = ReadExact(rfbsock, buffer, (int )(hdr___0.nSubrects * 6U));
    }
#line 696
    if (! tmp___20) {
#line 697
      return (0);
    }
#line 699
    ptr = (CARD8 *)(buffer);
#line 701
    goto switch_break___2;
    case_32___0: /* CIL Label */ 
    {
#line 704
    tmp___21 = ReadExact(rfbsock, (char *)(& pix32___0), 4);
    }
#line 704
    if (! tmp___21) {
#line 705
      return (0);
    }
    {
#line 708
    tmp___22 = ReadExact(rfbsock, buffer, (int )(hdr___0.nSubrects * 8U));
    }
#line 708
    if (! tmp___22) {
#line 709
      return (0);
    }
#line 711
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 713
    goto switch_break___0;
    case_5: /* CIL Label */ 
    {
#line 722
    if ((int )si.format.bitsPerPixel == 8) {
#line 722
      goto case_8___1;
    }
#line 727
    if ((int )si.format.bitsPerPixel == 16) {
#line 727
      goto case_16___1;
    }
#line 732
    if ((int )si.format.bitsPerPixel == 32) {
#line 732
      goto case_32___1;
    }
#line 721
    goto switch_break___3;
    case_8___1: /* CIL Label */ 
    {
#line 723
    tmp___23 = HandleHextileEncoding8((int )rect.r.x, (int )rect.r.y, (int )rect.r.w,
                                      (int )rect.r.h);
    }
#line 723
    if (! tmp___23) {
#line 725
      return (0);
    }
#line 726
    goto switch_break___3;
    case_16___1: /* CIL Label */ 
    {
#line 728
    tmp___24 = HandleHextileEncoding16((int )rect.r.x, (int )rect.r.y, (int )rect.r.w,
                                       (int )rect.r.h);
    }
#line 728
    if (! tmp___24) {
#line 730
      return (0);
    }
#line 731
    goto switch_break___3;
    case_32___1: /* CIL Label */ 
    {
#line 733
    tmp___25 = HandleHextileEncoding32((int )rect.r.x, (int )rect.r.y, (int )rect.r.w,
                                       (int )rect.r.h);
    }
#line 733
    if (! tmp___25) {
#line 735
      return (0);
    }
#line 736
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 738
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 742
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unknown rect encoding %d\n",
            programName, (int )rect.encoding);
    }
#line 744
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 530
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 748
  sendUpdateRequest = 1;
#line 750
  goto switch_break;
  case_2___0: /* CIL Label */ 
#line 757
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 764
  tmp___26 = ReadExact(rfbsock, (char *)(& msg) + 1, 7);
  }
#line 764
  if (! tmp___26) {
#line 766
    return (0);
  }
#line 768
  if (*((char *)(& endianTest))) {
#line 768
    msg.sct.length = ((((msg.sct.length & 4278190080U) >> 24) | ((msg.sct.length & 16711680U) >> 8)) | ((msg.sct.length & 65280U) << 8)) | ((msg.sct.length & 255U) << 24);
  } else {
#line 768
    msg.sct.length = msg.sct.length;
  }
  {
#line 770
  tmp___27 = malloc((size_t )(msg.sct.length + 1U));
#line 770
  str = (char *)tmp___27;
#line 771
  tmp___28 = ReadExact(rfbsock, str, (int )msg.sct.length);
  }
#line 771
  if (! tmp___28) {
#line 772
    return (0);
  }
  {
#line 774
  *(str + msg.sct.length) = (char)0;
#line 775
  handle_cut_text(str, (size_t )msg.sct.length);
  }
#line 777
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 781
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unknown message type %d from VNC server\n",
          programName, (int )msg.type);
  }
#line 783
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 786
  return (1);
}
}
#line 864 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/rfbproto.c"
static int HandleHextileEncoding8(int rx , int ry , int rw , int rh ) 
{ 
  CARD8 bg ;
  CARD8 fg ;
  CARD8 *ptr ;
  int x ;
  int y ;
  int w ;
  int h ;
  CARD8 subencoding ;
  CARD8 nSubrects ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 864
  y = ry;
  {
#line 864
  while (1) {
    while_continue: /* CIL Label */ ;
#line 864
    if (! (y < ry + rh)) {
#line 864
      goto while_break;
    }
#line 864
    x = rx;
    {
#line 864
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 864
      if (! (x < rx + rw)) {
#line 864
        goto while_break___0;
      }
#line 864
      h = 16;
#line 864
      w = h;
#line 864
      if ((rx + rw) - x < 16) {
#line 864
        w = (rx + rw) - x;
      }
#line 864
      if ((ry + rh) - y < 16) {
#line 864
        h = (ry + rh) - y;
      }
      {
#line 864
      tmp = ReadExact(rfbsock, (char *)(& subencoding), 1);
      }
#line 864
      if (! tmp) {
#line 864
        return (0);
      }
#line 864
      if ((int )subencoding & 1) {
        {
#line 864
        tmp___0 = ReadExact(rfbsock, buffer, w * h);
        }
#line 864
        if (! tmp___0) {
#line 864
          return (0);
        }
#line 864
        goto __Cont;
      }
#line 864
      if ((int )subencoding & (1 << 1)) {
        {
#line 864
        tmp___1 = ReadExact(rfbsock, (char *)(& bg), 1);
        }
#line 864
        if (! tmp___1) {
#line 864
          return (0);
        }
      }
#line 864
      if ((int )subencoding & (1 << 2)) {
        {
#line 864
        tmp___2 = ReadExact(rfbsock, (char *)(& fg), 1);
        }
#line 864
        if (! tmp___2) {
#line 864
          return (0);
        }
      }
#line 864
      if (! ((int )subencoding & (1 << 3))) {
#line 864
        goto __Cont;
      }
      {
#line 864
      tmp___3 = ReadExact(rfbsock, (char *)(& nSubrects), 1);
      }
#line 864
      if (! tmp___3) {
#line 864
        return (0);
      }
#line 864
      ptr = (CARD8 *)(buffer);
#line 864
      if ((int )subencoding & (1 << 4)) {
        {
#line 864
        tmp___4 = ReadExact(rfbsock, buffer, (int )nSubrects * 3);
        }
#line 864
        if (! tmp___4) {
#line 864
          return (0);
        }
      } else {
        {
#line 864
        tmp___5 = ReadExact(rfbsock, buffer, (int )nSubrects * 2);
        }
#line 864
        if (! tmp___5) {
#line 864
          return (0);
        }
      }
      __Cont: /* CIL Label */ 
#line 864
      x += 16;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 864
    y += 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 864
  return (1);
}
}
#line 865 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/rfbproto.c"
static int HandleHextileEncoding16(int rx , int ry , int rw , int rh ) 
{ 
  CARD16 bg ;
  CARD16 fg ;
  CARD8 *ptr ;
  int x ;
  int y ;
  int w ;
  int h ;
  CARD8 subencoding ;
  CARD8 nSubrects ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 865
  y = ry;
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if (! (y < ry + rh)) {
#line 865
      goto while_break;
    }
#line 865
    x = rx;
    {
#line 865
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 865
      if (! (x < rx + rw)) {
#line 865
        goto while_break___0;
      }
#line 865
      h = 16;
#line 865
      w = h;
#line 865
      if ((rx + rw) - x < 16) {
#line 865
        w = (rx + rw) - x;
      }
#line 865
      if ((ry + rh) - y < 16) {
#line 865
        h = (ry + rh) - y;
      }
      {
#line 865
      tmp = ReadExact(rfbsock, (char *)(& subencoding), 1);
      }
#line 865
      if (! tmp) {
#line 865
        return (0);
      }
#line 865
      if ((int )subencoding & 1) {
        {
#line 865
        tmp___0 = ReadExact(rfbsock, buffer, (w * h) * 2);
        }
#line 865
        if (! tmp___0) {
#line 865
          return (0);
        }
#line 865
        goto __Cont;
      }
#line 865
      if ((int )subencoding & (1 << 1)) {
        {
#line 865
        tmp___1 = ReadExact(rfbsock, (char *)(& bg), 2);
        }
#line 865
        if (! tmp___1) {
#line 865
          return (0);
        }
      }
#line 865
      if ((int )subencoding & (1 << 2)) {
        {
#line 865
        tmp___2 = ReadExact(rfbsock, (char *)(& fg), 2);
        }
#line 865
        if (! tmp___2) {
#line 865
          return (0);
        }
      }
#line 865
      if (! ((int )subencoding & (1 << 3))) {
#line 865
        goto __Cont;
      }
      {
#line 865
      tmp___3 = ReadExact(rfbsock, (char *)(& nSubrects), 1);
      }
#line 865
      if (! tmp___3) {
#line 865
        return (0);
      }
#line 865
      ptr = (CARD8 *)(buffer);
#line 865
      if ((int )subencoding & (1 << 4)) {
        {
#line 865
        tmp___4 = ReadExact(rfbsock, buffer, (int )nSubrects * 4);
        }
#line 865
        if (! tmp___4) {
#line 865
          return (0);
        }
      } else {
        {
#line 865
        tmp___5 = ReadExact(rfbsock, buffer, (int )nSubrects * 2);
        }
#line 865
        if (! tmp___5) {
#line 865
          return (0);
        }
      }
      __Cont: /* CIL Label */ 
#line 865
      x += 16;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 865
    y += 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 865
  return (1);
}
}
#line 866 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/rfbproto.c"
static int HandleHextileEncoding32(int rx , int ry , int rw , int rh ) 
{ 
  CARD32 bg ;
  CARD32 fg ;
  CARD8 *ptr ;
  int x ;
  int y ;
  int w ;
  int h ;
  CARD8 subencoding ;
  CARD8 nSubrects ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 866
  y = ry;
  {
#line 866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 866
    if (! (y < ry + rh)) {
#line 866
      goto while_break;
    }
#line 866
    x = rx;
    {
#line 866
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 866
      if (! (x < rx + rw)) {
#line 866
        goto while_break___0;
      }
#line 866
      h = 16;
#line 866
      w = h;
#line 866
      if ((rx + rw) - x < 16) {
#line 866
        w = (rx + rw) - x;
      }
#line 866
      if ((ry + rh) - y < 16) {
#line 866
        h = (ry + rh) - y;
      }
      {
#line 866
      tmp = ReadExact(rfbsock, (char *)(& subencoding), 1);
      }
#line 866
      if (! tmp) {
#line 866
        return (0);
      }
#line 866
      if ((int )subencoding & 1) {
        {
#line 866
        tmp___0 = ReadExact(rfbsock, buffer, (w * h) * 4);
        }
#line 866
        if (! tmp___0) {
#line 866
          return (0);
        }
#line 866
        goto __Cont;
      }
#line 866
      if ((int )subencoding & (1 << 1)) {
        {
#line 866
        tmp___1 = ReadExact(rfbsock, (char *)(& bg), 4);
        }
#line 866
        if (! tmp___1) {
#line 866
          return (0);
        }
      }
#line 866
      if ((int )subencoding & (1 << 2)) {
        {
#line 866
        tmp___2 = ReadExact(rfbsock, (char *)(& fg), 4);
        }
#line 866
        if (! tmp___2) {
#line 866
          return (0);
        }
      }
#line 866
      if (! ((int )subencoding & (1 << 3))) {
#line 866
        goto __Cont;
      }
      {
#line 866
      tmp___3 = ReadExact(rfbsock, (char *)(& nSubrects), 1);
      }
#line 866
      if (! tmp___3) {
#line 866
        return (0);
      }
#line 866
      ptr = (CARD8 *)(buffer);
#line 866
      if ((int )subencoding & (1 << 4)) {
        {
#line 866
        tmp___4 = ReadExact(rfbsock, buffer, (int )nSubrects * 6);
        }
#line 866
        if (! tmp___4) {
#line 866
          return (0);
        }
      } else {
        {
#line 866
        tmp___5 = ReadExact(rfbsock, buffer, (int )nSubrects * 2);
        }
#line 866
        if (! tmp___5) {
#line 866
          return (0);
        }
      }
      __Cont: /* CIL Label */ 
#line 866
      x += 16;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 866
    y += 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 866
  return (1);
}
}
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 50 "./x2vnc.h"
char hostname[256] ;
#line 51
int port ;
#line 78
int debug ;
#line 81
int reconnect ;
#line 89
void processArgs(int argc , char **argv ) ;
#line 127
Display *dpy ;
#line 130
int CreateXWindow(void) ;
#line 131
int HandleXEvents(void) ;
#line 153
void listenForIncomingConnections(void) ;
#line 35 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x2vnc.c"
int temp_file_fd  =    0;
#line 37 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x2vnc.c"
int main(int argc , char **argv ) 
{ 
  fd_set fds ;
  struct timeval tv ;
  long last_fork ;
  char *tmpdir ;
  char tmpfile___0[1024] ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  int status ;
  int pid ;
  int tmp___3 ;
  int tmp___4 ;
  __pid_t tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int __d0 ;
  int __d1 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 43
  processArgs(argc, argv);
  }
#line 45
  if (listenSpecified) {
    {
#line 47
    listenForIncomingConnections();
    }
  } else {
#line 53
    if (reconnect) {
      {
#line 55
      last_fork = 0L;
#line 56
      tmpdir = (char *)"/tmp";
#line 58
      tmp = getenv("TMPDIR");
      }
#line 58
      if (tmp) {
        {
#line 58
        tmp___0 = strlen((char const   *)tmpdir);
        }
#line 58
        if (tmp___0 < 900UL) {
          {
#line 59
          tmpdir = getenv("TMPDIR");
          }
        }
      }
      {
#line 61
      tmp___1 = time(0);
#line 61
      tmp___2 = getpid();
#line 61
      sprintf((char */* __restrict  */)(tmpfile___0), (char const   */* __restrict  */)"%s/x2vnc-%d-%d",
              tmpdir, tmp___2, tmp___1);
#line 66
      temp_file_fd = open((char const   *)(tmpfile___0), 194, 384);
#line 67
      unlink((char const   *)(tmpfile___0));
      }
      {
#line 69
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 74
        tmp___3 = time(0);
        }
#line 74
        if ((long )tmp___3 - last_fork < 1L) {
          {
#line 74
          sleep(2U);
          }
        }
        {
#line 76
        tmp___4 = time(0);
#line 76
        last_fork = (long )tmp___4;
#line 77
        pid = fork();
        }
        {
#line 79
        if (pid == -1) {
#line 79
          goto case_neg_1;
        }
#line 83
        if (pid == 0) {
#line 83
          goto case_0;
        }
#line 86
        goto switch_default;
        case_neg_1: /* CIL Label */ 
        {
#line 80
        perror("fork");
#line 81
        exit(1);
        }
        case_0: /* CIL Label */ 
#line 84
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 87
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 87
          tmp___5 = waitpid(pid, & status, 0);
          }
#line 87
          if (tmp___5 < 0) {
            {
#line 87
            tmp___6 = __errno_location();
            }
#line 87
            if (! (*tmp___6 == 4)) {
#line 87
              goto while_break___0;
            }
          } else {
#line 87
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 88
        if (debug) {
          {
#line 89
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Child exited with status %d\n",
                  status);
          }
        }
#line 90
        goto while_continue;
        switch_break: /* CIL Label */ ;
        }
#line 92
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 96
    tmp___7 = ConnectToRFBServer((char const   *)(hostname), port);
    }
#line 96
    if (! tmp___7) {
      {
#line 96
      exit(1);
      }
    }
  }
  {
#line 99
  tmp___8 = InitialiseRFBConnection(rfbsock);
  }
#line 99
  if (! tmp___8) {
    {
#line 99
    exit(1);
    }
  }
  {
#line 101
  tmp___9 = CreateXWindow();
  }
#line 101
  if (! tmp___9) {
    {
#line 101
    exit(1);
    }
  }
  {
#line 103
  tmp___10 = SetFormatAndEncodings();
  }
#line 103
  if (! tmp___10) {
    {
#line 104
    exit(1);
    }
  }
  {
#line 108
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 116
    tmp___11 = HandleXEvents();
    }
#line 116
    if (! tmp___11) {
      {
#line 117
      exit(1);
      }
    }
#line 120
    tv.tv_sec = (__time_t )5;
#line 121
    tv.tv_usec = (__suseconds_t )0;
    {
#line 123
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 123
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.__fds_bits[0]): "memory");
#line 123
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 124
    fds.__fds_bits[((_XPrivDisplay )dpy)->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ((_XPrivDisplay )dpy)->fd % (8 * (int )sizeof(__fd_mask ));
#line 125
    fds.__fds_bits[rfbsock / (8 * (int )sizeof(__fd_mask ))] |= 1L << rfbsock % (8 * (int )sizeof(__fd_mask ));
#line 127
    tmp___12 = select(1024, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
                      (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 127
    if (tmp___12 < 0) {
      {
#line 128
      perror("select");
#line 129
      exit(1);
      }
    }
#line 132
    if ((fds.__fds_bits[rfbsock / (8 * (int )sizeof(__fd_mask ))] & (1L << rfbsock % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 133
      tmp___13 = HandleRFBServerMessage();
      }
#line 133
      if (! tmp___13) {
        {
#line 134
        exit(1);
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 139
  return (0);
}
}
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 1527 "/usr/include/X11/Xlib.h"
extern char *XDisplayName(char const   * ) ;
#line 49 "./x2vnc.h"
char *programName  ;
#line 50 "./x2vnc.h"
char hostname[256]  ;
#line 51 "./x2vnc.h"
int port  ;
#line 53
int listenPort ;
#line 53
int flashPort ;
#line 54
char *displayname ;
#line 57 "./x2vnc.h"
CARD32 explicitEncodings[10]  ;
#line 63
int useBGR233 ;
#line 64
int forceOwnCmap ;
#line 65
int forceTruecolour ;
#line 66
int requestedDepth ;
#line 67
char *geometry ;
#line 68
int wmDecorationWidth ;
#line 69
int wmDecorationHeight ;
#line 71
int updateRequestPeriodms ;
#line 76
int rawDelay ;
#line 77
int copyRectDelay ;
#line 80
int resurface ;
#line 84
int noblank ;
#line 85
int no_wakeup_delay ;
#line 87
float acceleration ;
#line 90
void usage(void) ;
#line 126
enum edge_enum edge ;
#line 147
int useSSHTunnel ;
#line 148
char *useSSHGateway ;
#line 36 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int listenSpecified  =    0;
#line 37 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int listenPort  =    0;
#line 37 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int flashPort  =    0;
#line 39 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
char *displayname  =    (char *)((void *)0);
#line 41 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int shareDesktop  =    0;
#line 44 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int nExplicitEncodings  =    0;
#line 45 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int addCopyRect  =    1;
#line 46 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int addRRE  =    1;
#line 47 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int addCoRRE  =    1;
#line 48 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int addHextile  =    1;
#line 50 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int useBGR233  =    0;
#line 51 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int forceOwnCmap  =    0;
#line 52 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int forceTruecolour  =    0;
#line 53 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int resurface  =    0;
#line 54 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int reconnect  =    1;
#line 55 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int requestedDepth  =    0;
#line 56 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
float acceleration  =    (float )1.0;
#line 58 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
char *geometry  =    (char *)((void *)0);
#line 60 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int wmDecorationWidth  =    4;
#line 61 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int wmDecorationHeight  =    24;
#line 63 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
char *passwdFile  =    (char *)((void *)0);
#line 65 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int updateRequestPeriodms  =    0;
#line 67 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int updateRequestX  =    0;
#line 68 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int updateRequestY  =    0;
#line 69 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int updateRequestW  =    0;
#line 70 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int updateRequestH  =    0;
#line 72 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int rawDelay  =    0;
#line 73 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int copyRectDelay  =    0;
#line 75 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int debug  =    0;
#line 76 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int trimsel  =    0;
#line 78 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int noblank  =    0;
#line 79 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
int no_wakeup_delay  =    2147483647;
#line 81 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
void usage(void) 
{ 


  {
  {
#line 83
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"x2vnc version 1.7.2, Copyright (C) 2000 Fredrik Hubinette\nBased on vncviewer which is copyright by AT&T\nx2vnc comes with ABSOLUTELY NO WARRANTY. This is free software,\nand you are welcome to redistribute it under certain conditions.\nSee the file COPYING in the x2vnc source for details.\n\nusage: %s [<options>] <host>:<display#>\n       %s [<options>] -listen [<display#>]\n\n<options> are:\n              [-display <display>]\n              [-version]\n              [-shared]\n              [-north] [-south] [-east] [-west]\n              [-hotkey key]\n              [-passwdfile <passwd-file>]\n              [-resurface]\n              [-edgewidth width]\n              [-desktop desktop]\n              [-timeout seconds]\n              [-wheelhack]\n              [-navhack]\n              [-reversewheel]\n              [-scrolllines lines]\n              [-mac]\n              [-trimsel]\n              [-noblank]\n              [-lockdelay seconds]\n              [-debug]\n              [-accel multiplier]\n              [-noreconnect]\n              [-tunnel]\n              [-via <host>]\n Known extensions:\n",
          programName, programName);
#line 135
  exit(1);
  }
}
}
#line 160
int mac_mode ;
#line 163
int emulate_wheel ;
#line 169
int emulate_nav ;
#line 172
int wheel_button_up ;
#line 181
int edge_width ;
#line 190
int requested_desktop ;
#line 194
long grab_timeout_delay ;
#line 209
int scroll_lines ;
#line 218
void sethotkey(char *key ) ;
#line 138 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/args.c"
void processArgs(int argc , char **argv ) 
{ 
  int i ;
  int argumentSpecified ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  char *display ;
  char *colonPos ;
  struct utsname hostinfo ;
  int tmp___32 ;
  int tmp___33 ;
  size_t tmp___34 ;
  int tmp___35 ;

  {
#line 141
  argumentSpecified = 0;
#line 143
  programName = *(argv + 0);
#line 145
  i = 1;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! (i < argc)) {
#line 145
      goto while_break;
    }
    {
#line 146
    tmp___31 = strcmp((char const   *)*(argv + i), "-display");
    }
#line 146
    if (tmp___31 == 0) {
#line 148
      i ++;
#line 148
      if (i >= argc) {
        {
#line 148
        usage();
        }
      }
#line 149
      displayname = *(argv + i);
    } else {
      {
#line 151
      tmp___30 = strcmp((char const   *)*(argv + i), "-east");
      }
#line 151
      if (tmp___30 == 0) {
#line 152
        edge = (enum edge_enum )0;
      } else {
        {
#line 153
        tmp___29 = strcmp((char const   *)*(argv + i), "-west");
        }
#line 153
        if (tmp___29 == 0) {
#line 154
          edge = (enum edge_enum )1;
        } else {
          {
#line 155
          tmp___28 = strcmp((char const   *)*(argv + i), "-north");
          }
#line 155
          if (tmp___28 == 0) {
#line 156
            edge = (enum edge_enum )2;
          } else {
            {
#line 157
            tmp___27 = strcmp((char const   *)*(argv + i), "-south");
            }
#line 157
            if (tmp___27 == 0) {
#line 158
              edge = (enum edge_enum )3;
            } else {
              {
#line 159
              tmp___26 = strcmp((char const   *)*(argv + i), "-mac");
              }
#line 159
              if (tmp___26 == 0) {
#line 161
                mac_mode = 1;
              } else {
                {
#line 162
                tmp___25 = strcmp((char const   *)*(argv + i), "-nowheel");
                }
#line 162
                if (tmp___25 == 0) {
#line 164
                  emulate_wheel = 0;
                } else {
                  {
#line 165
                  tmp___24 = strcmp((char const   *)*(argv + i), "-wheelhack");
                  }
#line 165
                  if (tmp___24 == 0) {
#line 167
                    emulate_wheel = 1;
                  } else {
                    {
#line 168
                    tmp___23 = strcmp((char const   *)*(argv + i), "-navhack");
                    }
#line 168
                    if (tmp___23 == 0) {
#line 170
                      emulate_nav = 1;
                    } else {
                      {
#line 171
                      tmp___22 = strcmp((char const   *)*(argv + i), "-reversewheel");
                      }
#line 171
                      if (tmp___22 == 0) {
#line 173
                        wheel_button_up = 5;
                      } else {
                        {
#line 174
                        tmp___21 = strcmp((char const   *)*(argv + i), "-resurface");
                        }
#line 174
                        if (tmp___21 == 0) {
#line 175
                          resurface = 1;
                        } else {
                          {
#line 176
                          tmp___20 = strcmp((char const   *)*(argv + i), "-noreconnect");
                          }
#line 176
                          if (tmp___20 == 0) {
#line 177
                            reconnect = 0;
                          } else {
                            {
#line 178
                            tmp___19 = strcmp((char const   *)*(argv + i), "-shared");
                            }
#line 178
                            if (tmp___19 == 0) {
#line 179
                              shareDesktop = 1;
                            } else {
                              {
#line 180
                              tmp___18 = strcmp((char const   *)*(argv + i), "-edgewidth");
                              }
#line 180
                              if (tmp___18 == 0) {
#line 182
                                i ++;
#line 182
                                if (i >= argc) {
                                  {
#line 182
                                  usage();
                                  }
                                }
                                {
#line 183
                                edge_width = atoi((char const   *)*(argv + i));
                                }
#line 184
                                if (edge_width < 0) {
                                  {
#line 186
                                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"x2vnc: -edgewidth cannot be less than 0\n");
#line 187
                                  exit(1);
                                  }
                                }
                              } else {
                                {
#line 189
                                tmp___17 = strcmp((char const   *)*(argv + i), "-desktop");
                                }
#line 189
                                if (tmp___17 == 0) {
#line 191
                                  i ++;
#line 191
                                  if (i >= argc) {
                                    {
#line 191
                                    usage();
                                    }
                                  }
                                  {
#line 192
                                  requested_desktop = atoi((char const   *)*(argv + i));
                                  }
                                } else {
                                  {
#line 193
                                  tmp___16 = strcmp((char const   *)*(argv + i), "-timeout");
                                  }
#line 193
                                  if (tmp___16 == 0) {
#line 195
                                    i ++;
#line 195
                                    if (i >= argc) {
                                      {
#line 195
                                      usage();
                                      }
                                    }
                                    {
#line 196
                                    tmp = atoi((char const   *)*(argv + i));
#line 196
                                    grab_timeout_delay = (long )tmp;
                                    }
#line 197
                                    if (grab_timeout_delay < 0L) {
                                      {
#line 199
                                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"x2vnc: -timeout cannot be less than 0\n");
#line 200
                                      exit(1);
                                      }
                                    }
                                  } else {
                                    {
#line 202
                                    tmp___15 = strcmp((char const   *)*(argv + i),
                                                      "-lockdelay");
                                    }
#line 202
                                    if (tmp___15 == 0) {
#line 203
                                      i ++;
#line 203
                                      if (i >= argc) {
                                        {
#line 203
                                        usage();
                                        }
                                      }
                                      {
#line 204
                                      no_wakeup_delay = atoi((char const   *)*(argv + i));
                                      }
                                    } else {
                                      {
#line 205
                                      tmp___14 = strcmp((char const   *)*(argv + i),
                                                        "-accel");
                                      }
#line 205
                                      if (tmp___14 == 0) {
#line 206
                                        i ++;
#line 206
                                        if (i >= argc) {
                                          {
#line 206
                                          usage();
                                          }
                                        }
                                        {
#line 207
                                        tmp___0 = atof((char const   *)*(argv + i));
#line 207
                                        acceleration = (float )tmp___0;
                                        }
                                      } else {
                                        {
#line 208
                                        tmp___13 = strcmp((char const   *)*(argv + i),
                                                          "-scrolllines");
                                        }
#line 208
                                        if (tmp___13 == 0) {
#line 210
                                          i ++;
#line 210
                                          if (i >= argc) {
                                            {
#line 210
                                            usage();
                                            }
                                          }
                                          {
#line 211
                                          scroll_lines = atoi((char const   *)*(argv + i));
                                          }
#line 212
                                          if (scroll_lines < 1) {
                                            {
#line 214
                                            fprintf((FILE */* __restrict  */)stderr,
                                                    (char const   */* __restrict  */)"x2vnc: -scrollines cannot be less than 1\n");
#line 215
                                            exit(1);
                                            }
                                          }
                                        } else {
                                          {
#line 217
                                          tmp___12 = strcmp((char const   *)*(argv + i),
                                                            "-hotkey");
                                          }
#line 217
                                          if (tmp___12 == 0) {
#line 219
                                            i ++;
#line 219
                                            if (i >= argc) {
                                              {
#line 219
                                              usage();
                                              }
                                            }
                                            {
#line 220
                                            sethotkey(*(argv + i));
                                            }
                                          } else {
                                            {
#line 221
                                            tmp___11 = strcmp((char const   *)*(argv + i),
                                                              "-passwd");
                                            }
#line 221
                                            if (tmp___11 == 0) {
#line 222
                                              i ++;
#line 222
                                              if (i >= argc) {
                                                {
#line 222
                                                usage();
                                                }
                                              }
#line 223
                                              passwdFile = *(argv + i);
                                            } else {
                                              {
#line 224
                                              tmp___10 = strcmp((char const   *)*(argv + i),
                                                                "-passwdfile");
                                              }
#line 224
                                              if (tmp___10 == 0) {
#line 225
                                                i ++;
#line 225
                                                if (i >= argc) {
                                                  {
#line 225
                                                  usage();
                                                  }
                                                }
#line 226
                                                passwdFile = *(argv + i);
                                              } else {
                                                {
#line 227
                                                tmp___9 = strcmp((char const   *)*(argv + i),
                                                                 "-debug");
                                                }
#line 227
                                                if (tmp___9 == 0) {
#line 228
                                                  debug ++;
                                                } else {
                                                  {
#line 229
                                                  tmp___8 = strcmp((char const   *)*(argv + i),
                                                                   "-trimsel");
                                                  }
#line 229
                                                  if (tmp___8 == 0) {
#line 230
                                                    trimsel = 1;
                                                  } else {
                                                    {
#line 231
                                                    tmp___7 = strcmp((char const   *)*(argv + i),
                                                                     "-noblank");
                                                    }
#line 231
                                                    if (tmp___7 == 0) {
#line 232
                                                      noblank = 1;
                                                    } else {
                                                      {
#line 233
                                                      tmp___6 = strcmp((char const   *)*(argv + i),
                                                                       "-tunnel");
                                                      }
#line 233
                                                      if (tmp___6 == 0) {
#line 234
                                                        useSSHTunnel = 1;
                                                      } else {
                                                        {
#line 235
                                                        tmp___5 = strcmp((char const   *)*(argv + i),
                                                                         "-via");
                                                        }
#line 235
                                                        if (tmp___5 == 0) {
#line 236
                                                          i ++;
#line 236
                                                          if (i >= argc) {
                                                            {
#line 236
                                                            usage();
                                                            }
                                                          }
#line 237
                                                          useSSHGateway = *(argv + i);
#line 238
                                                          useSSHTunnel = 1;
                                                        } else {
                                                          {
#line 239
                                                          tmp___4 = strcmp((char const   *)*(argv + i),
                                                                           "-listen");
                                                          }
#line 239
                                                          if (tmp___4 == 0) {
#line 240
                                                            if (argumentSpecified) {
                                                              {
#line 240
                                                              usage();
                                                              }
                                                            }
#line 242
                                                            listenSpecified = 1;
#line 243
                                                            i ++;
#line 243
                                                            if (i < argc) {
                                                              {
#line 244
                                                              tmp___1 = atoi((char const   *)*(argv + i));
#line 244
                                                              listenPort = 5500 + tmp___1;
#line 245
                                                              tmp___2 = atoi((char const   *)*(argv + i));
#line 245
                                                              flashPort = 5400 + tmp___2;
                                                              }
                                                            }
                                                          } else
#line 248
                                                          if ((int )*(*(argv + i) + 0) != 45) {
#line 250
                                                            if (argumentSpecified) {
                                                              {
#line 250
                                                              usage();
                                                              }
                                                            } else
#line 250
                                                            if (listenSpecified) {
                                                              {
#line 250
                                                              usage();
                                                              }
                                                            }
                                                            {
#line 252
                                                            argumentSpecified = 1;
#line 254
                                                            tmp___3 = sscanf((char const   */* __restrict  */)*(argv + i),
                                                                             (char const   */* __restrict  */)"%[^:]:%d",
                                                                             hostname,
                                                                             & port);
                                                            }
#line 254
                                                            if (tmp___3 != 2) {
                                                              {
#line 254
                                                              usage();
                                                              }
                                                            }
#line 256
                                                            if (port < 100) {
#line 257
                                                              port += 5900;
                                                            }
                                                          } else {
                                                            {
#line 260
                                                            usage();
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 145
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  if (listenSpecified) {
#line 265
    if (listenPort == 0) {
      {
#line 270
      display = XDisplayName((char const   *)displayname);
#line 271
      colonPos = strchr((char const   *)display, ':');
#line 273
      uname(& hostinfo);
      }
#line 275
      if (colonPos) {
#line 275
        if ((unsigned long )colonPos == (unsigned long )display) {
          {
#line 279
          tmp___32 = atoi((char const   *)(colonPos + 1));
#line 279
          listenPort = 5500 + tmp___32;
#line 280
          tmp___33 = atoi((char const   *)(colonPos + 1));
#line 280
          flashPort = 5400 + tmp___33;
          }
        } else {
          {
#line 275
          tmp___34 = strlen((char const   *)(hostinfo.nodename));
#line 275
          tmp___35 = strncmp((char const   *)(hostinfo.nodename), (char const   *)display,
                             tmp___34);
          }
#line 275
          if (tmp___35 == 0) {
            {
#line 279
            tmp___32 = atoi((char const   *)(colonPos + 1));
#line 279
            listenPort = 5500 + tmp___32;
#line 280
            tmp___33 = atoi((char const   *)(colonPos + 1));
#line 280
            flashPort = 5400 + tmp___33;
            }
          } else {
            {
#line 283
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot work out which display number to listen on.\n",
                    programName);
#line 285
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please specify explicitly with -listen <num>\n");
#line 287
            exit(1);
            }
          }
        }
      } else {
        {
#line 283
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot work out which display number to listen on.\n",
                programName);
#line 285
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please specify explicitly with -listen <num>\n");
#line 287
        exit(1);
        }
      }
    }
  } else
#line 291
  if (! argumentSpecified) {
    {
#line 293
    usage();
    }
  }
#line 296
  return;
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 162 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern  __attribute__((__nothrow__)) __pid_t wait3(union wait *__stat_loc , int __options ,
                                                   struct rusage *__usage ) ;
#line 1495 "/usr/include/X11/Xlib.h"
extern Display *XOpenDisplay(char const   * ) ;
#line 1592
extern Font XLoadFont(Display * , char const   * ) ;
#line 1596
extern GC XCreateGC(Display * , Drawable  , unsigned long  , XGCValues * ) ;
#line 1648
extern Window XCreateWindow(Display * , Window  , int  , int  , unsigned int  , unsigned int  ,
                            unsigned int  , int  , unsigned int  , Visual * , unsigned long  ,
                            XSetWindowAttributes * ) ;
#line 1667
extern char **XListFonts(Display * , char const   * , int  , int * ) ;
#line 2022
extern int XBell(Display * , int  ) ;
#line 2104
extern int XCheckIfEvent(Display * , XEvent * , int (*)(Display * , XEvent * , XPointer  ) ,
                         XPointer  ) ;
#line 2172
extern int XCloseDisplay(Display * ) ;
#line 2255
extern int XDestroyWindow(Display * , Window  ) ;
#line 2416
extern int XDrawString(Display * , Drawable  , GC  , int  , int  , char const   * ,
                       int  ) ;
#line 2519
extern int XFlush(Display * ) ;
#line 2523
extern int XForceScreenSaver(Display * , int  ) ;
#line 2565
extern int XFreeFontNames(char ** ) ;
#line 2818
extern int XMapWindow(Display * , Window  ) ;
#line 132 "./x2vnc.h"
int AllXEventsPredicate(Display *dpy___0 , XEvent *ev , char *arg ) ;
#line 141
int ListenAtTcpPort(int port___0 ) ;
#line 144
int AcceptTcpConnection(int listenSock ) ;
#line 33 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/listen.c"
static Font flashFont  ;
#line 35
static void getFlashFont(Display *d ) ;
#line 36
static void flashDisplay(Display *d , char *user ) ;
#line 38 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/listen.c"
void listenForIncomingConnections(void) 
{ 
  Display *d ;
  XEvent ev ;
  int listenSocket ;
  int flashSocket ;
  int sock ;
  fd_set fds ;
  char flashUser[256] ;
  int n ;
  char *tmp ;
  int status ;
  int pid ;
  int tmp___0 ;
  int __d0 ;
  int __d1 ;
  ssize_t tmp___1 ;
  __pid_t tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 48
  d = XOpenDisplay((char const   *)displayname);
  }
#line 48
  if (! d) {
    {
#line 49
    tmp = XDisplayName((char const   *)displayname);
#line 49
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unable to open display %s\n",
            programName, tmp);
#line 51
    exit(1);
    }
  }
  {
#line 54
  getFlashFont(d);
#line 56
  listenSocket = ListenAtTcpPort(listenPort);
#line 57
  flashSocket = ListenAtTcpPort(flashPort);
  }
#line 59
  if (listenSocket < 0) {
    {
#line 59
    exit(1);
    }
  } else
#line 59
  if (flashSocket < 0) {
    {
#line 59
    exit(1);
    }
  }
  {
#line 61
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Listening on port %d (flash port %d)\n",
          programName, listenPort, flashPort);
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 68
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 68
      pid = wait3((union wait *)(& status), 1, (struct rusage *)0);
      }
#line 68
      if (! (pid > 0)) {
#line 68
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 71
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 71
      tmp___0 = XCheckIfEvent(d, & ev, & AllXEventsPredicate, (XPointer )((void *)0));
      }
#line 71
      if (! tmp___0) {
#line 71
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 74
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 74
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.__fds_bits[0]): "memory");
#line 74
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 76
    fds.__fds_bits[flashSocket / (8 * (int )sizeof(__fd_mask ))] |= 1L << flashSocket % (8 * (int )sizeof(__fd_mask ));
#line 77
    fds.__fds_bits[listenSocket / (8 * (int )sizeof(__fd_mask ))] |= 1L << listenSocket % (8 * (int )sizeof(__fd_mask ));
#line 78
    fds.__fds_bits[((_XPrivDisplay )d)->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ((_XPrivDisplay )d)->fd % (8 * (int )sizeof(__fd_mask ));
#line 80
    select(1024, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
           (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 82
    if ((fds.__fds_bits[flashSocket / (8 * (int )sizeof(__fd_mask ))] & (1L << flashSocket % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 84
      sock = AcceptTcpConnection(flashSocket);
      }
#line 85
      if (sock < 0) {
        {
#line 85
        exit(1);
        }
      }
      {
#line 86
      tmp___1 = read(sock, (void *)(flashUser), (size_t )255);
#line 86
      n = (int )tmp___1;
      }
#line 87
      if (n > 0) {
        {
#line 88
        flashUser[n] = (char)0;
#line 89
        flashDisplay(d, flashUser);
        }
      } else {
        {
#line 91
        flashDisplay(d, (char *)((void *)0));
        }
      }
      {
#line 93
      close(sock);
      }
    }
#line 96
    if ((fds.__fds_bits[listenSocket / (8 * (int )sizeof(__fd_mask ))] & (1L << listenSocket % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 97
      rfbsock = AcceptTcpConnection(listenSocket);
      }
#line 98
      if (rfbsock < 0) {
        {
#line 98
        exit(1);
        }
      }
      {
#line 100
      XCloseDisplay(d);
#line 104
      tmp___2 = fork();
      }
      {
#line 106
      if (tmp___2 == -1) {
#line 106
        goto case_neg_1;
      }
#line 110
      if (tmp___2 == 0) {
#line 110
        goto case_0;
      }
#line 116
      goto switch_default;
      case_neg_1: /* CIL Label */ 
      {
#line 107
      perror("fork");
#line 108
      exit(1);
      }
      case_0: /* CIL Label */ 
      {
#line 112
      close(listenSocket);
#line 113
      close(flashSocket);
      }
#line 114
      return;
      switch_default: /* CIL Label */ 
      {
#line 118
      close(rfbsock);
#line 119
      d = XOpenDisplay((char const   *)displayname);
      }
#line 119
      if (! d) {
        {
#line 120
        tmp___3 = XDisplayName((char const   *)displayname);
#line 120
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unable to open display \"%s\"\r\n",
                programName, tmp___3);
#line 122
        exit(1);
        }
      }
      {
#line 124
      getFlashFont(d);
      }
#line 125
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 136 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/listen.c"
static void getFlashFont(Display *d ) 
{ 
  char fontName[256] ;
  char **fontNames ;
  int nFontNames ;

  {
  {
#line 143
  sprintf((char */* __restrict  */)(fontName), (char const   */* __restrict  */)"-*-courier-bold-r-*-*-%d-*-*-*-*-*-iso8859-1",
          50);
#line 145
  fontNames = XListFonts(d, (char const   *)(fontName), 1, & nFontNames);
  }
#line 146
  if (nFontNames == 1) {
    {
#line 147
    XFreeFontNames(fontNames);
    }
  } else {
    {
#line 149
    sprintf((char */* __restrict  */)(fontName), (char const   */* __restrict  */)"fixed");
    }
  }
  {
#line 151
  flashFont = XLoadFont(d, (char const   *)(fontName));
  }
#line 152
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/listen.c"
static void flashDisplay(Display *d , char *user ) 
{ 
  Window w1 ;
  Window w2 ;
  Window w3 ;
  Window w4 ;
  XSetWindowAttributes attr ;
  GC gc ;
  XGCValues gcv ;
  size_t tmp ;

  {
  {
#line 165
  XBell(d, 100);
#line 167
  XForceScreenSaver(d, 0);
#line 169
  attr.background_pixel = (((_XPrivDisplay )d)->screens + ((_XPrivDisplay )d)->default_screen)->black_pixel;
#line 170
  attr.override_redirect = 1;
#line 171
  attr.save_under = 1;
#line 173
  w1 = XCreateWindow(d, (((_XPrivDisplay )d)->screens + ((_XPrivDisplay )d)->default_screen)->root,
                     0, 0, (unsigned int )(((_XPrivDisplay )d)->screens + ((_XPrivDisplay )d)->default_screen)->width,
                     50U, 0U, 0, 0U, (Visual *)0L, (unsigned long )(((1L << 1) | (1L << 9)) | (1L << 10)),
                     & attr);
#line 180
  w2 = XCreateWindow(d, (((_XPrivDisplay )d)->screens + ((_XPrivDisplay )d)->default_screen)->root,
                     0, 0, 50U, (unsigned int )(((_XPrivDisplay )d)->screens + ((_XPrivDisplay )d)->default_screen)->height,
                     0U, 0, 0U, (Visual *)0L, (unsigned long )(((1L << 1) | (1L << 9)) | (1L << 10)),
                     & attr);
#line 186
  w3 = XCreateWindow(d, (((_XPrivDisplay )d)->screens + ((_XPrivDisplay )d)->default_screen)->root,
                     (((_XPrivDisplay )d)->screens + ((_XPrivDisplay )d)->default_screen)->width - 50,
                     0, 50U, (unsigned int )(((_XPrivDisplay )d)->screens + ((_XPrivDisplay )d)->default_screen)->height,
                     0U, 0, 0U, (Visual *)0L, (unsigned long )(((1L << 1) | (1L << 9)) | (1L << 10)),
                     & attr);
#line 194
  w4 = XCreateWindow(d, (((_XPrivDisplay )d)->screens + ((_XPrivDisplay )d)->default_screen)->root,
                     0, (((_XPrivDisplay )d)->screens + ((_XPrivDisplay )d)->default_screen)->height - 50,
                     (unsigned int )(((_XPrivDisplay )d)->screens + ((_XPrivDisplay )d)->default_screen)->width,
                     50U, 0U, 0, 0U, (Visual *)0L, (unsigned long )(((1L << 1) | (1L << 9)) | (1L << 10)),
                     & attr);
#line 202
  XMapWindow(d, w1);
#line 203
  XMapWindow(d, w2);
#line 204
  XMapWindow(d, w3);
#line 205
  XMapWindow(d, w4);
  }
#line 207
  if (user) {
    {
#line 211
    gcv.foreground = (((_XPrivDisplay )d)->screens + ((_XPrivDisplay )d)->default_screen)->white_pixel;
#line 212
    gcv.font = flashFont;
#line 213
    gc = XCreateGC(d, w1, (unsigned long )((1L << 2) | (1L << 14)), & gcv);
#line 214
    tmp = strlen((char const   *)user);
#line 214
    XDrawString(d, w1, gc, (((_XPrivDisplay )d)->screens + ((_XPrivDisplay )d)->default_screen)->width / 2 - 50,
                37, (char const   *)user, (int )tmp);
    }
  }
  {
#line 218
  XFlush(d);
#line 220
  sleep(1U);
#line 222
  XDestroyWindow(d, w1);
#line 223
  XDestroyWindow(d, w2);
#line 224
  XDestroyWindow(d, w3);
#line 225
  XDestroyWindow(d, w4);
#line 226
  XFlush(d);
  }
#line 227
  return;
}
}
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 141
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpeername)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 73
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp ,
                                                                                struct in_addr *__inp ) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 578 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 717
extern int system(char const   *__command ) ;
#line 142 "./x2vnc.h"
int getFreePort(void) ;
#line 146
int SameMachine(int sock ) ;
#line 147 "./x2vnc.h"
int useSSHTunnel  ;
#line 148 "./x2vnc.h"
char *useSSHGateway  ;
#line 33 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/sockets.c"
void PrintInHex(char *buf , int len ) ;
#line 35 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/sockets.c"
int errorMessageFromReadExact  =    1;
#line 43 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/sockets.c"
int ReadExact(int sock , char *buf , int n ) 
{ 
  int i ;
  int j ;
  ssize_t tmp ;

  {
#line 46
  i = 0;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! (i < n)) {
#line 49
      goto while_break;
    }
    {
#line 50
    tmp = read(sock, (void *)(buf + i), (size_t )(n - i));
#line 50
    j = (int )tmp;
    }
#line 51
    if (j <= 0) {
#line 52
      if (j < 0) {
        {
#line 53
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
                programName);
#line 54
        perror(": read");
        }
      } else
#line 56
      if (errorMessageFromReadExact) {
        {
#line 57
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: read failed\n",
                programName);
        }
      }
#line 60
      return (0);
    }
#line 62
    i += j;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  if (debug) {
    {
#line 65
    PrintInHex(buf, n);
    }
  }
#line 66
  return (1);
}
}
#line 74 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/sockets.c"
int WriteExact(int sock , char *buf , int n ) 
{ 
  int i ;
  int j ;
  ssize_t tmp ;

  {
#line 77
  i = 0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! (i < n)) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = write(sock, (void const   *)(buf + i), (size_t )(n - i));
#line 81
    j = (int )tmp;
    }
#line 82
    if (j <= 0) {
#line 83
      if (j < 0) {
        {
#line 84
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
                programName);
#line 85
        perror(": write");
        }
      } else {
        {
#line 87
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: write failed\n",
                programName);
        }
      }
#line 89
      return (0);
    }
#line 91
    i += j;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return (1);
}
}
#line 123
int tunnel(char *gatewayhost , char *remotehost , int remoteport ) ;
#line 101 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/sockets.c"
int ConnectToTcpAddr(unsigned int host , int port___0 ) 
{ 
  int sock ;
  struct sockaddr_in addr ;
  int one ;
  char *remote ;
  char *gateway ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 106
  one = 1;
#line 108
  addr.sin_family = (sa_family_t )2;
#line 109
  addr.sin_port = htons((uint16_t )port___0);
#line 110
  addr.sin_addr.s_addr = host;
  }
#line 112
  if (useSSHTunnel) {
#line 115
    if (useSSHGateway) {
      {
#line 117
      gateway = useSSHGateway;
#line 118
      remote = inet_ntoa(addr.sin_addr);
      }
    } else {
      {
#line 120
      gateway = inet_ntoa(addr.sin_addr);
#line 121
      remote = (char *)"127.0.0.1";
      }
    }
    {
#line 123
    tmp = tunnel(gateway, remote, port___0);
#line 123
    addr.sin_port = htons((uint16_t )tmp);
#line 124
    inet_aton("127.0.0.1", & addr.sin_addr);
    }
  }
  {
#line 127
  sock = socket(2, 1, 0);
  }
#line 128
  if (sock < 0) {
    {
#line 129
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            programName);
#line 130
    perror(": ConnectToTcpAddr: socket");
    }
#line 131
    return (-1);
  }
  {
#line 134
  tmp___0 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                    (socklen_t )sizeof(addr));
  }
#line 134
  if (tmp___0 < 0) {
    {
#line 135
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            programName);
#line 136
    perror(": ConnectToTcpAddr: connect");
#line 137
    close(sock);
    }
#line 138
    return (-1);
  }
  {
#line 141
  tmp___1 = setsockopt(sock, 6, 1, (void const   *)((char *)(& one)), (socklen_t )sizeof(one));
  }
#line 141
  if (tmp___1 < 0) {
    {
#line 142
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            programName);
#line 143
    perror(": ConnectToTcpAddr: setsockopt");
#line 144
    close(sock);
    }
#line 145
    return (-1);
  }
#line 148
  return (sock);
}
}
#line 157 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/sockets.c"
int ListenAtTcpPort(int port___0 ) 
{ 
  int sock ;
  struct sockaddr_in addr ;
  int one ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 162
  one = 1;
#line 164
  addr.sin_family = (sa_family_t )2;
#line 165
  addr.sin_port = htons((uint16_t )port___0);
#line 166
  addr.sin_addr.s_addr = (in_addr_t )0;
#line 168
  sock = socket(2, 1, 0);
  }
#line 169
  if (sock < 0) {
    {
#line 170
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            programName);
#line 171
    perror(": ListenAtTcpPort: socket");
    }
#line 172
    return (-1);
  }
  {
#line 175
  tmp = setsockopt(sock, 1, 2, (void const   *)((char const   *)(& one)), (socklen_t )sizeof(one));
  }
#line 175
  if (tmp < 0) {
    {
#line 177
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            programName);
#line 178
    perror(": ListenAtTcpPort: setsockopt");
#line 179
    close(sock);
    }
#line 180
    return (-1);
  }
  {
#line 183
  tmp___0 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)), (socklen_t )sizeof(addr));
  }
#line 183
  if (tmp___0 < 0) {
    {
#line 184
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            programName);
#line 185
    perror(": ListenAtTcpPort: bind");
#line 186
    close(sock);
    }
#line 187
    return (-1);
  }
  {
#line 190
  tmp___1 = listen(sock, 5);
  }
#line 190
  if (tmp___1 < 0) {
    {
#line 191
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            programName);
#line 192
    perror(": ListenAtTcpPort: listen");
#line 193
    close(sock);
    }
#line 194
    return (-1);
  }
#line 197
  return (sock);
}
}
#line 206 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/sockets.c"
static int last  ;
#line 200 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/sockets.c"
int getFreePort(void) 
{ 
  int sock ;
  struct sockaddr_in addr ;
  int one ;
  int x ;
  int port___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 202
  sock = -1;
#line 204
  one = 1;
#line 208
  x = 0;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! (x < 100)) {
#line 208
      goto while_break;
    }
    {
#line 210
    port___0 = 5500 + last % 100;
#line 211
    last += 4711;
#line 213
    addr.sin_family = (sa_family_t )2;
#line 214
    addr.sin_port = htons((uint16_t )port___0);
#line 215
    addr.sin_addr.s_addr = (in_addr_t )0;
#line 217
    sock = socket(2, 1, 0);
    }
#line 218
    if (sock < 0) {
      {
#line 223
      close(sock);
      }
    } else {
      {
#line 218
      tmp = setsockopt(sock, 1, 2, (void const   *)((char const   *)(& one)), (socklen_t )sizeof(one));
      }
#line 218
      if (tmp < 0) {
        {
#line 223
        close(sock);
        }
      } else {
        {
#line 218
        tmp___0 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                       (socklen_t )sizeof(addr));
        }
#line 218
        if (tmp___0 < 0) {
          {
#line 223
          close(sock);
          }
        } else {
          {
#line 225
          close(sock);
          }
#line 226
          return (port___0);
        }
      }
    }
#line 208
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  return (-1);
}
}
#line 237 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/sockets.c"
int AcceptTcpConnection(int listenSock ) 
{ 
  int sock ;
  struct sockaddr_in addr ;
  int addrlen ;
  int one ;
  int tmp ;

  {
  {
#line 242
  addrlen = (int )sizeof(addr);
#line 243
  one = 1;
#line 245
  sock = accept(listenSock, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& addr)),
                (socklen_t */* __restrict  */)(& addrlen));
  }
#line 246
  if (sock < 0) {
    {
#line 247
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            programName);
#line 248
    perror(": AcceptTcpConnection: accept");
    }
#line 249
    return (-1);
  }
  {
#line 252
  tmp = setsockopt(sock, 6, 1, (void const   *)((char *)(& one)), (socklen_t )sizeof(one));
  }
#line 252
  if (tmp < 0) {
    {
#line 254
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            programName);
#line 255
    perror(": AcceptTcpConnection: setsockopt");
#line 256
    close(sock);
    }
#line 257
    return (-1);
  }
#line 260
  return (sock);
}
}
#line 268 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/sockets.c"
int StringToIPAddr(char const   *str , unsigned int *addr ) 
{ 
  struct hostent *hp ;
  unsigned int tmp ;

  {
  {
#line 273
  tmp = inet_addr(str);
#line 273
  *addr = tmp;
  }
#line 273
  if (tmp == 4294967295U) {
    {
#line 275
    hp = gethostbyname(str);
    }
#line 275
    if (! hp) {
#line 276
      return (0);
    }
#line 278
    *addr = *((unsigned int *)*(hp->h_addr_list + 0));
  }
#line 281
  return (1);
}
}
#line 289 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/sockets.c"
int SameMachine(int sock ) 
{ 
  struct sockaddr_in peeraddr ;
  struct sockaddr_in myaddr ;
  int addrlen ;

  {
  {
#line 293
  addrlen = (int )sizeof(struct sockaddr_in );
#line 295
  getpeername(sock, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& peeraddr)),
              (socklen_t */* __restrict  */)(& addrlen));
#line 296
  getsockname(sock, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& myaddr)),
              (socklen_t */* __restrict  */)(& addrlen));
  }
#line 298
  return (peeraddr.sin_addr.s_addr == myaddr.sin_addr.s_addr);
}
}
#line 306 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/sockets.c"
void PrintInHex(char *buf , int len ) 
{ 
  int i ;
  int j ;
  char c ;
  char str[17] ;

  {
  {
#line 312
  str[16] = (char)0;
#line 314
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ReadExact: ");
#line 316
  i = 0;
  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! (i < len)) {
#line 316
      goto while_break;
    }
#line 318
    if (i % 16 == 0) {
#line 318
      if (i != 0) {
        {
#line 319
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"           ");
        }
      }
    }
#line 321
    c = *(buf + i);
#line 322
    if ((int )c > 31) {
#line 322
      if ((int )c < 127) {
#line 322
        str[i % 16] = c;
      } else {
#line 322
        str[i % 16] = (char )'.';
      }
    } else {
#line 322
      str[i % 16] = (char )'.';
    }
    {
#line 323
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x ",
            (int )((unsigned char )c));
    }
#line 324
    if (i % 4 == 3) {
      {
#line 325
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
      }
    }
#line 326
    if (i % 16 == 15) {
      {
#line 328
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              str);
      }
    }
#line 316
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 331
  if (i % 16 != 0) {
#line 333
    j = i % 16;
    {
#line 333
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 333
      if (! (j < 16)) {
#line 333
        goto while_break___0;
      }
      {
#line 335
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   ");
      }
#line 336
      if (j % 4 == 3) {
        {
#line 336
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
        }
      }
#line 333
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 338
    str[i % 16] = (char)0;
#line 339
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            str);
    }
  }
  {
#line 342
  fflush(stderr);
  }
#line 343
  return;
}
}
#line 346 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/sockets.c"
int tunnel(char *gatewayhost , char *remotehost , int remoteport ) 
{ 
  char *space ;
  char *cmd ;
  int port___0 ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;

  {
  {
#line 349
  tmp = getFreePort();
#line 349
  port___0 = tmp;
  }
#line 351
  if (gatewayhost) {
    {
#line 351
    tmp___0 = strlen((char const   *)gatewayhost);
#line 351
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 351
    tmp___1 = strlen((char const   *)remotehost);
#line 351
    tmp___2 = tmp___1;
    }
  }
  {
#line 351
  tmp___3 = strlen((char const   *)remotehost);
#line 351
  tmp___4 = malloc((tmp___2 + tmp___3) + 1024UL);
#line 351
  space = (char *)tmp___4;
  }
#line 352
  if (! space) {
    {
#line 354
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to malloc environment buffer!\n");
#line 355
    exit(1);
    }
  }
  {
#line 358
  sprintf((char */* __restrict  */)space, (char const   */* __restrict  */)"LOCALPORT=%d",
          port___0);
#line 359
  putenv(space);
#line 360
  tmp___5 = strlen((char const   *)space);
#line 360
  space += tmp___5 + 1UL;
#line 362
  sprintf((char */* __restrict  */)space, (char const   */* __restrict  */)"REMOTEHOST=%s",
          remotehost);
#line 363
  putenv(space);
#line 364
  tmp___6 = strlen((char const   *)space);
#line 364
  space += tmp___6 + 1UL;
  }
#line 366
  if (gatewayhost) {
#line 366
    tmp___7 = gatewayhost;
  } else {
#line 366
    tmp___7 = remotehost;
  }
  {
#line 366
  sprintf((char */* __restrict  */)space, (char const   */* __restrict  */)"GATEWAYHOST=%s",
          tmp___7);
#line 367
  putenv(space);
#line 368
  tmp___8 = strlen((char const   *)space);
#line 368
  space += tmp___8 + 1UL;
#line 370
  sprintf((char */* __restrict  */)space, (char const   */* __restrict  */)"REMOTEPORT=%d",
          remoteport);
#line 371
  putenv(space);
#line 372
  tmp___9 = strlen((char const   *)space);
#line 372
  space += tmp___9 + 1UL;
#line 374
  cmd = getenv("X2VNC_SSH_CMD");
  }
#line 376
  if (! cmd) {
#line 376
    cmd = (char *)"ssh -A -X -f -L \"$LOCALPORT:$REMOTEHOST:$REMOTEPORT\" \"$GATEWAYHOST\" \'ssh-add;sleep 60\'";
  }
  {
#line 378
  tmp___10 = system((char const   *)cmd);
  }
#line 378
  if (tmp___10 < 0) {
    {
#line 380
    perror("tunnel:system");
#line 381
    exit(1);
    }
  }
#line 383
  return (port___0);
}
}
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 538 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 1503 "/usr/include/X11/Xlib.h"
extern char *XFetchBytes(Display * , int * ) ;
#line 1512
extern char *XGetAtomName(Display * , Atom  ) ;
#line 1548
extern Atom XInternAtom(Display * , char const   * , int  ) ;
#line 1570
extern Cursor XCreatePixmapCursor(Display * , Pixmap  , Pixmap  , XColor * , XColor * ,
                                  unsigned int  , unsigned int  ) ;
#line 1609
extern Pixmap XCreatePixmap(Display * , Drawable  , unsigned int  , unsigned int  ,
                            unsigned int  ) ;
#line 1644
extern Window XGetSelectionOwner(Display * , Atom  ) ;
#line 1698
extern KeySym __attribute__((__deprecated__))  XKeycodeToKeysym(Display * , KeyCode  ,
                                                                int  ) ;
#line 1722
extern KeySym XStringToKeysym(char const   * ) ;
#line 1860
extern XErrorHandler XSetErrorHandler(int (*)(Display * , XErrorEvent * ) ) ;
#line 1900
extern int XSetWMProtocols(Display * , Window  , Atom * , int  ) ;
#line 2080
extern int XChangeProperty(Display * , Window  , Atom  , Atom  , int  , int  , unsigned char const   * ,
                           int  ) ;
#line 2127
extern int XCheckTypedWindowEvent(Display * , Window  , int  , XEvent * ) ;
#line 2187
extern int XConvertSelection(Display * , Atom  , Atom  , Atom  , Window  , Time  ) ;
#line 2528
extern int XFree(void * ) ;
#line 2688
extern int XGetWindowProperty(Display * , Window  , Atom  , long  , long  , int  ,
                              Atom  , Atom * , int * , unsigned long * , unsigned long * ,
                              unsigned char ** ) ;
#line 2703
extern int XGetWindowAttributes(Display * , Window  , XWindowAttributes * ) ;
#line 2722
extern int XGrabKey(Display * , int  , unsigned int  , Window  , int  , int  , int  ) ;
#line 2732
extern int XGrabKeyboard(Display * , Window  , int  , int  , int  , Time  ) ;
#line 2741
extern int XGrabPointer(Display * , Window  , int  , unsigned int  , int  , int  ,
                        Window  , Cursor  , Time  ) ;
#line 2785
extern KeyCode XKeysymToKeycode(Display * , KeySym  ) ;
#line 2808
extern int XMapRaised(Display * , Window  ) ;
#line 2995
extern int XQueryPointer(Display * , Window  , Window * , Window * , int * , int * ,
                         int * , int * , unsigned int * ) ;
#line 3079
extern int XRefreshKeyboardMapping(XMappingEvent * ) ;
#line 3141
extern int XSelectInput(Display * , Window  , long  ) ;
#line 3147
extern int XSendEvent(Display * , Window  , int  , long  , XEvent * ) ;
#line 3304
extern int XSetSelectionOwner(Display * , Atom  , Window  , Time  ) ;
#line 3388
extern int XStoreBytes(Display * , char const   * , int  ) ;
#line 3407
extern int XStoreName(Display * , Window  , char const   * ) ;
#line 3421
extern int XSync(Display * , int  ) ;
#line 3488
extern int XUngrabKeyboard(Display * , Time  ) ;
#line 3493
extern int XUngrabPointer(Display * , Time  ) ;
#line 3517
extern int XUnmapWindow(Display * , Window  ) ;
#line 3526
extern int XWarpPointer(Display * , Window  , Window  , int  , int  , unsigned int  ,
                        unsigned int  , int  , int  ) ;
#line 127 "./x2vnc.h"
Display *dpy  ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 534 "/usr/include/X11/Xutil.h"
extern int XLookupString(XKeyEvent * , char * , int  , KeySym * , XComposeStatus * ) ;
#line 659
extern void XSetWMNormalHints(Display * , Window  , XSizeHints * ) ;
#line 812
extern int XWMGeometry(Display * , int  , char const   * , char const   * , unsigned int  ,
                       XSizeHints * , int * , int * , int * , int * , int * ) ;
#line 41 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
struct coord mkcoord(int x , int y ) 
{ 
  struct coord ret ;

  {
#line 44
  ret.x = x;
#line 45
  ret.y = y;
#line 46
  return (ret);
}
}
#line 49 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
void dumpcoord(struct coord *c ) 
{ 


  {
  {
#line 51
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"{ %d, %d }",
          c->x, c->y);
  }
#line 52
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static Window topLevel  ;
#line 85 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static int topLevelWidth  ;
#line 85 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static int topLevelHeight  ;
#line 87 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static Atom wmProtocols  ;
#line 87 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static Atom wmDeleteWindow  ;
#line 88 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static int modifierPressed[256]  ;
#line 90
static int HandleTopLevelEvent(XEvent *ev ) ;
#line 91
static int HandleRootEvent(XEvent *ev ) ;
#line 92 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static int displayWidth  ;
#line 92 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static int displayHeight  ;
#line 93 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static int x_offset  =    0;
#line 93 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static int y_offset  =    0;
#line 94 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static int grabbed  ;
#line 95 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static int pointer_warp_threshold  =    5;
#line 96 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
Cursor grabCursor  =    (Cursor )0;
#line 98 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
float remote_xpos  =    (float )0.0;
#line 99 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
float remote_ypos  =    (float )0.0;
#line 100 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
float pointer_speed  =    (float )0.0;
#line 102 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
struct coord origo1  ;
#line 102 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
struct coord origo2  ;
#line 103 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
struct coord current_location  ;
#line 104 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
struct coord current_speed  ;
#line 105 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
struct coord *next_origo  ;
#line 106 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
struct coord *current_origo  ;
#line 107 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int origo_separation  ;
#line 108 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int motion_events  ;
#line 116 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
enum edge_enum edge  =    (enum edge_enum )0;
#line 117 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int edge_width  =    1;
#line 118 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int restingx  =    -1;
#line 119 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int restingy  =    -1;
#line 120 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int emulate_wheel  =    0;
#line 121 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int emulate_nav  =    0;
#line 122 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int wheel_button_up  =    4;
#line 123 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int scroll_lines  =    1;
#line 124 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int mac_mode  =    0;
#line 125 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int hidden  =    0;
#line 128 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int last_event_time  =    0;
#line 130 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
KeySym grabkeysym  =    (KeySym )65481;
#line 131 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
KeyCode grabkey  ;
#line 132 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int grabmod  =    1 << 2;
#line 134 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
char *client_selection_text  =    (char *)0;
#line 135 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
size_t client_selection_text_length  =    (size_t )0;
#line 137 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int saved_xpos  =    -1;
#line 138 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int saved_ypos  =    -1;
#line 140 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int saved_remote_xpos  =    -1;
#line 141 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int saved_remote_ypos  =    -1;
#line 143 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
long grab_timeout  =    0L;
#line 144 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
long grab_timeout_delay  =    590L;
#line 149 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
Atom current_desktop_atom  ;
#line 150 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
Atom number_of_desktops_atom  ;
#line 152 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int requested_desktop  =    -2;
#line 153 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int current_desktop  =    -2;
#line 154 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int current_number_of_desktops  =    -2;
#line 156 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int remote_is_locked  =    0;
#line 158
static void ungrabit(int x , int y , Window warpWindow ) ;
#line 162 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int warn_about_hotkey(Display *dpy___0 , XErrorEvent *ev ) 
{ 


  {
  {
#line 164
  grabkeysym = (KeySym )0;
#line 165
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Failed to bind x2vnc hotkey, hotkey disabled.\n");
  }
#line 166
  return (0);
}
}
#line 174 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static int mouseOnScreen  ;
#line 180 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int CreateXWindow(void) 
{ 
  XSetWindowAttributes attr ;
  char defaultGeometry[256] ;
  XSizeHints wmHints ;
  int i ;
  int ew ;
  Pixmap nullPixmap ;
  XColor dummyColor ;
  char *tmp ;
  long tmp___0 ;
  Atom t ;
  Atom tmp___1 ;
  Atom tmp___2 ;
  Window root ;
  Window child ;
  int root_x ;
  int root_y ;
  int win_x ;
  int win_y ;
  unsigned int keys_buttons ;
  int (*prev_err_handler)(Display * , XErrorEvent * ) ;
  XErrorHandler tmp___3 ;
  double tmp___4 ;
  int N ;
  double tmp___5 ;

  {
  {
#line 193
  dpy = XOpenDisplay((char const   *)displayname);
  }
#line 193
  if (! dpy) {
    {
#line 194
    tmp = XDisplayName((char const   *)displayname);
#line 194
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unable to open display %s\n",
            programName, tmp);
    }
#line 196
    return (0);
  }
#line 218
  if (noblank) {
    {
#line 226
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-noblank option used, but no approperiate extensions found:\n x2vnc will keep the remote screen active at all times.\n");
    }
  }
#line 229
  i = 0;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! (i < 256)) {
#line 229
      goto while_break;
    }
#line 230
    modifierPressed[i] = 0;
#line 229
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  displayWidth = (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->width;
#line 235
  displayHeight = (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->height;
#line 237
  saved_remote_xpos = displayWidth / 2;
#line 238
  saved_remote_ypos = displayHeight / 2;
#line 240
  if (restingy == -1) {
#line 242
    restingy = ((int )si.framebufferHeight - 2) - mac_mode;
#line 243
    restingx = ((int )si.framebufferWidth - 2) + mac_mode;
  }
#line 313
  ew = edge_width;
#line 314
  if (! ew) {
#line 314
    ew = 1;
  }
#line 315
  topLevelWidth = ew;
#line 316
  topLevelHeight = ew;
#line 317
  wmHints.x = x_offset;
#line 318
  wmHints.y = y_offset;
  {
#line 322
  if ((unsigned int )edge == 0U) {
#line 322
    goto case_0;
  }
#line 323
  if ((unsigned int )edge == 1U) {
#line 323
    goto case_1;
  }
#line 326
  if ((unsigned int )edge == 3U) {
#line 326
    goto case_3;
  }
#line 327
  if ((unsigned int )edge == 2U) {
#line 327
    goto case_2;
  }
#line 320
  goto switch_break;
  case_0: /* CIL Label */ 
#line 322
  wmHints.x = (displayWidth - ew) + x_offset;
  case_1: /* CIL Label */ 
#line 323
  topLevelHeight = displayHeight;
#line 324
  goto switch_break;
  case_3: /* CIL Label */ 
#line 326
  wmHints.y = (displayHeight - ew) + y_offset;
  case_2: /* CIL Label */ 
#line 327
  topLevelWidth = displayWidth;
#line 328
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 331
  wmHints.flags = (((1L << 5) | (1L << 4)) | (1L << 2)) | (1L << 8);
#line 333
  wmHints.min_width = topLevelWidth;
#line 334
  wmHints.min_height = topLevelHeight;
#line 336
  wmHints.max_width = topLevelWidth;
#line 337
  wmHints.max_height = topLevelHeight;
#line 339
  wmHints.base_width = topLevelWidth;
#line 340
  wmHints.base_height = topLevelHeight;
#line 342
  sprintf((char */* __restrict  */)(defaultGeometry), (char const   */* __restrict  */)"%dx%d+%d+%d",
          topLevelWidth, topLevelHeight, wmHints.x, wmHints.y);
#line 346
  XWMGeometry(dpy, ((_XPrivDisplay )dpy)->default_screen, (char const   *)geometry,
              (char const   *)(defaultGeometry), 0U, & wmHints, & wmHints.x, & wmHints.y,
              & topLevelWidth, & topLevelHeight, & wmHints.win_gravity);
#line 352
  attr.border_pixel = 0UL;
#line 354
  attr.background_pixel = (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->black_pixel;
  }
#line 355
  if (resurface) {
#line 355
    tmp___0 = 1L << 16;
  } else {
#line 355
    tmp___0 = 0L;
  }
  {
#line 355
  attr.event_mask = ((((((((1L << 5) | (1L << 17)) | (1L << 2)) | (1L << 3)) | (1L << 6)) | 1L) | (1L << 1)) | (1L << 4)) | tmp___0;
#line 365
  attr.override_redirect = 1;
#line 367
  topLevel = XCreateWindow(dpy, (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root,
                           wmHints.x, wmHints.y, (unsigned int )topLevelWidth, (unsigned int )topLevelHeight,
                           0U, 0, 1U, (Visual *)0L, (unsigned long )((((1L << 3) | (1L << 11)) | (1L << 9)) | (1L << 1)),
                           & attr);
#line 376
  current_desktop_atom = XInternAtom(dpy, "_NET_CURRENT_DESKTOP", 0);
#line 377
  number_of_desktops_atom = XInternAtom(dpy, "_NET_NUMBER_OF_DESKTOPS", 0);
#line 381
  tmp___1 = XInternAtom(dpy, "_NET_WM_WINDOW_DOCK", 0);
#line 381
  t = tmp___1;
#line 383
  tmp___2 = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", 0);
#line 383
  XChangeProperty(dpy, topLevel, tmp___2, (Atom )4, 32, 0, (unsigned char const   *)((unsigned char *)(& t)),
                  1);
#line 395
  wmHints.flags |= 1L;
#line 396
  XSetWMNormalHints(dpy, topLevel, & wmHints);
#line 398
  wmProtocols = XInternAtom(dpy, "WM_PROTOCOLS", 0);
#line 399
  wmDeleteWindow = XInternAtom(dpy, "WM_DELETE_WINDOW", 0);
#line 400
  XSetWMProtocols(dpy, topLevel, & wmDeleteWindow, 1);
#line 402
  XStoreName(dpy, topLevel, (char const   *)desktopName);
  }
#line 404
  if (edge_width) {
    {
#line 405
    XMapRaised(dpy, topLevel);
    }
  } else {
#line 407
    hidden = 1;
  }
#line 414
  if (((_XPrivDisplay )dpy)->nscreens > 1) {
    {
#line 420
    XSelectInput(dpy, (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root,
                 (((1L << 22) | (1L << 4)) | (1L << 5)) | 1L);
    }
#line 426
    if ((((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root != (((_XPrivDisplay )dpy)->screens + 0)->root) {
      {
#line 427
      XSelectInput(dpy, (((_XPrivDisplay )dpy)->screens + 0)->root, 1L << 22);
      }
    }
    {
#line 429
    XQueryPointer(dpy, (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root,
                  & root, & child, & root_x, & root_y, & win_x, & win_y, & keys_buttons);
#line 431
    mouseOnScreen = root == (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root;
    }
  } else {
    {
#line 433
    XSelectInput(dpy, (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root,
                 1L << 22);
#line 434
    mouseOnScreen = 1;
    }
  }
  {
#line 450
  nullPixmap = XCreatePixmap(dpy, (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root,
                             1U, 1U, 1U);
  }
#line 451
  if (! debug) {
    {
#line 452
    grabCursor = XCreatePixmapCursor(dpy, nullPixmap, nullPixmap, & dummyColor, & dummyColor,
                                     0U, 0U);
    }
  }
#line 456
  if (grabkeysym) {
    {
#line 458
    tmp___3 = XSetErrorHandler(& warn_about_hotkey);
#line 458
    prev_err_handler = tmp___3;
#line 459
    grabkey = XKeysymToKeycode(dpy, grabkeysym);
#line 463
    XGrabKey(dpy, (int )grabkey, (unsigned int )grabmod, (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root,
             1, 0, 0);
#line 467
    XSync(dpy, 0);
    }
#line 469
    if (grabkeysym) {
      {
#line 472
      XGrabKey(dpy, (int )grabkey, (unsigned int )(grabmod | (1 << 4)), (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root,
               1, 0, 0);
      }
    }
    {
#line 476
    XSync(dpy, 0);
#line 478
    XSetErrorHandler(prev_err_handler);
    }
  }
  {
#line 483
  SendPointerEvent(restingx, restingy, 0);
#line 485
  tmp___4 = pow((double )((float )((int )si.framebufferWidth * (int )si.framebufferHeight) / (float )(displayWidth * displayHeight)),
                0.25);
#line 485
  pointer_speed = (float )((double )acceleration * tmp___4);
#line 504
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: pointer multiplier: %f\n",
          programName, (double )pointer_speed);
  }
#line 508
  if (displayWidth * 2 > displayHeight) {
    {
#line 510
    origo1 = mkcoord(displayWidth / 3, displayHeight / 2);
#line 511
    origo2 = mkcoord((displayWidth * 2) / 3, displayHeight / 2);
#line 512
    origo_separation = displayWidth / 3;
    }
  } else
#line 514
  if (displayHeight * 2 > displayWidth) {
    {
#line 516
    origo1 = mkcoord(displayWidth / 2, displayHeight / 3);
#line 517
    origo2 = mkcoord(displayWidth / 2, (displayHeight * 2) / 3);
#line 518
    origo_separation = displayHeight / 3;
    }
  } else {
    {
#line 522
    tmp___5 = sqrt((double )(((-3 * displayWidth) * displayWidth - (3 * displayHeight) * displayHeight) + (8 * displayWidth) * displayHeight));
#line 522
    N = (int )(((double )(2 * (displayWidth + displayHeight)) - tmp___5) / 7.0);
#line 523
    origo1 = mkcoord(N, N);
#line 524
    origo2 = mkcoord(displayWidth - N, displayHeight - N);
#line 525
    origo_separation = N;
    }
  }
#line 527
  origo1.x += x_offset;
#line 528
  origo1.y += y_offset;
#line 529
  origo2.x += x_offset;
#line 530
  origo2.y += y_offset;
#line 538
  return (1);
}
}
#line 550 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
Time check_idle(void) 
{ 


  {
#line 573
  return ((Time )0);
}
}
#line 576 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
void WiggleMouse(void) 
{ 
  int tmpy ;
  int tmp ;

  {
#line 578
  if (restingy > (int )si.framebufferHeight / 2) {
#line 578
    tmp = restingy - 1;
  } else {
#line 578
    tmp = restingy + 1;
  }
  {
#line 578
  tmpy = tmp;
#line 579
  SendPointerEvent(restingx, tmpy, 0);
#line 580
  SendPointerEvent(restingx, restingy, 0);
  }
#line 581
  return;
}
}
#line 583 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
void doWarp(void) 
{ 


  {
#line 585
  if (grabbed) {
#line 587
    if (next_origo) {
#line 587
      return;
    }
#line 588
    if (current_origo) {
#line 588
      if (current_location.x == current_origo->x) {
#line 588
        if (current_location.y == current_origo->y) {
#line 591
          return;
        }
      }
    }
#line 593
    if ((unsigned long )current_origo == (unsigned long )(& origo1)) {
#line 594
      next_origo = & origo2;
    } else {
#line 596
      next_origo = & origo1;
    }
    {
#line 599
    XWarpPointer(dpy, (Window )0L, (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root,
                 0, 0, 0U, 0U, next_origo->x, next_origo->y);
#line 603
    motion_events = 0;
    }
  }
#line 605
  return;
}
}
#line 613 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int HandleXEvents(void) 
{ 
  XEvent ev ;
  int tmp ;
  int remote_idle ;
  int tmp___0 ;
  Time tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 617
  if (grabbed) {
#line 619
    if (grab_timeout_delay) {
      {
#line 619
      tmp = time(0);
      }
#line 619
      if ((long )tmp > grab_timeout) {
        {
#line 620
        ungrabit(-1, -1, (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root);
        }
      }
    }
  } else {
    {
#line 622
    tmp___0 = time(0);
#line 622
    remote_idle = tmp___0 - last_event_time;
    }
#line 623
    if (remote_idle > no_wakeup_delay) {
#line 624
      remote_is_locked = 1;
    }
#line 628
    if (noblank) {
#line 628
      if (remote_idle >= 45) {
#line 628
        if (! remote_is_locked) {
          {
#line 628
          tmp___1 = check_idle();
          }
#line 628
          if (tmp___1 < 30000UL) {
            {
#line 633
            WiggleMouse();
            }
          }
        }
      }
    }
  }
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 639
    tmp___4 = XCheckIfEvent(dpy, & ev, & AllXEventsPredicate, (XPointer )((void *)0));
    }
#line 639
    if (! tmp___4) {
#line 639
      goto while_break;
    }
#line 641
    if (ev.xany.window == topLevel) {
      {
#line 643
      tmp___2 = HandleTopLevelEvent(& ev);
      }
#line 643
      if (! tmp___2) {
#line 644
        return (0);
      }
    } else
#line 646
    if (ev.xany.window == (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root) {
#line 646
      goto _L;
    } else
#line 646
    if (ev.xany.window == (((_XPrivDisplay )dpy)->screens + 0)->root) {
      _L: /* CIL Label */ 
      {
#line 648
      tmp___3 = HandleRootEvent(& ev);
      }
#line 648
      if (! tmp___3) {
#line 649
        return (0);
      }
    } else
#line 651
    if (ev.type == 34) {
      {
#line 653
      XRefreshKeyboardMapping(& ev.xmapping);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 657
  doWarp();
  }
#line 659
  return (1);
}
}
#line 667 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static int enter_translate(int isedge , int width , int pos ) 
{ 


  {
#line 669
  if (! isedge) {
#line 669
    return (pos);
  }
#line 670
  if ((unsigned int )edge == 0U) {
#line 670
    return (0);
  } else
#line 670
  if ((unsigned int )edge == 3U) {
#line 670
    return (0);
  }
#line 671
  return (width - 1);
}
}
#line 691 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static int sendpointerevent(int x , int y , int buttonmask ) 
{ 
  int tmp ;

  {
#line 693
  if (mac_mode) {
#line 693
    if (buttonmask & (1 << 2)) {
#line 695
      buttonmask &= ~ (1 << 2);
#line 696
      buttonmask |= -2;
    }
  }
  {
#line 699
  tmp = SendPointerEvent(x, y, buttonmask);
  }
#line 699
  return (tmp);
}
}
#line 703 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
void mapwindow(void) 
{ 


  {
#line 705
  if (edge_width) {
    {
#line 707
    hidden = 0;
#line 708
    XMapRaised(dpy, topLevel);
    }
  }
#line 710
  return;
}
}
#line 712 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
void hidewindow(void) 
{ 


  {
  {
#line 714
  hidden = 1;
#line 715
  XUnmapWindow(dpy, topLevel);
  }
#line 716
  return;
}
}
#line 718 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static void grabit(int x , int y , int state ) 
{ 
  Window selection_owner ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 722
  if (hidden) {
    {
#line 724
    XMapRaised(dpy, topLevel);
#line 725
    hidden = 0;
    }
  }
  {
#line 728
  XGrabPointer(dpy, topLevel, 1, (unsigned int )(((1L << 6) | (1L << 2)) | (1L << 3)),
               1, 1, (Window )0L, grabCursor, (Time )0L);
#line 732
  XGrabKeyboard(dpy, topLevel, 1, 1, 1, (Time )0L);
#line 741
  grabbed = 1;
#line 742
  next_origo = (struct coord *)((void *)0);
#line 743
  current_origo = (struct coord *)((void *)0);
  }
#line 745
  if (x > -1) {
#line 745
    if (y > -1) {
      {
#line 747
      doWarp();
      }
#line 750
      if ((unsigned int )edge == 1U) {
#line 750
        tmp = edge_width;
      } else {
#line 750
        tmp = 0;
      }
#line 750
      if ((unsigned int )edge == 0U) {
#line 750
        tmp___0 = edge_width;
      } else
#line 750
      if ((unsigned int )edge == 1U) {
#line 750
        tmp___0 = edge_width;
      } else {
#line 750
        tmp___0 = 0;
      }
#line 750
      remote_xpos = (float )(((x - tmp) * ((int )si.framebufferWidth - 1)) / ((displayWidth - 1) - tmp___0));
#line 751
      if ((unsigned int )edge == 2U) {
#line 751
        tmp___1 = edge_width;
      } else {
#line 751
        tmp___1 = 0;
      }
#line 751
      if ((unsigned int )edge == 2U) {
#line 751
        tmp___2 = edge_width;
      } else
#line 751
      if ((unsigned int )edge == 3U) {
#line 751
        tmp___2 = edge_width;
      } else {
#line 751
        tmp___2 = 0;
      }
      {
#line 751
      remote_ypos = (float )(((y - tmp___1) * ((int )si.framebufferHeight - 1)) / ((displayHeight - 1) - tmp___2));
#line 752
      sendpointerevent((int )remote_xpos, (int )remote_ypos, (state & 7936) >> 8);
      }
    }
  }
  {
#line 756
  mouseOnScreen = 1;
#line 758
  selection_owner = XGetSelectionOwner(dpy, (Atom )1);
  }
#line 761
  if (selection_owner != 0UL) {
#line 761
    if (selection_owner != topLevel) {
      {
#line 763
      XConvertSelection(dpy, (Atom )1, (Atom )31, (Atom )9, topLevel, (Time )0L);
      }
    }
  }
  {
#line 767
  tmp___3 = time(0);
#line 767
  grab_timeout = (long )tmp___3 + grab_timeout_delay;
  }
#line 768
  return;
}
}
#line 770 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static void ungrabit(int x , int y , Window warpWindow ) 
{ 
  int i ;
  KeySym __attribute__((__deprecated__))  tmp ;
  int tmp___0 ;

  {
  {
#line 778
  SendPointerEvent(restingx, restingy, 0);
  }
#line 779
  if (x > -1) {
#line 779
    if (y > -1) {
      {
#line 781
      XWarpPointer(dpy, (Window )0L, warpWindow, 0, 0, 0U, 0U, x_offset + x, y_offset + y);
#line 782
      XFlush(dpy);
      }
    }
  }
  {
#line 784
  XUngrabKeyboard(dpy, (Time )0L);
#line 785
  XUngrabPointer(dpy, (Time )0L);
#line 786
  mouseOnScreen = warpWindow == (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root;
#line 787
  XFlush(dpy);
#line 789
  i = 255;
  }
  {
#line 789
  while (1) {
    while_continue: /* CIL Label */ ;
#line 789
    if (! (i >= 0)) {
#line 789
      goto while_break;
    }
#line 791
    if (modifierPressed[i]) {
      {
#line 792
      tmp = XKeycodeToKeysym(dpy, (KeyCode )i, 0);
#line 792
      tmp___0 = SendKeyEvent((CARD32 )tmp, 0);
      }
#line 792
      if (! tmp___0) {
#line 793
        return;
      }
#line 794
      modifierPressed[i] = 0;
    }
#line 789
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 804
  SendFramebufferUpdateRequest(0, 0, 1, 1, 0);
  }
#line 806
  if (! edge_width) {
    {
#line 806
    hidewindow();
    }
  }
#line 808
  grabbed = 0;
#line 809
  return;
}
}
#line 811 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static void shortsleep(int usec ) 
{ 
  struct timeval timeout ;

  {
  {
#line 814
  timeout.tv_sec = (__time_t )0;
#line 815
  timeout.tv_usec = (__suseconds_t )usec;
#line 816
  select(0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0,
         (struct timeval */* __restrict  */)(& timeout));
  }
#line 817
  return;
}
}
#line 820 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
void dumpMotionEvent(XEvent *ev ) 
{ 


  {
  {
#line 822
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"{ %d, %d } -> { %d, %d } = %d, %d\n",
          current_location.x, current_location.y, ev->xmotion.x_root - x_offset, ev->xmotion.y_root - y_offset,
          (ev->xmotion.x_root - x_offset) - current_location.x, (ev->xmotion.y_root - y_offset) - current_location.y);
  }
#line 829
  return;
}
}
#line 831 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
struct coord coord_subtract(struct coord a , struct coord b ) 
{ 
  struct coord tmp ;

  {
  {
#line 833
  tmp = mkcoord(a.x - b.x, a.y - b.y);
  }
#line 833
  return (tmp);
}
}
#line 836 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
struct coord coord_add(struct coord a , struct coord b ) 
{ 
  struct coord tmp ;

  {
  {
#line 838
  tmp = mkcoord(a.x + b.x, a.y + b.y);
  }
#line 838
  return (tmp);
}
}
#line 841 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int coord_dist_sq(struct coord a , struct coord b ) 
{ 


  {
  {
#line 843
  a = coord_subtract(a, b);
  }
#line 844
  return (a.x * a.x + a.y * a.y);
}
}
#line 847 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int coord_dist_from_edge(struct coord a ) 
{ 
  int n ;
  int ret ;

  {
#line 849
  ret = a.x;
#line 850
  if (a.y < ret) {
#line 850
    ret = a.y;
  }
#line 851
  n = (y_offset + displayHeight) - a.y;
#line 852
  if (n < ret) {
#line 852
    ret = n;
  }
#line 853
  n = (x_offset + displayWidth) - a.x;
#line 854
  if (n < ret) {
#line 854
    ret = n;
  }
#line 855
  return (ret);
}
}
#line 869 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static Atom COMPOUND_TEXT  ;
#line 871 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static Atom TARGETS  ;
#line 1007 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static long last_resurface  =    0L;
#line 861 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static int HandleTopLevelEvent(XEvent *ev ) 
{ 
  int x ;
  int y ;
  int buttonMask ;
  KeySym ks ;
  int tmp ;
  XEvent reply ;
  XSelectionRequestEvent *req ;
  Atom targets[2] ;
  char *name ;
  Atom t ;
  unsigned long len ;
  unsigned long bytes_left ;
  int format ;
  unsigned char *data ;
  int ret___1 ;
  long t___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int i___0 ;
  int d ;
  Window warpWindow ;
  struct coord offset ;
  struct coord tmp___5 ;
  struct coord new_location ;
  struct coord tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int l ;
  int ctrlcode ;
  KeyCode tmp___13 ;
  int ctrlcode___0 ;
  KeyCode tmp___14 ;
  int tmp___15 ;
  char keyname[256] ;
  KeySym __attribute__((__deprecated__))  tmp___16 ;
  char const   *tmp___17 ;
  int tmp___18 ;

  {
  {
#line 873
  tmp = time(0);
#line 873
  grab_timeout = (long )tmp + grab_timeout_delay;
  }
  {
#line 877
  if (ev->type == 30) {
#line 877
    goto case_30;
  }
#line 964
  if (ev->type == 31) {
#line 964
    goto case_31;
  }
#line 997
  if (ev->type == 15) {
#line 997
    goto case_15;
  }
#line 1027
  if (ev->type == 7) {
#line 1027
    goto case_7;
  }
#line 1036
  if (ev->type == 6) {
#line 1036
    goto case_6;
  }
#line 1157
  if (ev->type == 5) {
#line 1157
    goto case_5;
  }
#line 1157
  if (ev->type == 4) {
#line 1157
    goto case_5;
  }
#line 1218
  if (ev->type == 3) {
#line 1218
    goto case_3___0;
  }
#line 1218
  if (ev->type == 2) {
#line 1218
    goto case_3___0;
  }
#line 1265
  if (ev->type == 33) {
#line 1265
    goto case_33;
  }
#line 875
  goto switch_break;
  case_30: /* CIL Label */ 
#line 881
  req = & ev->xselectionrequest;
#line 883
  reply.xselection.type = 31;
#line 884
  reply.xselection.display = req->display;
#line 885
  reply.xselection.selection = req->selection;
#line 886
  reply.xselection.requestor = req->requestor;
#line 887
  reply.xselection.target = req->target;
#line 888
  reply.xselection.time = req->time;
#line 889
  reply.xselection.property = (Atom )0L;
#line 891
  if (COMPOUND_TEXT == 0UL) {
    {
#line 892
    COMPOUND_TEXT = XInternAtom(dpy, "COMPOUND_TEXT", 1);
    }
  }
#line 895
  if (TARGETS == 0UL) {
    {
#line 895
    TARGETS = XInternAtom(dpy, "TARGETS", 1);
    }
  }
#line 897
  if (client_selection_text) {
#line 899
    if (req->target == TARGETS) {
#line 909
      if (req->property == 0UL) {
#line 910
        req->property = TARGETS;
      }
      {
#line 912
      targets[0] = (Atom )31;
#line 913
      targets[1] = COMPOUND_TEXT;
#line 914
      XChangeProperty(dpy, req->requestor, req->property, (Atom )4, 32, 0, (unsigned char const   *)((unsigned char *)(targets)),
                      2);
#line 923
      reply.xselection.property = req->property;
      }
    } else
#line 925
    if (req->target == 31UL) {
#line 925
      goto _L;
    } else
#line 925
    if (req->target == COMPOUND_TEXT) {
      _L: /* CIL Label */ 
#line 928
      if (req->property == 0UL) {
#line 929
        req->property = (Atom )9;
      }
      {
#line 935
      XChangeProperty(dpy, req->requestor, req->property, req->target, 8, 0, (unsigned char const   *)client_selection_text,
                      (int )client_selection_text_length);
#line 944
      reply.xselection.property = req->property;
      }
    } else
#line 947
    if (debug) {
      {
#line 954
      name = XGetAtomName(dpy, req->target);
#line 955
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown property target request %s\n",
              name);
#line 956
      XFree((void *)name);
      }
    }
  }
  {
#line 959
  XSendEvent(dpy, req->requestor, 0, 0L, & reply);
#line 960
  XFlush(dpy);
  }
#line 962
  return (1);
  case_31: /* CIL Label */ 
  {
#line 967
  len = 0UL;
#line 968
  bytes_left = 0UL;
#line 970
  data = (unsigned char *)0;
#line 973
  ret___1 = XGetWindowProperty(dpy, topLevel, (Atom )9, 0L, 1048576L, 1, (Atom )31,
                               & t, & format, & len, & bytes_left, & data);
  }
#line 986
  if (format == 8) {
    {
#line 987
    SendClientCutText((char *)data, (int )len);
    }
  }
#line 992
  if (data) {
    {
#line 992
    XFree((void *)data);
    }
  }
#line 995
  return (1);
  case_15: /* CIL Label */ 
#line 1004
  if (ev->xvisibility.state == 1) {
#line 1004
    if (resurface) {
#line 1004
      if (! hidden) {
        {
#line 1008
        tmp___0 = time(0);
#line 1008
        t___0 = (long )tmp___0;
        }
#line 1010
        if (t___0 == last_resurface) {
          {
#line 1011
          shortsleep(5000);
          }
        }
        {
#line 1013
        last_resurface = t___0;
#line 1017
        mapwindow();
        }
      }
    }
  }
#line 1020
  return (1);
  case_7: /* CIL Label */ 
#line 1028
  if (! grabbed) {
#line 1028
    if (ev->xcrossing.mode == 0) {
#line 1030
      if ((unsigned int )edge == 2U) {
#line 1030
        tmp___1 = 1;
      } else
#line 1030
      if ((unsigned int )edge == 3U) {
#line 1030
        tmp___1 = 1;
      } else {
#line 1030
        tmp___1 = 0;
      }
      {
#line 1030
      tmp___2 = enter_translate(tmp___1, displayHeight, ev->xcrossing.y_root - y_offset);
      }
#line 1030
      if ((unsigned int )edge == 0U) {
#line 1030
        tmp___3 = 1;
      } else
#line 1030
      if ((unsigned int )edge == 1U) {
#line 1030
        tmp___3 = 1;
      } else {
#line 1030
        tmp___3 = 0;
      }
      {
#line 1030
      tmp___4 = enter_translate(tmp___3, displayWidth, ev->xcrossing.x_root - x_offset);
#line 1030
      grabit(tmp___4, tmp___2, (int )ev->xcrossing.state);
      }
    }
  }
#line 1034
  return (1);
  case_6: /* CIL Label */ 
#line 1038
  if (grabbed) {
    {
#line 1040
    d = 0;
#line 1042
    tmp___5 = mkcoord(0, 0);
#line 1042
    offset = tmp___5;
    }
    {
#line 1044
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1055
      tmp___6 = mkcoord(ev->xmotion.x_root, ev->xmotion.y_root);
#line 1055
      new_location = tmp___6;
      }
#line 1056
      if (debug) {
        {
#line 1058
        dumpMotionEvent(ev);
        }
#line 1060
        if (next_origo) {
          {
#line 1061
          tmp___7 = coord_dist_sq(new_location, current_location);
#line 1061
          tmp___8 = coord_dist_sq(new_location, *next_origo);
#line 1061
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" {%d} <? {%d}\n",
                  tmp___8, tmp___7);
          }
        }
      }
#line 1064
      motion_events ++;
#line 1066
      if (next_origo) {
        {
#line 1066
        tmp___9 = coord_dist_sq(new_location, *next_origo);
#line 1066
        tmp___10 = coord_dist_sq(new_location, current_location);
        }
#line 1066
        if (tmp___9 < tmp___10) {
#line 1070
          current_origo = next_origo;
#line 1071
          current_location = *next_origo;
#line 1072
          next_origo = (struct coord *)((void *)0);
#line 1073
          motion_events = 0;
        } else {
          {
#line 1066
          tmp___11 = coord_dist_from_edge(new_location);
          }
#line 1066
          if (tmp___11 < motion_events) {
#line 1070
            current_origo = next_origo;
#line 1071
            current_location = *next_origo;
#line 1072
            next_origo = (struct coord *)((void *)0);
#line 1073
            motion_events = 0;
          }
        }
      }
      {
#line 1076
      current_speed = coord_subtract(new_location, current_location);
      }
#line 1077
      if (current_origo) {
        {
#line 1078
        offset = coord_add(offset, current_speed);
        }
      }
      {
#line 1079
      current_location = new_location;
#line 1044
      tmp___12 = XCheckTypedWindowEvent(dpy, topLevel, 6, ev);
      }
#line 1044
      if (! tmp___12) {
#line 1044
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1084
    if (pointer_speed > (float )1) {
#line 1084
      if (offset.x * offset.x + offset.y * offset.y < pointer_warp_threshold) {
#line 1088
        remote_xpos += (float )offset.x;
#line 1089
        remote_ypos += (float )offset.y;
      } else {
#line 1091
        remote_xpos += (float )offset.x * pointer_speed;
#line 1092
        remote_ypos += (float )offset.y * pointer_speed;
      }
    } else {
#line 1091
      remote_xpos += (float )offset.x * pointer_speed;
#line 1092
      remote_ypos += (float )offset.y * pointer_speed;
    }
#line 1102
    if (! (ev->xmotion.state & 7936U)) {
#line 1104
      warpWindow = (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root;
      {
#line 1107
      if ((unsigned int )edge == 2U) {
#line 1107
        goto case_2;
      }
#line 1112
      if ((unsigned int )edge == 3U) {
#line 1112
        goto case_3;
      }
#line 1117
      if ((unsigned int )edge == 0U) {
#line 1117
        goto case_0;
      }
#line 1122
      if ((unsigned int )edge == 1U) {
#line 1122
        goto case_1;
      }
#line 1105
      goto switch_break___0;
      case_2: /* CIL Label */ 
#line 1108
      d = remote_ypos >= (float )si.framebufferHeight;
#line 1109
      y = edge_width;
#line 1110
      x = (int )((remote_xpos * (float )displayWidth) / (float )si.framebufferWidth);
#line 1111
      goto switch_break___0;
      case_3: /* CIL Label */ 
#line 1113
      d = remote_ypos < (float )0;
#line 1114
      y = (displayHeight - edge_width) - 1;
#line 1115
      x = (int )((remote_xpos * (float )displayWidth) / (float )si.framebufferWidth);
#line 1116
      goto switch_break___0;
      case_0: /* CIL Label */ 
#line 1118
      d = remote_xpos < (float )0;
#line 1119
      x = (displayWidth - edge_width) - 1;
#line 1120
      y = (int )((remote_ypos * (float )displayHeight) / (float )si.framebufferHeight);
#line 1121
      goto switch_break___0;
      case_1: /* CIL Label */ 
#line 1123
      d = remote_xpos > (float )si.framebufferWidth;
#line 1124
      x = edge_width;
#line 1125
      y = (int )((remote_ypos * (float )displayHeight) / (float )si.framebufferHeight);
#line 1126
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1130
    if (d) {
#line 1132
      if (x < 0) {
#line 1132
        x = 0;
      }
#line 1133
      if (y < 0) {
#line 1133
        y = 0;
      }
#line 1134
      if (y >= displayHeight) {
#line 1134
        y = displayHeight - 1;
      }
#line 1135
      if (x >= displayWidth) {
#line 1135
        x = displayWidth - 1;
      }
      {
#line 1136
      ungrabit(x, y, warpWindow);
      }
#line 1137
      return (1);
    } else {
#line 1139
      if (remote_xpos < (float )0) {
#line 1139
        remote_xpos = (float )0;
      }
#line 1140
      if (remote_ypos < (float )0) {
#line 1140
        remote_ypos = (float )0;
      }
#line 1142
      if (remote_xpos >= (float )si.framebufferWidth) {
#line 1143
        remote_xpos = (float )((int )si.framebufferWidth - 1);
      }
#line 1145
      if (remote_ypos >= (float )si.framebufferHeight) {
#line 1146
        remote_ypos = (float )((int )si.framebufferHeight - 1);
      }
      {
#line 1148
      i___0 = sendpointerevent((int )remote_xpos, (int )remote_ypos, (int )((ev->xmotion.state & 7936U) >> 8));
      }
    }
  }
#line 1154
  return (1);
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 1158
  if (emulate_wheel) {
#line 1158
    if (ev->xbutton.button >= 4U) {
#line 1158
      if (ev->xbutton.button <= 5U) {
#line 1163
        if (ev->xbutton.button == (unsigned int )wheel_button_up) {
#line 1164
          ks = (KeySym )65362;
        } else {
#line 1166
          ks = (KeySym )65364;
        }
#line 1168
        if (ev->type == 4) {
#line 1170
          l = 1;
          {
#line 1170
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1170
            if (! (l < scroll_lines)) {
#line 1170
              goto while_break___0;
            }
            {
#line 1172
            SendKeyEvent((CARD32 )ks, 1);
#line 1173
            SendKeyEvent((CARD32 )ks, 0);
#line 1170
            l ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
        {
#line 1177
        SendKeyEvent((CARD32 )ks, ev->type == 4);
        }
#line 1178
        goto switch_break;
      }
    }
  }
#line 1181
  if (emulate_nav) {
#line 1181
    if (ev->xbutton.button >= 6U) {
#line 1181
      if (ev->xbutton.button <= 7U) {
#line 1186
        if (ev->xbutton.button == 6U) {
#line 1187
          ks = (KeySym )65361;
        } else {
#line 1189
          ks = (KeySym )65363;
        }
        {
#line 1191
        tmp___13 = XKeysymToKeycode(dpy, (KeySym )65513);
#line 1191
        ctrlcode = (int )tmp___13;
#line 1192
        SendKeyEvent((CARD32 )65513, ev->type == 4);
#line 1193
        modifierPressed[ctrlcode] = ev->type == 4;
#line 1194
        SendKeyEvent((CARD32 )ks, ev->type == 4);
        }
#line 1195
        goto switch_break;
      }
    }
  }
#line 1198
  if (mac_mode) {
#line 1198
    if (ev->xbutton.button == 3U) {
      {
#line 1200
      tmp___14 = XKeysymToKeycode(dpy, (KeySym )65507);
#line 1200
      ctrlcode___0 = (int )tmp___14;
#line 1201
      SendKeyEvent((CARD32 )65507, ev->type == 4);
#line 1202
      modifierPressed[ctrlcode___0] = ev->type == 4;
      }
    }
  }
#line 1205
  if (ev->type == 4) {
#line 1206
    buttonMask = (int )(((ev->xbutton.state & 7936U) >> 8) | (unsigned int )(1 << (ev->xbutton.button - 1U)));
  } else {
#line 1209
    buttonMask = (int )(((ev->xbutton.state & 7936U) >> 8) & (unsigned int )(~ (1 << (ev->xbutton.button - 1U))));
  }
  {
#line 1213
  tmp___15 = sendpointerevent((int )remote_xpos, (int )remote_ypos, buttonMask);
  }
#line 1213
  return (tmp___15);
  case_3___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  {
#line 1221
  keyname[0] = (char )'\000';
#line 1224
  XLookupString(& ev->xkey, keyname, 256, & ks, (XComposeStatus *)((void *)0));
  }
#line 1227
  if (ev->type == 2) {
#line 1227
    if (ev->xkey.keycode == (unsigned int )grabkey) {
#line 1227
      if (ev->xkey.state == (unsigned int )grabmod) {
        {
#line 1232
        saved_remote_xpos = (int )remote_xpos;
#line 1233
        saved_remote_ypos = (int )remote_ypos;
#line 1234
        ungrabit(saved_xpos, saved_ypos, (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root);
        }
#line 1235
        return (1);
      } else
#line 1227
      if ((ev->xkey.state & (unsigned int )(~ (1 << 4))) == (unsigned int )grabmod) {
        {
#line 1232
        saved_remote_xpos = (int )remote_xpos;
#line 1233
        saved_remote_ypos = (int )remote_ypos;
#line 1234
        ungrabit(saved_xpos, saved_ypos, (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root);
        }
#line 1235
        return (1);
      }
    }
  }
#line 1237
  if (ks >= 65505UL) {
#line 1237
    if (ks <= 65518UL) {
#line 1237
      goto _L___0;
    } else {
#line 1237
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1237
  if (ks >= 65025UL) {
#line 1237
    if (ks <= 65043UL) {
#line 1237
      goto _L___0;
    } else {
#line 1237
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1237
  if (ks == 65406UL) {
#line 1237
    goto _L___0;
  } else
#line 1237
  if (ks == 65407UL) {
    _L___0: /* CIL Label */ 
    {
#line 1238
    tmp___16 = XKeycodeToKeysym(dpy, (KeyCode )ev->xkey.keycode, 0);
#line 1238
    ks = (KeySym )tmp___16;
    }
#line 1241
    if (ks == 65406UL) {
#line 1241
      return (1);
    }
#line 1243
    modifierPressed[ev->xkey.keycode] = ev->type == 2;
  } else {
    {
#line 1251
    if (ks == 65056UL) {
#line 1251
      goto case_65056;
    }
#line 1251
    if (ks == 268500852UL) {
#line 1251
      goto case_65056;
    }
#line 1246
    goto switch_break___1;
    case_65056: /* CIL Label */ 
    case_268500852: /* CIL Label */ 
#line 1251
    ks = (KeySym )65289;
#line 1251
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
#line 1255
  if (debug) {
#line 1256
    if (ev->type == 2) {
#line 1256
      tmp___17 = "down";
    } else {
#line 1256
      tmp___17 = "up";
    }
    {
#line 1256
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  --> %x (%c) name=%s (%s)\n",
            ks, ks, keyname, tmp___17);
    }
  }
  {
#line 1260
  remote_is_locked = 0;
#line 1262
  tmp___18 = SendKeyEvent((CARD32 )ks, ev->type == 2);
  }
#line 1262
  return (tmp___18);
  case_33: /* CIL Label */ 
#line 1266
  if (ev->xclient.message_type == wmProtocols) {
#line 1266
    if ((Atom )ev->xclient.data.l[0] == wmDeleteWindow) {
      {
#line 1269
      exit(0);
      }
    }
  }
#line 1271
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1274
  return (1);
}
}
#line 1277 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int get_root_int_prop(Atom property ) 
{ 
  unsigned char *data ;
  Atom t ;
  int format ;
  unsigned long len ;
  unsigned long bytes_left ;
  int ret ;
  int tmp ;

  {
  {
#line 1279
  data = (unsigned char *)0;
#line 1284
  tmp = XGetWindowProperty(dpy, (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root,
                           property, 0L, 1L, 0, (Atom )6, & t, & format, & len, & bytes_left,
                           & data);
#line 1284
  ret = tmp;
#line 1297
  ret = (int )*((CARD32 *)data);
  }
#line 1299
  if (data) {
    {
#line 1300
    XFree((void *)data);
    }
  }
#line 1302
  return (ret);
}
}
#line 1305 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
void check_desktop(void) 
{ 
  int t ;
  int tmp ;

  {
  {
#line 1307
  t = requested_desktop;
#line 1309
  current_desktop = get_root_int_prop(current_desktop_atom);
  }
  {
#line 1313
  if (t == -2) {
#line 1313
    goto case_neg_2;
  }
#line 1314
  if (t == -1) {
#line 1314
    goto case_neg_1;
  }
#line 1311
  goto switch_break;
  case_neg_2: /* CIL Label */ 
#line 1313
  t = current_desktop;
#line 1313
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 1315
  tmp = get_root_int_prop(number_of_desktops_atom);
#line 1315
  t = tmp - 1;
  }
#line 1316
  if (t < 0) {
#line 1316
    t = 0;
  }
#line 1317
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1319
  if (t == current_desktop) {
    {
#line 1321
    mapwindow();
    }
  } else {
    {
#line 1323
    hidewindow();
    }
  }
#line 1325
  return;
}
}
#line 1331 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
static int HandleRootEvent(XEvent *ev ) 
{ 
  char *str ;
  int len ;
  int nowOnScreen ;
  int grab ;
  int x ;
  int y ;
  KeySym ks ;
  char keyname[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1350
  if (ev->type == 2) {
#line 1350
    goto case_2;
  }
#line 1369
  if (ev->type == 8) {
#line 1369
    goto case_8;
  }
#line 1369
  if (ev->type == 7) {
#line 1369
    goto case_8;
  }
#line 1433
  if (ev->type == 28) {
#line 1433
    goto case_28;
  }
#line 1343
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1348
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1354
  keyname[0] = (char )'\000';
#line 1355
  XLookupString(& ev->xkey, keyname, 256, & ks, (XComposeStatus *)((void *)0));
  }
#line 1359
  if (ev->xkey.keycode) {
    {
#line 1361
    saved_xpos = ev->xkey.x_root - x_offset;
#line 1362
    saved_ypos = ev->xkey.y_root - y_offset;
#line 1363
    grabit(saved_remote_xpos, saved_remote_ypos, 0);
    }
  }
#line 1365
  goto switch_break;
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 1374
  if (ev->xcrossing.subwindow == topLevel) {
#line 1374
    if (! ev->xcrossing.same_screen) {
#line 1376
      goto switch_break;
    }
  }
#line 1379
  grab = 0;
#line 1380
  if (! grabbed) {
#line 1382
    nowOnScreen = ev->xcrossing.same_screen;
#line 1383
    if (mouseOnScreen != nowOnScreen) {
#line 1394
      x = ev->xcrossing.x_root - x_offset;
#line 1395
      y = ev->xcrossing.x_root - x_offset;
#line 1396
      if (! nowOnScreen) {
#line 1397
        if ((unsigned int )edge == 0U) {
#line 1397
          tmp = 1;
        } else
#line 1397
        if ((unsigned int )edge == 1U) {
#line 1397
          tmp = 1;
        } else {
#line 1397
          tmp = 0;
        }
        {
#line 1397
        x = enter_translate(tmp, displayWidth, ev->xcrossing.x_root - x_offset);
        }
#line 1398
        if ((unsigned int )edge == 2U) {
#line 1398
          tmp___0 = 1;
        } else
#line 1398
        if ((unsigned int )edge == 3U) {
#line 1398
          tmp___0 = 1;
        } else {
#line 1398
          tmp___0 = 0;
        }
        {
#line 1398
        y = enter_translate(tmp___0, displayHeight, ev->xcrossing.y_root - y_offset);
        }
      }
      {
#line 1402
      if ((unsigned int )edge == 2U) {
#line 1402
        goto case_2___0;
      }
#line 1405
      if ((unsigned int )edge == 3U) {
#line 1405
        goto case_3;
      }
#line 1408
      if ((unsigned int )edge == 0U) {
#line 1408
        goto case_0;
      }
#line 1411
      if ((unsigned int )edge == 1U) {
#line 1411
        goto case_1;
      }
#line 1400
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 1403
      grab = y < displayHeight / 2;
#line 1404
      goto switch_break___0;
      case_3: /* CIL Label */ 
#line 1406
      grab = y > displayHeight / 2;
#line 1407
      goto switch_break___0;
      case_0: /* CIL Label */ 
#line 1409
      grab = x > displayWidth / 2;
#line 1410
      goto switch_break___0;
      case_1: /* CIL Label */ 
#line 1412
      grab = x < displayWidth / 2;
#line 1413
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1416
    mouseOnScreen = nowOnScreen;
  }
#line 1425
  if (grab) {
#line 1425
    if (ev->xcrossing.mode == 0) {
#line 1427
      if ((unsigned int )edge == 2U) {
#line 1427
        tmp___1 = 1;
      } else
#line 1427
      if ((unsigned int )edge == 3U) {
#line 1427
        tmp___1 = 1;
      } else {
#line 1427
        tmp___1 = 0;
      }
      {
#line 1427
      tmp___2 = enter_translate(tmp___1, displayHeight, ev->xcrossing.y_root - y_offset);
      }
#line 1427
      if ((unsigned int )edge == 0U) {
#line 1427
        tmp___3 = 1;
      } else
#line 1427
      if ((unsigned int )edge == 1U) {
#line 1427
        tmp___3 = 1;
      } else {
#line 1427
        tmp___3 = 0;
      }
      {
#line 1427
      tmp___4 = enter_translate(tmp___3, displayWidth, ev->xcrossing.x_root - x_offset);
#line 1427
      grabit(tmp___4, tmp___2, (int )ev->xcrossing.state);
      }
    }
  }
#line 1431
  goto switch_break;
  case_28: /* CIL Label */ 
#line 1434
  if (ev->xproperty.atom == 9UL) {
    {
#line 1436
    str = XFetchBytes(dpy, & len);
    }
#line 1437
    if (str) {
      {
#line 1441
      tmp___5 = SendClientCutText(str, len);
      }
#line 1441
      if (! tmp___5) {
#line 1442
        return (0);
      }
      {
#line 1443
      XFree((void *)str);
      }
    }
  }
#line 1446
  if (ev->xproperty.atom == current_desktop_atom) {
    {
#line 1448
    check_desktop();
    }
  } else
#line 1446
  if (ev->xproperty.atom == number_of_desktops_atom) {
    {
#line 1448
    check_desktop();
    }
  }
#line 1450
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1453
  return (1);
}
}
#line 1456 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
void handle_cut_text(char *str , size_t len ) 
{ 
  XWindowAttributes attrs ;

  {
#line 1460
  if (client_selection_text) {
    {
#line 1461
    free((void *)client_selection_text);
    }
  }
  {
#line 1463
  client_selection_text_length = len;
#line 1464
  client_selection_text = str;
#line 1466
  XGetWindowAttributes(dpy, (((_XPrivDisplay )dpy)->screens + 0)->root, & attrs);
#line 1467
  XSelectInput(dpy, (((_XPrivDisplay )dpy)->screens + 0)->root, attrs.your_event_mask & ~ (1L << 22));
#line 1469
  XStoreBytes(dpy, (char const   *)str, (int )len);
#line 1470
  XSetSelectionOwner(dpy, (Atom )1, topLevel, (Time )0L);
#line 1471
  XSelectInput(dpy, (((_XPrivDisplay )dpy)->screens + 0)->root, attrs.your_event_mask);
  }
#line 1472
  return;
}
}
#line 1480 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
int AllXEventsPredicate(Display *dpy___0 , XEvent *ev , char *arg ) 
{ 


  {
#line 1483
  return (1);
}
}
#line 1487 "/home/june/repo/benchmarks/collector2/temp/x2vnc-1.7.2/x.c"
void sethotkey(char *key ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 1489
  grabmod = 0;
  {
#line 1498
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1500
    tmp = strncasecmp((char const   *)key, "s-", (sizeof("s") + 1UL) - sizeof(""));
    }
#line 1500
    if (! tmp) {
#line 1500
      grabmod |= 1;
#line 1500
      key += (sizeof("s") + 1UL) - sizeof("");
#line 1500
      goto while_continue;
    }
    {
#line 1501
    tmp___0 = strncasecmp((char const   *)key, "shift-", (sizeof("shift") + 1UL) - sizeof(""));
    }
#line 1501
    if (! tmp___0) {
#line 1501
      grabmod |= 1;
#line 1501
      key += (sizeof("shift") + 1UL) - sizeof("");
#line 1501
      goto while_continue;
    }
    {
#line 1503
    tmp___1 = strncasecmp((char const   *)key, "c-", (sizeof("c") + 1UL) - sizeof(""));
    }
#line 1503
    if (! tmp___1) {
#line 1503
      grabmod |= 1 << 2;
#line 1503
      key += (sizeof("c") + 1UL) - sizeof("");
#line 1503
      goto while_continue;
    }
    {
#line 1504
    tmp___2 = strncasecmp((char const   *)key, "ctrl-", (sizeof("ctrl") + 1UL) - sizeof(""));
    }
#line 1504
    if (! tmp___2) {
#line 1504
      grabmod |= 1 << 2;
#line 1504
      key += (sizeof("ctrl") + 1UL) - sizeof("");
#line 1504
      goto while_continue;
    }
    {
#line 1505
    tmp___3 = strncasecmp((char const   *)key, "control-", (sizeof("control") + 1UL) - sizeof(""));
    }
#line 1505
    if (! tmp___3) {
#line 1505
      grabmod |= 1 << 2;
#line 1505
      key += (sizeof("control") + 1UL) - sizeof("");
#line 1505
      goto while_continue;
    }
    {
#line 1507
    tmp___4 = strncasecmp((char const   *)key, "a-", (sizeof("a") + 1UL) - sizeof(""));
    }
#line 1507
    if (! tmp___4) {
#line 1507
      grabmod |= 1 << 3;
#line 1507
      key += (sizeof("a") + 1UL) - sizeof("");
#line 1507
      goto while_continue;
    }
    {
#line 1508
    tmp___5 = strncasecmp((char const   *)key, "alt-", (sizeof("alt") + 1UL) - sizeof(""));
    }
#line 1508
    if (! tmp___5) {
#line 1508
      grabmod |= 1 << 3;
#line 1508
      key += (sizeof("alt") + 1UL) - sizeof("");
#line 1508
      goto while_continue;
    }
    {
#line 1509
    tmp___6 = strncasecmp((char const   *)key, "mod1-", (sizeof("mod1") + 1UL) - sizeof(""));
    }
#line 1509
    if (! tmp___6) {
#line 1509
      grabmod |= 1 << 3;
#line 1509
      key += (sizeof("mod1") + 1UL) - sizeof("");
#line 1509
      goto while_continue;
    }
    {
#line 1511
    tmp___7 = strncasecmp((char const   *)key, "mod2-", (sizeof("mod2") + 1UL) - sizeof(""));
    }
#line 1511
    if (! tmp___7) {
#line 1511
      grabmod |= 1 << 4;
#line 1511
      key += (sizeof("mod2") + 1UL) - sizeof("");
#line 1511
      goto while_continue;
    }
    {
#line 1513
    tmp___8 = strncasecmp((char const   *)key, "m-", (sizeof("m") + 1UL) - sizeof(""));
    }
#line 1513
    if (! tmp___8) {
#line 1513
      grabmod |= 1 << 5;
#line 1513
      key += (sizeof("m") + 1UL) - sizeof("");
#line 1513
      goto while_continue;
    }
    {
#line 1514
    tmp___9 = strncasecmp((char const   *)key, "meta-", (sizeof("meta") + 1UL) - sizeof(""));
    }
#line 1514
    if (! tmp___9) {
#line 1514
      grabmod |= 1 << 5;
#line 1514
      key += (sizeof("meta") + 1UL) - sizeof("");
#line 1514
      goto while_continue;
    }
    {
#line 1515
    tmp___10 = strncasecmp((char const   *)key, "mod3-", (sizeof("mod3") + 1UL) - sizeof(""));
    }
#line 1515
    if (! tmp___10) {
#line 1515
      grabmod |= 1 << 5;
#line 1515
      key += (sizeof("mod3") + 1UL) - sizeof("");
#line 1515
      goto while_continue;
    }
    {
#line 1517
    tmp___11 = strncasecmp((char const   *)key, "super-", (sizeof("super") + 1UL) - sizeof(""));
    }
#line 1517
    if (! tmp___11) {
#line 1517
      grabmod |= 1 << 6;
#line 1517
      key += (sizeof("super") + 1UL) - sizeof("");
#line 1517
      goto while_continue;
    }
    {
#line 1518
    tmp___12 = strncasecmp((char const   *)key, "mod4-", (sizeof("mod4") + 1UL) - sizeof(""));
    }
#line 1518
    if (! tmp___12) {
#line 1518
      grabmod |= 1 << 6;
#line 1518
      key += (sizeof("mod4") + 1UL) - sizeof("");
#line 1518
      goto while_continue;
    }
    {
#line 1520
    tmp___13 = strncasecmp((char const   *)key, "hyper-", (sizeof("hyper") + 1UL) - sizeof(""));
    }
#line 1520
    if (! tmp___13) {
#line 1520
      grabmod |= 1 << 7;
#line 1520
      key += (sizeof("hyper") + 1UL) - sizeof("");
#line 1520
      goto while_continue;
    }
    {
#line 1521
    tmp___14 = strncasecmp((char const   *)key, "mod5-", (sizeof("mod5") + 1UL) - sizeof(""));
    }
#line 1521
    if (! tmp___14) {
#line 1521
      grabmod |= 1 << 7;
#line 1521
      key += (sizeof("mod5") + 1UL) - sizeof("");
#line 1521
      goto while_continue;
    }
#line 1523
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1526
  grabkeysym = XStringToKeysym((char const   *)key);
  }
#line 1527
  return;
}
}
