/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct___fsid_t_1 {
   int __val[2] ;
};
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct___fsid_t_1 __fsid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 163 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 170 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 60 "/usr/include/x86_64-linux-gnu/sys/wait.h"
union wait;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_40 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_41 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_40 __wait_terminated ;
   struct __anonstruct___wait_stopped_41 __wait_stopped ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/statfs.h"
struct statfs {
   __fsword_t f_type ;
   __fsword_t f_bsize ;
   __fsblkcnt64_t f_blocks ;
   __fsblkcnt64_t f_bfree ;
   __fsblkcnt64_t f_bavail ;
   __fsfilcnt64_t f_files ;
   __fsfilcnt64_t f_ffree ;
   __fsid_t f_fsid ;
   __fsword_t f_namelen ;
   __fsword_t f_frsize ;
   __fsword_t f_flags ;
   __fsword_t f_spare[4] ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 138 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
struct name_entry {
   char f_name[128] ;
   char write_dir[40] ;
   char target_dir[40] ;
};
#line 149 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
struct __anonstruct_child_job_t_56 {
   pid_t child_pid ;
   char test_dir[4096] ;
};
#line 149 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
typedef struct __anonstruct_child_job_t_56 child_job_t;
#line 157 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
struct __anonstruct_fs_mark_stat_t_57 {
   unsigned int file_count ;
   float files_per_sec ;
   unsigned long long app_overhead_usec ;
   unsigned long long min_creat_usec ;
   unsigned long long avg_creat_usec ;
   unsigned long long max_creat_usec ;
   unsigned long long min_write_usec ;
   unsigned long long avg_write_usec ;
   unsigned long long max_write_usec ;
   unsigned long long min_fsync_usec ;
   unsigned long long avg_fsync_usec ;
   unsigned long long max_fsync_usec ;
   unsigned long long min_sync_usec ;
   unsigned long long avg_sync_usec ;
   unsigned long long max_sync_usec ;
   unsigned long long min_unlink_usec ;
   unsigned long long avg_unlink_usec ;
   unsigned long long max_unlink_usec ;
   unsigned long long min_close_usec ;
   unsigned long long avg_close_usec ;
   unsigned long long max_close_usec ;
};
#line 157 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
typedef struct __anonstruct_fs_mark_stat_t_57 fs_mark_stat_t;
#line 27 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
char *fs_mark_version  =    (char *)"3.3";
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 321 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 35 "/usr/include/x86_64-linux-gnu/sys/statfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) statfs)(char const   *__file ,
                                                                                               struct statfs *__buf )  __asm__("statfs64")  ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 956 "/usr/include/unistd.h"
extern int fsync(int __fd ) ;
#line 972
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) sync)(void) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 321
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 324
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
char const   dir_policy_string[3][160]  = { {        (char const   )'N',        (char const   )'o',        (char const   )' ',        (char const   )'s', 
            (char const   )'u',        (char const   )'b',        (char const   )'d',        (char const   )'i', 
            (char const   )'r',        (char const   )'e',        (char const   )'c',        (char const   )'t', 
            (char const   )'o',        (char const   )'r',        (char const   )'i',        (char const   )'e', 
            (char const   )'s',        (char const   )'\000'}, 
   {        (char const   )'R',        (char const   )'o',        (char const   )'u',        (char const   )'n', 
            (char const   )'d',        (char const   )' ',        (char const   )'R',        (char const   )'o', 
            (char const   )'b',        (char const   )'i',        (char const   )'n',        (char const   )' ', 
            (char const   )'b',        (char const   )'e',        (char const   )'t',        (char const   )'w', 
            (char const   )'e',        (char const   )'e',        (char const   )'n',        (char const   )' ', 
            (char const   )'d',        (char const   )'i',        (char const   )'r',        (char const   )'e', 
            (char const   )'c',        (char const   )'t',        (char const   )'o',        (char const   )'r', 
            (char const   )'i',        (char const   )'e',        (char const   )'s',        (char const   )'\000'}, 
   {        (char const   )'T',        (char const   )'i',        (char const   )'m',        (char const   )'e', 
            (char const   )' ',        (char const   )'b',        (char const   )'a',        (char const   )'s', 
            (char const   )'e',        (char const   )'d',        (char const   )' ',        (char const   )'h', 
            (char const   )'a',        (char const   )'s',        (char const   )'h',        (char const   )' ', 
            (char const   )'b',        (char const   )'e',        (char const   )'t',        (char const   )'w', 
            (char const   )'e',        (char const   )'e',        (char const   )'n',        (char const   )' ', 
            (char const   )'d',        (char const   )'i',        (char const   )'r',        (char const   )'e', 
            (char const   )'c',        (char const   )'t',        (char const   )'o',        (char const   )'r', 
            (char const   )'i',        (char const   )'e',        (char const   )'s',        (char const   )'\000'}};
#line 61 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
int dir_policy  =    0;
#line 84 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
char const   sync_policy_string[7][160]  = { {        (char const   )'N',        (char const   )'O',        (char const   )' ',        (char const   )'S', 
            (char const   )'Y',        (char const   )'N',        (char const   )'C',        (char const   )':', 
            (char const   )' ',        (char const   )'T',        (char const   )'e',        (char const   )'s', 
            (char const   )'t',        (char const   )' ',        (char const   )'d',        (char const   )'o', 
            (char const   )'e',        (char const   )'s',        (char const   )' ',        (char const   )'n', 
            (char const   )'o',        (char const   )'t',        (char const   )' ',        (char const   )'i', 
            (char const   )'s',        (char const   )'s',        (char const   )'u',        (char const   )'e', 
            (char const   )' ',        (char const   )'s',        (char const   )'y',        (char const   )'n', 
            (char const   )'c',        (char const   )'(',        (char const   )')',        (char const   )' ', 
            (char const   )'o',        (char const   )'r',        (char const   )' ',        (char const   )'f', 
            (char const   )'s',        (char const   )'y',        (char const   )'n',        (char const   )'c', 
            (char const   )'(',        (char const   )')',        (char const   )' ',        (char const   )'c', 
            (char const   )'a',        (char const   )'l',        (char const   )'l',        (char const   )'s', 
            (char const   )'.',        (char const   )'\000'}, 
   {        (char const   )'I',        (char const   )'N',        (char const   )'B',        (char const   )'A', 
            (char const   )'N',        (char const   )'D',        (char const   )' ',        (char const   )'F', 
            (char const   )'S',        (char const   )'Y',        (char const   )'N',        (char const   )'C', 
            (char const   )':',        (char const   )' ',        (char const   )'f',        (char const   )'s', 
            (char const   )'y',        (char const   )'n',        (char const   )'c',        (char const   )'(', 
            (char const   )')',        (char const   )' ',        (char const   )'p',        (char const   )'e', 
            (char const   )'r',        (char const   )' ',        (char const   )'f',        (char const   )'i', 
            (char const   )'l',        (char const   )'e',        (char const   )' ',        (char const   )'i', 
            (char const   )'n',        (char const   )' ',        (char const   )'w',        (char const   )'r', 
            (char const   )'i',        (char const   )'t',        (char const   )'e',        (char const   )' ', 
            (char const   )'l',        (char const   )'o',        (char const   )'o',        (char const   )'p', 
            (char const   )'.',        (char const   )'\000'}, 
   {        (char const   )'S',        (char const   )'Y',        (char const   )'S',        (char const   )'T', 
            (char const   )'E',        (char const   )'M',        (char const   )' ',        (char const   )'S', 
            (char const   )'Y',        (char const   )'N',        (char const   )'C',        (char const   )'/', 
            (char const   )'S',        (char const   )'I',        (char const   )'N',        (char const   )'G', 
            (char const   )'L',        (char const   )'E',        (char const   )' ',        (char const   )'F', 
            (char const   )'S',        (char const   )'Y',        (char const   )'N',        (char const   )'C', 
            (char const   )':',        (char const   )' ',        (char const   )'I',        (char const   )'s', 
            (char const   )'s',        (char const   )'u',        (char const   )'e',        (char const   )' ', 
            (char const   )'s',        (char const   )'y',        (char const   )'n',        (char const   )'c', 
            (char const   )'(',        (char const   )')',        (char const   )' ',        (char const   )'a', 
            (char const   )'f',        (char const   )'t',        (char const   )'e',        (char const   )'r', 
            (char const   )' ',        (char const   )'m',        (char const   )'a',        (char const   )'i', 
            (char const   )'n',        (char const   )' ',        (char const   )'w',        (char const   )'r', 
            (char const   )'i',        (char const   )'t',        (char const   )'e',        (char const   )' ', 
            (char const   )'l',        (char const   )'o',        (char const   )'o',        (char const   )'p', 
            (char const   )' ',        (char const   )'a',        (char const   )'n',        (char const   )'d', 
            (char const   )' ',        (char const   )'1',        (char const   )' ',        (char const   )'f', 
            (char const   )'i',        (char const   )'l',        (char const   )'e',        (char const   )' ', 
            (char const   )'f',        (char const   )'s',        (char const   )'y',        (char const   )'n', 
            (char const   )'c',        (char const   )'(',        (char const   )')',        (char const   )' ', 
            (char const   )'p',        (char const   )'e',        (char const   )'r',        (char const   )' ', 
            (char const   )'s',        (char const   )'u',        (char const   )'b',        (char const   )'d', 
            (char const   )'i',        (char const   )'r',        (char const   )'e',        (char const   )'c', 
            (char const   )'t',        (char const   )'o',        (char const   )'r',        (char const   )'y', 
            (char const   )'.',        (char const   )'\000'}, 
   {        (char const   )'P',        (char const   )'O',        (char const   )'S',        (char const   )'T', 
            (char const   )' ',        (char const   )'R',        (char const   )'E',        (char const   )'V', 
            (char const   )'E',        (char const   )'R',        (char const   )'S',        (char const   )'E', 
            (char const   )':',        (char const   )' ',        (char const   )'R',        (char const   )'e', 
            (char const   )'o',        (char const   )'p',        (char const   )'e',        (char const   )'n', 
            (char const   )' ',        (char const   )'a',        (char const   )'n',        (char const   )'d', 
            (char const   )' ',        (char const   )'f',        (char const   )'s',        (char const   )'y', 
            (char const   )'n',        (char const   )'c',        (char const   )'(',        (char const   )')', 
            (char const   )' ',        (char const   )'e',        (char const   )'a',        (char const   )'c', 
            (char const   )'h',        (char const   )' ',        (char const   )'f',        (char const   )'i', 
            (char const   )'l',        (char const   )'e',        (char const   )' ',        (char const   )'i', 
            (char const   )'n',        (char const   )' ',        (char const   )'r',        (char const   )'e', 
            (char const   )'v',        (char const   )'e',        (char const   )'r',        (char const   )'s', 
            (char const   )'e',        (char const   )' ',        (char const   )'o',        (char const   )'r', 
            (char const   )'d',        (char const   )'e',        (char const   )'r',        (char const   )' ', 
            (char const   )'a',        (char const   )'f',        (char const   )'t',        (char const   )'e', 
            (char const   )'r',        (char const   )' ',        (char const   )'m',        (char const   )'a', 
            (char const   )'i',        (char const   )'n',        (char const   )' ',        (char const   )'w', 
            (char const   )'r',        (char const   )'i',        (char const   )'t',        (char const   )'e', 
            (char const   )' ',        (char const   )'l',        (char const   )'o',        (char const   )'o', 
            (char const   )'p',        (char const   )'.',        (char const   )'\000'}, 
   {        (char const   )'S',        (char const   )'Y',        (char const   )'N',        (char const   )'C', 
            (char const   )' ',        (char const   )'P',        (char const   )'O',        (char const   )'S', 
            (char const   )'T',        (char const   )' ',        (char const   )'R',        (char const   )'E', 
            (char const   )'V',        (char const   )'E',        (char const   )'R',        (char const   )'S', 
            (char const   )'E',        (char const   )':',        (char const   )' ',        (char const   )'I', 
            (char const   )'s',        (char const   )'s',        (char const   )'u',        (char const   )'e', 
            (char const   )' ',        (char const   )'s',        (char const   )'y',        (char const   )'n', 
            (char const   )'c',        (char const   )'(',        (char const   )')',        (char const   )' ', 
            (char const   )'a',        (char const   )'n',        (char const   )'d',        (char const   )' ', 
            (char const   )'t',        (char const   )'h',        (char const   )'e',        (char const   )'n', 
            (char const   )' ',        (char const   )'r',        (char const   )'e',        (char const   )'o', 
            (char const   )'p',        (char const   )'e',        (char const   )'n',        (char const   )' ', 
            (char const   )'a',        (char const   )'n',        (char const   )'d',        (char const   )' ', 
            (char const   )'f',        (char const   )'s',        (char const   )'y',        (char const   )'n', 
            (char const   )'c',        (char const   )'(',        (char const   )')',        (char const   )' ', 
            (char const   )'e',        (char const   )'a',        (char const   )'c',        (char const   )'h', 
            (char const   )' ',        (char const   )'f',        (char const   )'i',        (char const   )'l', 
            (char const   )'e',        (char const   )' ',        (char const   )'i',        (char const   )'n', 
            (char const   )' ',        (char const   )'r',        (char const   )'e',        (char const   )'v', 
            (char const   )'e',        (char const   )'r',        (char const   )'s',        (char const   )'e', 
            (char const   )' ',        (char const   )'o',        (char const   )'r',        (char const   )'d', 
            (char const   )'e',        (char const   )'r',        (char const   )' ',        (char const   )'a', 
            (char const   )'f',        (char const   )'t',        (char const   )'e',        (char const   )'r', 
            (char const   )' ',        (char const   )'m',        (char const   )'a',        (char const   )'i', 
            (char const   )'n',        (char const   )' ',        (char const   )'w',        (char const   )'r', 
            (char const   )'i',        (char const   )'t',        (char const   )'e',        (char const   )' ', 
            (char const   )'l',        (char const   )'o',        (char const   )'o',        (char const   )'p', 
            (char const   )'.',        (char const   )'\000'}, 
   {        (char const   )'P',        (char const   )'O',        (char const   )'S',        (char const   )'T', 
            (char const   )':',        (char const   )' ',        (char const   )'R',        (char const   )'e', 
            (char const   )'o',        (char const   )'p',        (char const   )'e',        (char const   )'n', 
            (char const   )' ',        (char const   )'a',        (char const   )'n',        (char const   )'d', 
            (char const   )' ',        (char const   )'f',        (char const   )'s',        (char const   )'y', 
            (char const   )'n',        (char const   )'c',        (char const   )'(',        (char const   )')', 
            (char const   )' ',        (char const   )'e',        (char const   )'a',        (char const   )'c', 
            (char const   )'h',        (char const   )' ',        (char const   )'f',        (char const   )'i', 
            (char const   )'l',        (char const   )'e',        (char const   )' ',        (char const   )'i', 
            (char const   )'n',        (char const   )' ',        (char const   )'o',        (char const   )'r', 
            (char const   )'d',        (char const   )'e',        (char const   )'r',        (char const   )' ', 
            (char const   )'a',        (char const   )'f',        (char const   )'t',        (char const   )'e', 
            (char const   )'r',        (char const   )' ',        (char const   )'m',        (char const   )'a', 
            (char const   )'i',        (char const   )'n',        (char const   )' ',        (char const   )'w', 
            (char const   )'r',        (char const   )'i',        (char const   )'t',        (char const   )'e', 
            (char const   )' ',        (char const   )'l',        (char const   )'o',        (char const   )'o', 
            (char const   )'p',        (char const   )'.',        (char const   )'\000'}, 
   {        (char const   )'S',        (char const   )'Y',        (char const   )'N',        (char const   )'C', 
            (char const   )' ',        (char const   )'P',        (char const   )'O',        (char const   )'S', 
            (char const   )'T',        (char const   )':',        (char const   )' ',        (char const   )'I', 
            (char const   )'s',        (char const   )'s',        (char const   )'u',        (char const   )'e', 
            (char const   )' ',        (char const   )'s',        (char const   )'y',        (char const   )'n', 
            (char const   )'c',        (char const   )'(',        (char const   )')',        (char const   )' ', 
            (char const   )'a',        (char const   )'n',        (char const   )'d',        (char const   )' ', 
            (char const   )'t',        (char const   )'h',        (char const   )'e',        (char const   )'n', 
            (char const   )' ',        (char const   )'r',        (char const   )'e',        (char const   )'o', 
            (char const   )'p',        (char const   )'e',        (char const   )'n',        (char const   )' ', 
            (char const   )'a',        (char const   )'n',        (char const   )'d',        (char const   )' ', 
            (char const   )'f',        (char const   )'s',        (char const   )'y',        (char const   )'n', 
            (char const   )'c',        (char const   )'(',        (char const   )')',        (char const   )' ', 
            (char const   )'e',        (char const   )'a',        (char const   )'c',        (char const   )'h', 
            (char const   )' ',        (char const   )'f',        (char const   )'i',        (char const   )'l', 
            (char const   )'e',        (char const   )' ',        (char const   )'i',        (char const   )'n', 
            (char const   )' ',        (char const   )'o',        (char const   )'r',        (char const   )'d', 
            (char const   )'e',        (char const   )'r',        (char const   )' ',        (char const   )'a', 
            (char const   )'f',        (char const   )'t',        (char const   )'e',        (char const   )'r', 
            (char const   )' ',        (char const   )'m',        (char const   )'a',        (char const   )'i', 
            (char const   )'n',        (char const   )' ',        (char const   )'w',        (char const   )'r', 
            (char const   )'i',        (char const   )'t',        (char const   )'e',        (char const   )' ', 
            (char const   )'l',        (char const   )'o',        (char const   )'o',        (char const   )'p', 
            (char const   )'.',        (char const   )'\000'}};
#line 98 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
int sync_method  =    1;
#line 99 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
int sync_method_type  =    1;
#line 104 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
int io_buffer_size  =    16384;
#line 105 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
unsigned int file_size  =    51200U;
#line 106 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
int num_files  =    1000;
#line 107 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
int name_len  =    40;
#line 108 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
int rand_len  =    24;
#line 113 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
int num_subdirs  =    0;
#line 114 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
int num_per_subdir  =    0;
#line 115 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
int num_dirs  =    0;
#line 116 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
int files_in_subdir  =    0;
#line 117 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
int current_subdir  =    0;
#line 118 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
unsigned long secs_per_directory  =    180UL;
#line 124 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
int keep_files  =    0;
#line 125 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
int num_threads  =    1;
#line 126 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
int do_fill_fs  =    0;
#line 127 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
int verbose_stats  =    0;
#line 128 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
char log_file_name[4096]  = 
#line 128
  {      (char )'f',      (char )'s',      (char )'_',      (char )'l', 
        (char )'o',      (char )'g',      (char )'.',      (char )'t', 
        (char )'x',      (char )'t',      (char )'\000'};
#line 129 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
FILE *log_file_fp  ;
#line 130 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
FILE *child_log_file_fp  ;
#line 132 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
unsigned int loop_count  =    0U;
#line 133 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
unsigned int file_count  =    0U;
#line 134 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
unsigned long long start_sec_time  =    0ULL;
#line 136 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
static char io_buffer[1048576]  ;
#line 144 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
struct name_entry *names  =    (struct name_entry *)((void *)0);
#line 146 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
static char rand_name[128]  ;
#line 147 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
static char seq_name[128]  ;
#line 209 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.h"
child_job_t child_tasks[64]  ;
#line 214
void start(struct timeval *tv ) ;
#line 215
unsigned long long stop(struct timeval *begin , struct timeval *end ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
void cleanup_exit(void) 
{ 
  char child_log_file_name[4096] ;
  __pid_t tmp ;

  {
  {
#line 55
  tmp = getpid();
#line 55
  sprintf((char */* __restrict  */)(child_log_file_name), (char const   */* __restrict  */)"%s.%d",
          log_file_name, tmp);
#line 56
  unlink((char const   *)(child_log_file_name));
#line 58
  exit(1);
  }
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
void usage(void) 
{ 


  {
  {
#line 63
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: fs_mark\n%s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s",
          "\t-h <print usage and exit>\n", "\t-k <keep files after each iteration>\n",
          "\t-F <run until FS full>\n", "\t-S Sync Method (0:No Sync, 1:fsyncBeforeClose, 2:sync/1_fsync, 3:PostReverseFsync, 4:syncPostReverseFsync, 5:PostFsync, 6:syncPostFsync)\n",
          "\t[-D number (of subdirectories)]\n", "\t[-N number (of files in each subdirectory in Round Robin mode)]\n",
          "\t[-d dir1 ... -d dirN]\n", "\t[-l log_file_name]\n", "\t[-l log_file_name]\n",
          "\t[-L number (of iterations)]\n", "\t[-n number (of files per iteration)]\n",
          "\t[-p number (of total bytes file names)]\n", "\t[-r number (of random bytes in file names)]\n",
          "\t[-s byte_count (size in bytes of each file)]\n", "\t[-t number (of total threads)]\n",
          "\t[-w number (of bytes per write() syscall)]\n");
#line 82
  cleanup_exit();
  }
#line 83
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
void process_args(int argc , char **argv , char **envp ) 
{ 
  int ret ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int threads_per_dir ;
  int i ;
  int j ;

  {
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 96
    ret = getopt(argc, (char * const  *)argv, "vhkFr:S:N:D:d:l:L:n:p:s:t:w:");
    }
#line 96
    if (! (ret != -1)) {
#line 96
      goto while_break;
    }
    {
#line 99
    if (ret == 118) {
#line 99
      goto case_118;
    }
#line 103
    if (ret == 68) {
#line 103
      goto case_68;
    }
#line 117
    if (ret == 100) {
#line 117
      goto case_100;
    }
#line 135
    if (ret == 70) {
#line 135
      goto case_70;
    }
#line 140
    if (ret == 107) {
#line 140
      goto case_107;
    }
#line 144
    if (ret == 108) {
#line 144
      goto case_108;
    }
#line 148
    if (ret == 76) {
#line 148
      goto case_76;
    }
#line 153
    if (ret == 110) {
#line 153
      goto case_110;
    }
#line 161
    if (ret == 78) {
#line 161
      goto case_78;
    }
#line 166
    if (ret == 112) {
#line 166
      goto case_112;
    }
#line 175
    if (ret == 115) {
#line 175
      goto case_115;
    }
#line 179
    if (ret == 114) {
#line 179
      goto case_114;
    }
#line 183
    if (ret == 83) {
#line 183
      goto case_83;
    }
#line 215
    if (ret == 116) {
#line 215
      goto case_116;
    }
#line 224
    if (ret == 119) {
#line 224
      goto case_119;
    }
#line 233
    if (ret == 104) {
#line 233
      goto case_104;
    }
#line 237
    goto switch_default___0;
    case_118: /* CIL Label */ 
#line 100
    verbose_stats = 1;
#line 101
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 104
    num_subdirs = atoi((char const   *)optarg);
    }
#line 105
    if (num_subdirs < 2) {
      {
#line 106
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Number of subdirs needs to be greater than 1\n");
#line 108
      usage();
      }
    }
#line 113
    if (dir_policy == 0) {
#line 114
      dir_policy = 2;
    }
#line 115
    goto switch_break;
    case_100: /* CIL Label */ 
#line 118
    if (num_dirs > 64) {
      {
#line 119
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Max number of threads (and directories) is %d\n",
              64);
#line 122
      usage();
      }
    }
    {
#line 124
    tmp = strlen((char const   *)optarg);
    }
#line 124
    if (tmp >= 40UL) {
      {
#line 125
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fs_mark: %s directory pathname too long (must be less than %d bytes)\n",
              optarg, 40);
#line 128
      usage();
      }
    }
    {
#line 130
    strncpy((char */* __restrict  */)(child_tasks[num_dirs].test_dir), (char const   */* __restrict  */)optarg,
            (size_t )4096);
#line 132
    num_dirs ++;
    }
#line 133
    goto switch_break;
    case_70: /* CIL Label */ 
#line 136
    keep_files = 1;
#line 137
    do_fill_fs = 1;
#line 138
    goto switch_break;
    case_107: /* CIL Label */ 
#line 141
    keep_files = 1;
#line 142
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 145
    strncpy((char */* __restrict  */)(log_file_name), (char const   */* __restrict  */)optarg,
            (size_t )4096);
    }
#line 146
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 149
    tmp___0 = atoi((char const   *)optarg);
#line 149
    loop_count = (unsigned int )tmp___0;
#line 150
    keep_files = 1;
    }
#line 151
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 154
    num_files = atoi((char const   *)optarg);
    }
#line 155
    if (num_files > 1000000) {
      {
#line 156
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Max files is %d\n",
              1000000);
#line 157
      usage();
      }
    }
#line 159
    goto switch_break;
    case_78: /* CIL Label */ 
    {
#line 162
    dir_policy = 1;
#line 163
    num_per_subdir = atoi((char const   *)optarg);
    }
#line 164
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 167
    name_len = atoi((char const   *)optarg);
    }
#line 168
    if (name_len > 128) {
      {
#line 169
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Max filename size is %d\n",
              128);
#line 171
      usage();
      }
    }
#line 173
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 176
    tmp___1 = atoi((char const   *)optarg);
#line 176
    file_size = (unsigned int )tmp___1;
    }
#line 177
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 180
    rand_len = atoi((char const   *)optarg);
    }
#line 181
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 184
    sync_method_type = atoi((char const   *)optarg);
    }
    {
#line 186
    if (sync_method_type == 0) {
#line 186
      goto case_0;
    }
#line 189
    if (sync_method_type == 1) {
#line 189
      goto case_1;
    }
#line 192
    if (sync_method_type == 2) {
#line 192
      goto case_2;
    }
#line 195
    if (sync_method_type == 3) {
#line 195
      goto case_3;
    }
#line 198
    if (sync_method_type == 4) {
#line 198
      goto case_4;
    }
#line 201
    if (sync_method_type == 5) {
#line 201
      goto case_5;
    }
#line 204
    if (sync_method_type == 6) {
#line 204
      goto case_6;
    }
#line 208
    goto switch_default;
    case_0: /* CIL Label */ 
#line 187
    sync_method = 0;
#line 188
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 190
    sync_method = 1;
#line 191
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 193
    sync_method = 6;
#line 194
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 196
    sync_method = 8;
#line 197
    goto switch_break___0;
    case_4: /* CIL Label */ 
#line 199
    sync_method = 10;
#line 200
    goto switch_break___0;
    case_5: /* CIL Label */ 
#line 202
    sync_method = 16;
#line 203
    goto switch_break___0;
    case_6: /* CIL Label */ 
#line 205
    sync_method = 18;
#line 206
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 209
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Max filename size is %d\n",
            128);
#line 211
    usage();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 213
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 216
    num_threads = atoi((char const   *)optarg);
    }
#line 217
    if (num_threads > 64) {
      {
#line 218
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Max threads is %d\n",
              64);
#line 220
      usage();
      }
    }
#line 222
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 225
    io_buffer_size = atoi((char const   *)optarg);
    }
#line 226
    if (io_buffer_size > 1048576) {
      {
#line 227
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MAX IO buffer size is %d\n",
              1048576);
#line 229
      usage();
      }
    }
#line 231
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 234
    usage();
    }
#line 235
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 238
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  if (num_dirs == 0) {
    {
#line 243
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Must specify at least one directory with -d switch\n");
#line 245
    usage();
    }
  }
#line 247
  if (num_subdirs == 0) {
#line 247
    if (num_per_subdir > 0) {
      {
#line 248
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Must specify at more than 1 subdirectory with -D switch for -N num_per_subdir to make sense\n");
#line 251
      usage();
      }
    }
  }
#line 260
  if (num_dirs > num_threads) {
#line 261
    num_threads = num_dirs;
  } else {
#line 265
    threads_per_dir = num_threads / num_dirs;
#line 266
    if (num_dirs * threads_per_dir != num_threads) {
      {
#line 268
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Threads (%d) must be an even multiple the number of directories (%d) and less than %d \n",
              num_threads, num_dirs, 64);
#line 272
      usage();
      }
    } else
#line 266
    if (num_dirs * threads_per_dir > 64) {
      {
#line 268
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Threads (%d) must be an even multiple the number of directories (%d) and less than %d \n",
              num_threads, num_dirs, 64);
#line 272
      usage();
      }
    }
#line 274
    i = 0;
    {
#line 274
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 274
      if (! (i < num_dirs)) {
#line 274
        goto while_break___0;
      }
#line 275
      j = 1;
      {
#line 275
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 275
        if (! (j < threads_per_dir)) {
#line 275
          goto while_break___1;
        }
        {
#line 276
        strncpy((char */* __restrict  */)(child_tasks[i + j * num_dirs].test_dir),
                (char const   */* __restrict  */)(child_tasks[i].test_dir), (size_t )4096);
#line 275
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 274
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 281
  return;
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
char *find_dir_name(int pid ) 
{ 
  int num_dir ;

  {
#line 291
  num_dir = 0;
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if (! (num_dir < 64)) {
#line 291
      goto while_break;
    }
#line 292
    if (child_tasks[num_dir].child_pid == pid) {
#line 293
      goto while_break;
    }
#line 291
    num_dir ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  return (child_tasks[num_dir].test_dir);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
void setup_file_name(int file_index , pid_t my_pid ) 
{ 
  int seq_len ;
  int j ;
  int pad ;
  int skip ;
  unsigned long sec_time ;
  char *my_dir ;
  char subdir_name[40] ;
  struct timeval now ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  long val ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 308
  my_dir = find_dir_name(my_pid);
#line 315
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((struct timezone *)0));
#line 316
  sec_time = (unsigned long )now.tv_sec;
  }
#line 322
  if (start_sec_time == 0ULL) {
#line 323
    start_sec_time = (unsigned long long )sec_time;
  }
#line 331
  seq_len = name_len - rand_len;
#line 333
  if ((unsigned long )names == (unsigned long )((void *)0)) {
    {
#line 334
    tmp___1 = calloc(sizeof(struct name_entry ), (size_t )num_files);
#line 334
    names = (struct name_entry *)tmp___1;
    }
#line 334
    if ((unsigned long )names == (unsigned long )((void *)0)) {
      {
#line 336
      tmp = __errno_location();
#line 336
      tmp___0 = strerror(*tmp);
#line 336
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fs_mark: failed to allocate memory for file names: %s\n",
              tmp___0);
#line 339
      cleanup_exit();
      }
    }
  }
  {
#line 348
  if (dir_policy == 0) {
#line 348
    goto case_0;
  }
#line 352
  if (dir_policy == 1) {
#line 352
    goto case_1;
  }
#line 368
  if (dir_policy == 2) {
#line 368
    goto case_2;
  }
#line 376
  goto switch_default;
  case_0: /* CIL Label */ 
#line 349
  subdir_name[0] = (char)0;
#line 350
  goto switch_break;
  case_1: /* CIL Label */ 
#line 353
  if (num_per_subdir) {
#line 358
    if (files_in_subdir >= num_per_subdir) {
#line 359
      current_subdir ++;
#line 360
      files_in_subdir = 0;
    }
#line 362
    current_subdir %= num_subdirs;
#line 363
    files_in_subdir ++;
  }
  {
#line 365
  sprintf((char */* __restrict  */)(subdir_name), (char const   */* __restrict  */)"%02x",
          current_subdir);
  }
#line 366
  goto switch_break;
  case_2: /* CIL Label */ 
#line 369
  if ((unsigned long long )sec_time - start_sec_time > (unsigned long long )secs_per_directory) {
#line 370
    current_subdir = (current_subdir + 1) % num_subdirs;
#line 371
    start_sec_time = (unsigned long long )sec_time;
  }
  {
#line 373
  sprintf((char */* __restrict  */)(subdir_name), (char const   */* __restrict  */)"%02x",
          current_subdir);
  }
#line 374
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 377
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fs_mark: invalid directory policy\n");
#line 378
  exit(1);
  }
#line 379
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 382
  sprintf((char */* __restrict  */)((names + file_index)->target_dir), (char const   */* __restrict  */)"%s/%s",
          my_dir, subdir_name);
#line 387
  tmp___4 = mkdir((char const   *)((names + file_index)->target_dir), (__mode_t )511);
  }
#line 387
  if (tmp___4 != 0) {
    {
#line 387
    tmp___5 = __errno_location();
    }
#line 387
    if (*tmp___5 != 17) {
      {
#line 389
      tmp___2 = __errno_location();
#line 389
      tmp___3 = strerror(*tmp___2);
#line 389
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fs_mark: mkdir %s failed: %s\n",
              (names + file_index)->target_dir, tmp___3);
#line 391
      cleanup_exit();
      }
    }
  }
  {
#line 394
  sprintf((char */* __restrict  */)((names + file_index)->write_dir), (char const   */* __restrict  */)"%s",
          (names + file_index)->target_dir);
#line 399
  sprintf((char */* __restrict  */)(seq_name), (char const   */* __restrict  */)"%lx",
          sec_time);
#line 404
  j = 0;
  }
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 404
    if (! (j < rand_len)) {
#line 404
      goto while_break;
    }
    {
#line 408
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 411
      val = random();
#line 412
      rand_name[j] = (char )(48L + (val & 127L));
#line 408
      tmp___6 = __ctype_b_loc();
      }
#line 408
      if ((int const   )*(*tmp___6 + (int )rand_name[j]) & 256) {
#line 408
        goto while_break___0;
      } else {
        {
#line 408
        tmp___7 = __ctype_b_loc();
        }
#line 408
        if ((int const   )*(*tmp___7 + (int )rand_name[j]) & 2048) {
#line 408
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 404
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 415
  rand_name[rand_len] = (char)0;
#line 422
  tmp___8 = strlen((char const   *)(seq_name));
#line 422
  skip = (int )(tmp___8 - (size_t )seq_len);
  }
#line 423
  if (skip > 0) {
    {
#line 424
    strncat((char */* __restrict  */)((names + file_index)->f_name), (char const   */* __restrict  */)(& seq_name[skip]),
            (size_t )seq_len);
    }
  } else {
    {
#line 426
    strncat((char */* __restrict  */)((names + file_index)->f_name), (char const   */* __restrict  */)(seq_name),
            (size_t )seq_len);
    }
  }
  {
#line 428
  tmp___9 = strlen((char const   *)(seq_name));
#line 428
  pad = (int )((size_t )seq_len - tmp___9);
#line 429
  j = 0;
  }
  {
#line 429
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 429
    if (! (j < pad)) {
#line 429
      goto while_break___1;
    }
    {
#line 430
    strcat((char */* __restrict  */)((names + file_index)->f_name), (char const   */* __restrict  */)"~");
#line 429
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 431
  strncat((char */* __restrict  */)((names + file_index)->f_name), (char const   */* __restrict  */)(rand_name),
          (size_t )rand_len);
  }
#line 433
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
void setup(pid_t pid ) 
{ 
  char thread_log_file_name[4096] ;
  char *my_dir ;
  struct timeval now ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 448
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((struct timezone *)0));
#line 449
  srandom((unsigned int )now.tv_usec);
  }
#line 451
  if (num_subdirs > 0) {
#line 457
    current_subdir = (int )(now.tv_sec % (long )num_subdirs);
  }
  {
#line 463
  sprintf((char */* __restrict  */)(thread_log_file_name), (char const   */* __restrict  */)"%s.%d",
          log_file_name, pid);
#line 464
  child_log_file_fp = fopen((char const   */* __restrict  */)(thread_log_file_name),
                            (char const   */* __restrict  */)"w");
  }
#line 464
  if ((unsigned long )child_log_file_fp == (unsigned long )((void *)0)) {
    {
#line 465
    tmp = __errno_location();
#line 465
    tmp___0 = strerror(*tmp);
#line 465
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fs_mark:  setup failed to fopen log file: %s %s\n",
            thread_log_file_name, tmp___0);
#line 468
    cleanup_exit();
    }
  }
  {
#line 474
  memset((void *)(io_buffer), 0, (size_t )io_buffer_size);
#line 479
  my_dir = find_dir_name(pid);
#line 481
  tmp___3 = mkdir((char const   *)my_dir, (__mode_t )511);
  }
#line 481
  if (tmp___3 != 0) {
    {
#line 481
    tmp___4 = __errno_location();
    }
#line 481
    if (*tmp___4 != 17) {
      {
#line 482
      tmp___1 = __errno_location();
#line 482
      tmp___2 = strerror(*tmp___1);
#line 482
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fill_dir:mkdir %s failed: %s\n",
              my_dir, tmp___2);
#line 485
      cleanup_exit();
      }
    }
  }
#line 488
  return;
}
}
#line 494 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
int get_df_full(char *dir_name ) 
{ 
  struct statfs fs_buf ;
  float df_used ;
  float used_blocks ;
  int df_percent_used ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 500
  tmp___1 = statfs((char const   *)dir_name, & fs_buf);
  }
#line 500
  if (tmp___1 == -1) {
    {
#line 501
    tmp = __errno_location();
#line 501
    tmp___0 = strerror(*tmp);
#line 501
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fs_mark: statfs failed on %s %s\n",
            dir_name, tmp___0);
#line 503
    cleanup_exit();
    }
  }
#line 506
  used_blocks = (float )(fs_buf.f_blocks - fs_buf.f_bavail);
#line 508
  df_used = used_blocks / (float )fs_buf.f_blocks;
#line 510
  df_percent_used = (int )((float )100 * df_used);
#line 512
  return (df_percent_used);
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
unsigned long long get_bytes_free(char *dir_name ) 
{ 
  struct statfs fs_buf ;
  unsigned long long bytes_free ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 523
  tmp___1 = statfs((char const   *)dir_name, & fs_buf);
  }
#line 523
  if (tmp___1 == -1) {
    {
#line 524
    tmp = __errno_location();
#line 524
    tmp___0 = strerror(*tmp);
#line 524
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fs_mark: statfs failed on %s %s\n",
            dir_name, tmp___0);
#line 526
    cleanup_exit();
    }
  }
#line 529
  bytes_free = (unsigned long long )fs_buf.f_bavail;
#line 530
  bytes_free *= (unsigned long long )fs_buf.f_bsize;
#line 532
  return (bytes_free);
}
}
#line 540 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
void write_file(int fd , int sz , unsigned long long *avg_write_usec , unsigned long long *total_write_usec ,
                unsigned long long *min_write_usec , unsigned long long *max_write_usec ) 
{ 
  int ret ;
  int sz_left ;
  int write_size ;
  int write_calls ;
  unsigned long long local_write_usec ;
  unsigned long long delta ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 547
  ret = 0;
#line 552
  write_calls = 0;
#line 553
  write_size = io_buffer_size;
#line 554
  sz_left = sz;
#line 555
  local_write_usec = 0ULL;
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 558
    if (write_size > sz_left) {
#line 559
      write_size = sz_left;
    }
    {
#line 561
    start((struct timeval *)0);
#line 562
    tmp___1 = write(fd, (void const   *)(io_buffer), (size_t )write_size);
#line 562
    ret = (int )tmp___1;
    }
#line 562
    if (ret != write_size) {
      {
#line 563
      tmp = __errno_location();
#line 563
      tmp___0 = strerror(*tmp);
#line 563
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fs_mark: write_file write failed: %d %s\n",
              ret, tmp___0);
#line 566
      cleanup_exit();
      }
    }
    {
#line 568
    delta = stop((struct timeval *)0, (struct timeval *)0);
#line 570
    local_write_usec += delta;
    }
#line 572
    if (delta > *max_write_usec) {
#line 573
      *max_write_usec = delta;
    }
#line 575
    if (*min_write_usec == 0ULL) {
#line 576
      *min_write_usec = delta;
    } else
#line 575
    if (delta < *min_write_usec) {
#line 576
      *min_write_usec = delta;
    }
#line 578
    sz_left -= ret;
#line 579
    write_calls ++;
#line 557
    if (! (sz_left > 0)) {
#line 557
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 582
  *avg_write_usec += local_write_usec / (unsigned long long )write_calls;
#line 583
  *total_write_usec += local_write_usec;
#line 585
  return;
}
}
#line 591 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
static void check_space(pid_t my_pid ) 
{ 
  char *my_dir_name ;
  unsigned long long bytes_per_loop ;
  unsigned long long tmp ;

  {
  {
#line 596
  my_dir_name = find_dir_name(my_pid);
#line 602
  bytes_per_loop = (unsigned long long )file_size * (unsigned long long )num_files;
#line 603
  tmp = get_bytes_free(my_dir_name);
  }
#line 603
  if (tmp < bytes_per_loop) {
    {
#line 604
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Insufficient free space in %s to create %d new files, exiting\n",
            my_dir_name, num_files);
#line 607
    do_fill_fs = 0;
#line 608
    cleanup_exit();
    }
  }
#line 611
  return;
}
}
#line 619 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
static struct timeval loop_start_tv  ;
#line 619 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
static struct timeval loop_stop_tv  ;
#line 621 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
void do_run(pid_t my_pid ) 
{ 
  int file_index ;
  int fd ;
  float files_per_sec ;
  unsigned long long total_file_ops ;
  unsigned long long delta ;
  unsigned long long loop_usecs ;
  unsigned long long creat_usec ;
  unsigned long long max_creat_usec ;
  unsigned long long min_creat_usec ;
  unsigned long long avg_write_usec ;
  unsigned long long max_write_usec ;
  unsigned long long min_write_usec ;
  unsigned long long total_write_usec ;
  unsigned long long fsync_usec ;
  unsigned long long max_fsync_usec ;
  unsigned long long min_fsync_usec ;
  unsigned long long close_usec ;
  unsigned long long max_close_usec ;
  unsigned long long min_close_usec ;
  unsigned long long unlink_usec ;
  unsigned long long max_unlink_usec ;
  unsigned long long min_unlink_usec ;
  unsigned long long avg_sync_usec ;
  unsigned long long app_overhead_usec ;
  char file_write_name[168] ;
  char file_target_name[168] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int fd___0 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int fd___1 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int fd___2 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  unsigned long long tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;

  {
  {
#line 639
  check_space(my_pid);
#line 646
  files_per_sec = (float )0.0;
#line 647
  min_creat_usec = 0ULL;
#line 647
  max_creat_usec = min_creat_usec;
#line 647
  creat_usec = max_creat_usec;
#line 648
  total_write_usec = 0ULL;
#line 648
  min_write_usec = total_write_usec;
#line 648
  max_write_usec = min_write_usec;
#line 648
  avg_write_usec = max_write_usec;
#line 649
  avg_sync_usec = 0ULL;
#line 649
  min_fsync_usec = avg_sync_usec;
#line 649
  max_fsync_usec = min_fsync_usec;
#line 649
  fsync_usec = max_fsync_usec;
#line 650
  min_close_usec = 0ULL;
#line 650
  max_close_usec = min_close_usec;
#line 650
  close_usec = max_close_usec;
#line 651
  min_unlink_usec = 0ULL;
#line 651
  max_unlink_usec = min_unlink_usec;
#line 651
  unlink_usec = max_unlink_usec;
#line 663
  start(& loop_start_tv);
#line 664
  file_index = 0;
  }
  {
#line 664
  while (1) {
    while_continue: /* CIL Label */ ;
#line 664
    if (! (file_index < num_files)) {
#line 664
      goto while_break;
    }
    {
#line 672
    setup_file_name(file_index, my_pid);
#line 677
    sprintf((char */* __restrict  */)(file_write_name), (char const   */* __restrict  */)"%s/%s",
            (names + file_index)->write_dir, (names + file_index)->f_name);
#line 679
    sprintf((char */* __restrict  */)(file_target_name), (char const   */* __restrict  */)"%s/%s",
            (names + file_index)->target_dir, (names + file_index)->f_name);
#line 682
    start((struct timeval *)0);
#line 683
    fd = open((char const   *)(file_write_name), 578, 438);
    }
#line 683
    if (fd == -1) {
      {
#line 686
      tmp = __errno_location();
#line 686
      tmp___0 = strerror(*tmp);
#line 686
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in creat: %s\n",
              tmp___0);
#line 688
      cleanup_exit();
      }
    }
    {
#line 690
    delta = stop((struct timeval *)0, (struct timeval *)0);
#line 691
    creat_usec += delta;
    }
#line 693
    if (delta > max_creat_usec) {
#line 694
      max_creat_usec = delta;
    }
#line 696
    if (min_creat_usec == 0ULL) {
#line 697
      min_creat_usec = delta;
    } else
#line 696
    if (delta < min_creat_usec) {
#line 697
      min_creat_usec = delta;
    }
    {
#line 706
    write_file(fd, (int )file_size, & avg_write_usec, & total_write_usec, & min_write_usec,
               & max_write_usec);
    }
#line 714
    if (sync_method & 1) {
      {
#line 715
      start((struct timeval *)0);
#line 717
      tmp___3 = fsync(fd);
      }
#line 717
      if (tmp___3 == -1) {
        {
#line 718
        tmp___1 = __errno_location();
#line 718
        tmp___2 = strerror(*tmp___1);
#line 718
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fs_mark: fsync failed %s\n",
                tmp___2);
#line 720
        cleanup_exit();
        }
      }
      {
#line 722
      delta = stop((struct timeval *)0, (struct timeval *)0);
#line 723
      fsync_usec += delta;
      }
#line 725
      if (delta > max_fsync_usec) {
#line 726
        max_fsync_usec = delta;
      }
#line 727
      if (min_fsync_usec == 0ULL) {
#line 728
        min_fsync_usec = delta;
      } else
#line 727
      if (delta < min_fsync_usec) {
#line 728
        min_fsync_usec = delta;
      }
    }
    {
#line 734
    start((struct timeval *)0);
#line 735
    close(fd);
#line 736
    delta = stop((struct timeval *)0, (struct timeval *)0);
#line 738
    close_usec += delta;
    }
#line 739
    if (delta > max_close_usec) {
#line 740
      max_close_usec = delta;
    }
#line 742
    if (min_close_usec == 0ULL) {
#line 743
      min_close_usec = delta;
    } else
#line 742
    if (delta < min_close_usec) {
#line 743
      min_close_usec = delta;
    }
#line 664
    file_index ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 747
  if (sync_method & 2) {
    {
#line 748
    start((struct timeval *)0);
#line 749
    sync();
#line 750
    delta = stop((struct timeval *)0, (struct timeval *)0);
#line 755
    avg_sync_usec = delta;
    }
  }
#line 763
  if (sync_method & 16) {
#line 764
    file_index = 0;
    {
#line 764
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 764
      if (! (file_index < num_files)) {
#line 764
        goto while_break___0;
      }
      {
#line 767
      sprintf((char */* __restrict  */)(file_target_name), (char const   */* __restrict  */)"%s/%s",
              (names + file_index)->target_dir, (names + file_index)->f_name);
#line 771
      start((struct timeval *)0);
#line 772
      fd___0 = open((char const   *)(file_target_name), 0, 438);
      }
#line 772
      if (fd___0 == -1) {
        {
#line 773
        tmp___4 = __errno_location();
#line 773
        tmp___5 = strerror(*tmp___4);
#line 773
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in open of %s : %s\n",
                file_target_name, tmp___5);
#line 775
        cleanup_exit();
        }
      }
      {
#line 778
      tmp___8 = fsync(fd___0);
      }
#line 778
      if (tmp___8 == -1) {
        {
#line 779
        tmp___6 = __errno_location();
#line 779
        tmp___7 = strerror(*tmp___6);
#line 779
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fs_mark: fsync failed %s\n",
                tmp___7);
#line 781
        cleanup_exit();
        }
      }
      {
#line 784
      close(fd___0);
#line 785
      delta = stop((struct timeval *)0, (struct timeval *)0);
#line 786
      fsync_usec += delta;
      }
#line 788
      if (delta > max_fsync_usec) {
#line 789
        max_fsync_usec = delta;
      }
#line 790
      if (min_fsync_usec == 0ULL) {
#line 791
        min_fsync_usec = delta;
      } else
#line 790
      if (delta < min_fsync_usec) {
#line 791
        min_fsync_usec = delta;
      }
#line 764
      file_index ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 800
  if (sync_method & 8) {
#line 801
    file_index = num_files - 1;
    {
#line 801
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 801
      if (! (file_index >= 0)) {
#line 801
        goto while_break___1;
      }
      {
#line 805
      sprintf((char */* __restrict  */)(file_target_name), (char const   */* __restrict  */)"%s/%s",
              (names + file_index)->target_dir, (names + file_index)->f_name);
#line 809
      start((struct timeval *)0);
#line 810
      fd___1 = open((char const   *)(file_target_name), 0, 438);
      }
#line 810
      if (fd___1 == -1) {
        {
#line 811
        tmp___9 = __errno_location();
#line 811
        tmp___10 = strerror(*tmp___9);
#line 811
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in open of %s : %s\n",
                file_target_name, tmp___10);
#line 813
        cleanup_exit();
        }
      }
      {
#line 816
      tmp___13 = fsync(fd___1);
      }
#line 816
      if (tmp___13 == -1) {
        {
#line 817
        tmp___11 = __errno_location();
#line 817
        tmp___12 = strerror(*tmp___11);
#line 817
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fs_mark: fsync failed %s\n",
                tmp___12);
#line 819
        cleanup_exit();
        }
      }
      {
#line 822
      close(fd___1);
#line 823
      delta = stop((struct timeval *)0, (struct timeval *)0);
#line 824
      fsync_usec += delta;
      }
#line 826
      if (delta > max_fsync_usec) {
#line 827
        max_fsync_usec = delta;
      }
#line 828
      if (min_fsync_usec == 0ULL) {
#line 829
        min_fsync_usec = delta;
      } else
#line 828
      if (delta < min_fsync_usec) {
#line 829
        min_fsync_usec = delta;
      }
#line 801
      file_index --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 839
  if (sync_method & 4) {
    {
#line 842
    sprintf((char */* __restrict  */)(file_target_name), (char const   */* __restrict  */)"%s/%s",
            (names + 0)->target_dir, (names + 0)->f_name);
#line 845
    start((struct timeval *)0);
#line 846
    fd___2 = open((char const   *)(file_target_name), 0, 438);
    }
#line 846
    if (fd___2 == -1) {
      {
#line 847
      tmp___14 = __errno_location();
#line 847
      tmp___15 = strerror(*tmp___14);
#line 847
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in open of %s : %s\n",
              file_target_name, tmp___15);
#line 849
      cleanup_exit();
      }
    }
    {
#line 852
    tmp___18 = fsync(fd___2);
    }
#line 852
    if (tmp___18 == -1) {
      {
#line 853
      tmp___16 = __errno_location();
#line 853
      tmp___17 = strerror(*tmp___16);
#line 853
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fs_mark: fsync failed %s\n",
              tmp___17);
#line 855
      cleanup_exit();
      }
    }
    {
#line 858
    close(fd___2);
#line 859
    tmp___19 = stop((struct timeval *)0, (struct timeval *)0);
#line 859
    fsync_usec += tmp___19;
    }
  }
  {
#line 865
  loop_usecs = stop(& loop_start_tv, & loop_stop_tv);
  }
#line 870
  if (! keep_files) {
#line 871
    file_index = 0;
    {
#line 871
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 871
      if (! (file_index < num_files)) {
#line 871
        goto while_break___2;
      }
      {
#line 872
      sprintf((char */* __restrict  */)(file_target_name), (char const   */* __restrict  */)"%s/%s",
              (names + file_index)->target_dir, (names + file_index)->f_name);
#line 876
      start((struct timeval *)0);
#line 877
      tmp___22 = unlink((char const   *)(file_target_name));
      }
#line 877
      if (tmp___22 == -1) {
        {
#line 878
        tmp___20 = __errno_location();
#line 878
        tmp___21 = strerror(*tmp___20);
#line 878
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in unlink of %s : %s\n",
                file_target_name, tmp___21);
#line 880
        cleanup_exit();
        }
      }
      {
#line 882
      delta = stop((struct timeval *)0, (struct timeval *)0);
#line 884
      unlink_usec += delta;
      }
#line 885
      if (delta > max_unlink_usec) {
#line 886
        max_unlink_usec = delta;
      }
#line 888
      if (min_unlink_usec == 0ULL) {
#line 889
        min_unlink_usec = delta;
      } else
#line 888
      if (delta < min_unlink_usec) {
#line 889
        min_unlink_usec = delta;
      }
#line 871
      file_index ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 896
  total_file_ops = (((creat_usec + total_write_usec) + fsync_usec) + avg_sync_usec) + close_usec;
#line 899
  app_overhead_usec = loop_usecs - total_file_ops;
#line 905
  file_count += (unsigned int )num_files;
#line 910
  files_per_sec = (float )((double )num_files / ((double )loop_usecs / 1000000.0));
#line 915
  fprintf((FILE */* __restrict  */)child_log_file_fp, (char const   */* __restrict  */)"%u %.1f %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu\n",
          file_count, (double )files_per_sec, app_overhead_usec, min_creat_usec, creat_usec / (unsigned long long )num_files,
          max_creat_usec, min_write_usec, avg_write_usec / (unsigned long long )num_files,
          max_write_usec, min_fsync_usec, fsync_usec / (unsigned long long )num_files,
          max_fsync_usec, avg_sync_usec, min_close_usec, close_usec / (unsigned long long )num_files,
          max_close_usec, min_unlink_usec, unlink_usec / (unsigned long long )num_files,
          max_unlink_usec);
#line 935
  fflush(child_log_file_fp);
  }
#line 937
  return;
}
}
#line 940 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
void process_child_log_file(pid_t child_pid , fs_mark_stat_t *thread_stats ) 
{ 
  char child_log_file_name[4096] ;
  FILE *thread_log_fp ;
  int res ;

  {
  {
#line 949
  sprintf((char */* __restrict  */)(child_log_file_name), (char const   */* __restrict  */)"%s.%d",
          log_file_name, child_pid);
#line 950
  thread_log_fp = fopen((char const   */* __restrict  */)(child_log_file_name), (char const   */* __restrict  */)"r");
  }
#line 950
  if ((unsigned long )thread_log_fp == (unsigned long )((void *)0)) {
    {
#line 951
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fopen failed to open: %s\n",
            child_log_file_name);
#line 953
    cleanup_exit();
    }
  }
  {
#line 956
  res = fscanf((FILE */* __restrict  */)thread_log_fp, (char const   */* __restrict  */)"%u %f %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu",
               & thread_stats->file_count, & thread_stats->files_per_sec, & thread_stats->app_overhead_usec,
               & thread_stats->min_creat_usec, & thread_stats->avg_creat_usec, & thread_stats->max_creat_usec,
               & thread_stats->min_write_usec, & thread_stats->avg_write_usec, & thread_stats->max_write_usec,
               & thread_stats->min_fsync_usec, & thread_stats->avg_fsync_usec, & thread_stats->max_fsync_usec,
               & thread_stats->avg_sync_usec, & thread_stats->min_close_usec, & thread_stats->avg_close_usec,
               & thread_stats->max_close_usec, & thread_stats->min_unlink_usec, & thread_stats->avg_unlink_usec,
               & thread_stats->max_unlink_usec);
  }
#line 956
  if (res != 19) {
    {
#line 977
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fscanf read too few entries from thread log file: %s\n",
            child_log_file_name);
#line 980
    cleanup_exit();
    }
  }
  {
#line 986
  fclose(thread_log_fp);
#line 987
  unlink((char const   *)(child_log_file_name));
  }
#line 989
  return;
}
}
#line 995 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
void aggregate_thread_stats(fs_mark_stat_t *thread_stats , fs_mark_stat_t *iteration_stats ) 
{ 
  int i ;

  {
#line 1000
  i = 0;
  {
#line 1000
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1000
    if (! (i < num_threads)) {
#line 1000
      goto while_break;
    }
    {
#line 1001
    process_child_log_file(child_tasks[i].child_pid, thread_stats);
#line 1006
    iteration_stats->file_count += thread_stats->file_count;
#line 1007
    iteration_stats->files_per_sec += thread_stats->files_per_sec;
#line 1008
    iteration_stats->app_overhead_usec += thread_stats->app_overhead_usec;
#line 1016
    iteration_stats->avg_creat_usec += thread_stats->avg_creat_usec;
    }
#line 1017
    if (iteration_stats->min_creat_usec == 0ULL) {
#line 1020
      iteration_stats->min_creat_usec = thread_stats->min_creat_usec;
    } else
#line 1017
    if (thread_stats->min_creat_usec < iteration_stats->min_creat_usec) {
#line 1020
      iteration_stats->min_creat_usec = thread_stats->min_creat_usec;
    }
#line 1022
    if (thread_stats->max_creat_usec > iteration_stats->max_creat_usec) {
#line 1024
      iteration_stats->max_creat_usec = thread_stats->max_creat_usec;
    }
#line 1027
    iteration_stats->avg_write_usec += thread_stats->avg_write_usec;
#line 1028
    if (iteration_stats->min_write_usec == 0ULL) {
#line 1031
      iteration_stats->min_write_usec = thread_stats->min_write_usec;
    } else
#line 1028
    if (thread_stats->min_write_usec < iteration_stats->min_write_usec) {
#line 1031
      iteration_stats->min_write_usec = thread_stats->min_write_usec;
    }
#line 1033
    if (thread_stats->max_write_usec > iteration_stats->max_write_usec) {
#line 1035
      iteration_stats->max_write_usec = thread_stats->max_write_usec;
    }
#line 1038
    iteration_stats->avg_fsync_usec += thread_stats->avg_fsync_usec;
#line 1039
    if (iteration_stats->min_fsync_usec == 0ULL) {
#line 1042
      iteration_stats->min_fsync_usec = thread_stats->min_fsync_usec;
    } else
#line 1039
    if (thread_stats->min_fsync_usec < iteration_stats->min_fsync_usec) {
#line 1042
      iteration_stats->min_fsync_usec = thread_stats->min_fsync_usec;
    }
#line 1044
    if (thread_stats->max_fsync_usec > iteration_stats->max_fsync_usec) {
#line 1046
      iteration_stats->max_fsync_usec = thread_stats->max_fsync_usec;
    }
#line 1049
    iteration_stats->avg_sync_usec += thread_stats->avg_sync_usec;
#line 1050
    if (iteration_stats->min_sync_usec == 0ULL) {
#line 1053
      iteration_stats->min_sync_usec = thread_stats->min_sync_usec;
    } else
#line 1050
    if (thread_stats->min_sync_usec < iteration_stats->min_sync_usec) {
#line 1053
      iteration_stats->min_sync_usec = thread_stats->min_sync_usec;
    }
#line 1055
    if (thread_stats->max_sync_usec > iteration_stats->max_sync_usec) {
#line 1057
      iteration_stats->max_sync_usec = thread_stats->max_sync_usec;
    }
#line 1060
    iteration_stats->avg_close_usec += thread_stats->avg_close_usec;
#line 1061
    if (iteration_stats->min_close_usec == 0ULL) {
#line 1064
      iteration_stats->min_close_usec = thread_stats->min_close_usec;
    } else
#line 1061
    if (thread_stats->min_close_usec < iteration_stats->min_close_usec) {
#line 1064
      iteration_stats->min_close_usec = thread_stats->min_close_usec;
    }
#line 1066
    if (thread_stats->max_close_usec > iteration_stats->max_close_usec) {
#line 1068
      iteration_stats->max_close_usec = thread_stats->max_close_usec;
    }
#line 1071
    iteration_stats->avg_unlink_usec += thread_stats->avg_unlink_usec;
#line 1073
    if (iteration_stats->min_unlink_usec == 0ULL) {
#line 1076
      iteration_stats->min_unlink_usec = thread_stats->min_unlink_usec;
    } else
#line 1073
    if (thread_stats->min_unlink_usec < iteration_stats->min_unlink_usec) {
#line 1076
      iteration_stats->min_unlink_usec = thread_stats->min_unlink_usec;
    }
#line 1078
    if (thread_stats->max_unlink_usec > iteration_stats->max_unlink_usec) {
#line 1080
      iteration_stats->max_unlink_usec = thread_stats->max_unlink_usec;
    }
#line 1000
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1087
  if (num_threads > 1) {
#line 1088
    iteration_stats->avg_creat_usec /= (unsigned long long )num_threads;
#line 1090
    iteration_stats->avg_write_usec /= (unsigned long long )num_threads;
#line 1092
    iteration_stats->avg_fsync_usec /= (unsigned long long )num_threads;
#line 1094
    iteration_stats->avg_sync_usec /= (unsigned long long )num_threads;
#line 1096
    iteration_stats->avg_close_usec /= (unsigned long long )num_threads;
#line 1098
    iteration_stats->avg_unlink_usec /= (unsigned long long )num_threads;
  }
#line 1102
  return;
}
}
#line 1108 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
void thread_work(pid_t my_pid ) 
{ 


  {
  {
#line 1114
  setup(my_pid);
#line 1116
  do_run(my_pid);
#line 1118
  fclose(child_log_file_fp);
  }
#line 1119
  return;
}
}
#line 1126 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
void fork_threads(void) 
{ 
  int i ;
  int active_kids ;
  int *tmp ;
  char *tmp___0 ;
  pid_t tmp___1 ;
  int status ;
  pid_t child_pid ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 1128
  active_kids = 0;
#line 1133
  fflush(stdout);
#line 1134
  fflush(log_file_fp);
#line 1140
  i = 0;
  }
  {
#line 1140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1140
    if (! (i < num_threads)) {
#line 1140
      goto while_break;
    }
    {
#line 1141
    tmp___1 = fork();
#line 1141
    child_tasks[i].child_pid = tmp___1;
    }
#line 1141
    if (tmp___1 == -1) {
      {
#line 1142
      tmp = __errno_location();
#line 1142
      tmp___0 = strerror(*tmp);
#line 1142
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fs_mark: fork failed: %s\n",
              tmp___0);
#line 1144
      cleanup_exit();
      }
    }
#line 1146
    if (child_tasks[i].child_pid == 0) {
      {
#line 1152
      child_tasks[i].child_pid = getpid();
#line 1153
      thread_work(child_tasks[i].child_pid);
#line 1158
      exit(0);
      }
    }
#line 1160
    active_kids ++;
#line 1140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1166
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1166
    if (! active_kids) {
#line 1166
      goto while_break___0;
    }
    {
#line 1174
    child_pid = wait((union wait *)(& status));
    }
#line 1175
    if (child_pid == -1) {
      {
#line 1176
      tmp___2 = __errno_location();
      }
#line 1176
      if (*tmp___2 == 4) {
#line 1177
        goto while_continue___0;
      }
      {
#line 1178
      tmp___3 = __errno_location();
#line 1178
      tmp___4 = strerror(*tmp___3);
#line 1178
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fs_mark: wait failed: %s\n",
              tmp___4);
#line 1180
      exit(0);
      }
    }
#line 1186
    i = 0;
    {
#line 1186
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1186
      if (! (i < num_threads)) {
#line 1186
        goto while_break___1;
      }
#line 1187
      if (child_tasks[i].child_pid == child_pid) {
#line 1188
        active_kids --;
#line 1189
        goto while_break___1;
      }
#line 1186
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1193
  return;
}
}
#line 1199 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
void print_run_info(FILE *log_fp , int argc , char **argv ) 
{ 
  time_t time_run ;
  int i ;
  char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1204
  time_run = time((time_t *)0);
#line 1205
  fprintf((FILE */* __restrict  */)log_fp, (char const   */* __restrict  */)"\n# ");
#line 1206
  i = 0;
  }
  {
#line 1206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1206
    if (! (i < argc)) {
#line 1206
      goto while_break;
    }
    {
#line 1207
    fprintf((FILE */* __restrict  */)log_fp, (char const   */* __restrict  */)" %s ",
            *(argv + i));
#line 1206
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1208
  tmp = ctime((time_t const   *)(& time_run));
#line 1208
  fprintf((FILE */* __restrict  */)log_fp, (char const   */* __restrict  */)"\n#\tVersion %s, %d thread(s) starting at %s",
          fs_mark_version, num_threads, tmp);
#line 1210
  fprintf((FILE */* __restrict  */)log_fp, (char const   */* __restrict  */)"#\tSync method: %s\n",
          sync_policy_string[sync_method_type]);
  }
#line 1212
  if (num_subdirs > 1) {
#line 1213
    if (dir_policy == 1) {
#line 1213
      tmp___0 = "files per subdirectory";
    } else {
#line 1213
      tmp___0 = "seconds per subdirectory";
    }
#line 1213
    if (dir_policy == 1) {
#line 1213
      tmp___1 = num_per_subdir;
    } else {
#line 1213
      tmp___1 = (int )secs_per_directory;
    }
    {
#line 1213
    fprintf((FILE */* __restrict  */)log_fp, (char const   */* __restrict  */)"#\tDirectories:  %s across %d subdirectories with %d %s.\n",
            dir_policy_string[dir_policy], num_subdirs, tmp___1, tmp___0);
    }
  } else {
    {
#line 1221
    fprintf((FILE */* __restrict  */)log_fp, (char const   */* __restrict  */)"#\tDirectories:  no subdirectories used\n");
    }
  }
  {
#line 1222
  fprintf((FILE */* __restrict  */)log_fp, (char const   */* __restrict  */)"#\tFile names: %d bytes long, (%d initial bytes of time stamp with %d random bytes at end of name)\n",
          name_len, name_len - rand_len, rand_len);
#line 1225
  fprintf((FILE */* __restrict  */)log_fp, (char const   */* __restrict  */)"#\tFiles info: size %d bytes, written with an IO size of %d bytes per write\n",
          file_size, io_buffer_size);
#line 1228
  fprintf((FILE */* __restrict  */)log_fp, (char const   */* __restrict  */)"#\tApp overhead is time in microseconds spent in the test not doing file writing related system calls.\n");
  }
#line 1231
  if ((unsigned long )log_fp != (unsigned long )stdout) {
    {
#line 1232
    fprintf((FILE */* __restrict  */)log_fp, (char const   */* __restrict  */)"#");
    }
  }
#line 1233
  if (verbose_stats) {
    {
#line 1234
    fprintf((FILE */* __restrict  */)log_fp, (char const   */* __restrict  */)"#\tAll system call times are reported in microseconds.\n\n");
#line 1236
    fprintf((FILE */* __restrict  */)log_fp, (char const   */* __restrict  */)"%6s %12s %12s %12s %16s %26s %26s %26s %26s %26s %26s\n",
            "FSUse%", "Count", "Size", "Files/sec", "App Overhead", "CREAT (Min/Avg/Max)",
            "WRITE (Min/Avg/Max)", "FSYNC (Min/Avg/Max)", "SYNC (Min/Avg/Max)", "CLOSE (Min/Avg/Max)",
            "UNLINK (Min/Avg/Max)");
    }
  } else {
    {
#line 1243
    fprintf((FILE */* __restrict  */)log_fp, (char const   */* __restrict  */)"\n");
#line 1244
    fprintf((FILE */* __restrict  */)log_fp, (char const   */* __restrict  */)"%6s %12s %12s %12s %16s\n",
            "FSUse%", "Count", "Size", "Files/sec", "App Overhead");
    }
  }
#line 1248
  return;
}
}
#line 1255 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
void print_iteration_stats(FILE *log_fp , fs_mark_stat_t *iteration_stats , unsigned int files_written ) 
{ 
  int df_full ;

  {
  {
#line 1263
  df_full = get_df_full(child_tasks[0].test_dir);
  }
#line 1265
  if (verbose_stats) {
    {
#line 1266
    fprintf((FILE */* __restrict  */)log_fp, (char const   */* __restrict  */)"%6u %12u %12u %12.1f %16llu %8llu %8llu %8llu %8llu %8llu %8llu %8llu %8llu %8llu %8llu %8llu %8llu %8llu %8llu %8llu %8llu %8llu %8llu\n",
            df_full, files_written, file_size, (double )iteration_stats->files_per_sec,
            iteration_stats->app_overhead_usec, iteration_stats->min_creat_usec, iteration_stats->avg_creat_usec,
            iteration_stats->max_creat_usec, iteration_stats->min_write_usec, iteration_stats->avg_write_usec,
            iteration_stats->max_write_usec, iteration_stats->min_fsync_usec, iteration_stats->avg_fsync_usec,
            iteration_stats->max_fsync_usec, iteration_stats->min_sync_usec, iteration_stats->avg_sync_usec,
            iteration_stats->max_sync_usec, iteration_stats->min_close_usec, iteration_stats->avg_close_usec,
            iteration_stats->max_close_usec, iteration_stats->min_unlink_usec, iteration_stats->avg_unlink_usec,
            iteration_stats->max_unlink_usec);
    }
  } else {
    {
#line 1292
    fprintf((FILE */* __restrict  */)log_fp, (char const   */* __restrict  */)"%6u %12u %12u %12.1f %16llu\n",
            df_full, files_written, file_size, (double )iteration_stats->files_per_sec,
            iteration_stats->app_overhead_usec);
    }
  }
  {
#line 1300
  fflush(log_fp);
  }
#line 1301
  return;
}
}
#line 1304 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/fs_mark.c"
int main(int argc , char **argv , char **envp ) 
{ 
  unsigned int files_written ;
  unsigned int loops_done ;
  int *tmp ;
  char *tmp___0 ;
  fs_mark_stat_t thread_stats ;
  fs_mark_stat_t iteration_stats ;

  {
  {
#line 1306
  files_written = 0U;
#line 1307
  loops_done = 0U;
#line 1309
  process_args(argc, argv, envp);
#line 1315
  log_file_fp = fopen((char const   */* __restrict  */)(log_file_name), (char const   */* __restrict  */)"a");
  }
#line 1315
  if ((unsigned long )log_file_fp == (unsigned long )((void *)0)) {
    {
#line 1316
    tmp = __errno_location();
#line 1316
    tmp___0 = strerror(*tmp);
#line 1316
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fs_mark: failed to fopen log file: %s %s\n",
            log_file_name, tmp___0);
#line 1319
    cleanup_exit();
    }
  }
  {
#line 1325
  print_run_info(stdout, argc, argv);
#line 1326
  print_run_info(log_file_fp, argc, argv);
  }
  {
#line 1332
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1335
    memset((void *)(& thread_stats), 0, sizeof(thread_stats));
#line 1336
    memset((void *)(& iteration_stats), 0, sizeof(iteration_stats));
#line 1338
    fork_threads();
#line 1345
    aggregate_thread_stats(& thread_stats, & iteration_stats);
#line 1350
    files_written += iteration_stats.file_count;
#line 1352
    print_iteration_stats(stdout, & iteration_stats, files_written);
#line 1353
    print_iteration_stats(log_file_fp, & iteration_stats, files_written);
#line 1355
    loops_done ++;
    }
#line 1332
    if (! do_fill_fs) {
#line 1332
      if (! (loop_count > loops_done)) {
#line 1332
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1359
  return (0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/lib_timing.c"
static struct timeval start_tv  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/lib_timing.c"
static struct timeval stop_tv  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/lib_timing.c"
unsigned long long tvnow(void) 
{ 
  unsigned long long usec_time ;
  struct timeval now ;

  {
  {
#line 62
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((struct timezone *)0));
#line 67
  usec_time = (unsigned long long )now.tv_sec;
#line 68
  usec_time *= 1000000ULL;
#line 69
  usec_time += (unsigned long long )now.tv_usec;
  }
#line 71
  return (usec_time);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/lib_timing.c"
void start(struct timeval *tv ) 
{ 


  {
#line 81
  if ((unsigned long )tv == (unsigned long )((void *)0)) {
#line 82
    tv = & start_tv;
  }
  {
#line 84
  gettimeofday((struct timeval */* __restrict  */)tv, (__timezone_ptr_t )((struct timezone *)0));
  }
#line 85
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/lib_timing.c"
void tvsub(struct timeval *tdiff , struct timeval *t1 , struct timeval *t0 ) 
{ 


  {
#line 90
  tdiff->tv_sec = t1->tv_sec - t0->tv_sec;
#line 91
  tdiff->tv_usec = t1->tv_usec - t0->tv_usec;
#line 92
  if (tdiff->tv_usec < 0L) {
#line 92
    if (tdiff->tv_sec > 0L) {
#line 93
      (tdiff->tv_sec) --;
#line 94
      tdiff->tv_usec += 1000000L;
#line 95
      if (tdiff->tv_usec < 0L) {
        {
#line 96
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lat_fs: tvsub shows test time ran backwards!\n");
#line 97
        exit(1);
        }
      }
    }
  }
#line 102
  if (tdiff->tv_usec < 0L) {
#line 103
    tdiff->tv_sec = (__time_t )0;
#line 104
    tdiff->tv_usec = (__suseconds_t )0;
  } else
#line 102
  if (t1->tv_sec < t0->tv_sec) {
#line 103
    tdiff->tv_sec = (__time_t )0;
#line 104
    tdiff->tv_usec = (__suseconds_t )0;
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/lib_timing.c"
unsigned long long tvdelta(struct timeval *start___0 , struct timeval *stop___0 ) 
{ 
  struct timeval td ;
  unsigned long long usecs ;

  {
  {
#line 114
  tvsub(& td, stop___0, start___0);
#line 115
  usecs = (unsigned long long )td.tv_sec;
#line 116
  usecs *= 1000000ULL;
#line 117
  usecs += (unsigned long long )td.tv_usec;
  }
#line 118
  return (usecs);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/fsmark-3.3/lib_timing.c"
unsigned long long stop(struct timeval *begin , struct timeval *end ) 
{ 
  unsigned long long tmp ;

  {
#line 127
  if ((unsigned long )end == (unsigned long )((void *)0)) {
#line 128
    end = & stop_tv;
  }
  {
#line 130
  gettimeofday((struct timeval */* __restrict  */)end, (__timezone_ptr_t )((struct timezone *)0));
  }
#line 132
  if ((unsigned long )begin == (unsigned long )((void *)0)) {
#line 133
    begin = & start_tv;
  }
  {
#line 135
  tmp = tvdelta(begin, end);
  }
#line 135
  return (tmp);
}
}
